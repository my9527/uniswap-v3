{"version":3,"file":"static/js/379.45e654d8.chunk.js","mappings":"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","sources":["../node_modules/ajv/lib/ajv.ts","../node_modules/ajv/lib/compile/codegen/code.ts","../node_modules/ajv/lib/compile/codegen/index.ts","../node_modules/ajv/lib/compile/codegen/scope.ts","../node_modules/ajv/lib/compile/errors.ts","../node_modules/ajv/lib/compile/index.ts","../node_modules/ajv/lib/compile/names.ts","../node_modules/ajv/lib/compile/ref_error.ts","../node_modules/ajv/lib/compile/resolve.ts","../node_modules/ajv/lib/compile/rules.ts","../node_modules/ajv/lib/compile/util.ts","../node_modules/ajv/lib/compile/validate/applicability.ts","../node_modules/ajv/lib/compile/validate/boolSchema.ts","../node_modules/ajv/lib/compile/validate/dataType.ts","../node_modules/ajv/lib/compile/validate/defaults.ts","../node_modules/ajv/lib/compile/validate/index.ts","../node_modules/ajv/lib/compile/validate/keyword.ts","../node_modules/ajv/lib/compile/validate/subschema.ts","../node_modules/ajv/lib/core.ts","../node_modules/ajv/lib/runtime/equal.ts","../node_modules/ajv/lib/runtime/ucs2length.ts","../node_modules/ajv/lib/runtime/uri.ts","../node_modules/ajv/lib/runtime/validation_error.ts","../node_modules/ajv/lib/vocabularies/applicator/additionalItems.ts","../node_modules/ajv/lib/vocabularies/applicator/additionalProperties.ts","../node_modules/ajv/lib/vocabularies/applicator/allOf.ts","../node_modules/ajv/lib/vocabularies/applicator/anyOf.ts","../node_modules/ajv/lib/vocabularies/applicator/contains.ts","../node_modules/ajv/lib/vocabularies/applicator/dependencies.ts","../node_modules/ajv/lib/vocabularies/applicator/if.ts","../node_modules/ajv/lib/vocabularies/applicator/index.ts","../node_modules/ajv/lib/vocabularies/applicator/items.ts","../node_modules/ajv/lib/vocabularies/applicator/items2020.ts","../node_modules/ajv/lib/vocabularies/applicator/not.ts","../node_modules/ajv/lib/vocabularies/applicator/oneOf.ts","../node_modules/ajv/lib/vocabularies/applicator/patternProperties.ts","../node_modules/ajv/lib/vocabularies/applicator/prefixItems.ts","../node_modules/ajv/lib/vocabularies/applicator/properties.ts","../node_modules/ajv/lib/vocabularies/applicator/propertyNames.ts","../node_modules/ajv/lib/vocabularies/applicator/thenElse.ts","../node_modules/ajv/lib/vocabularies/code.ts","../node_modules/ajv/lib/vocabularies/core/id.ts","../node_modules/ajv/lib/vocabularies/core/index.ts","../node_modules/ajv/lib/vocabularies/core/ref.ts","../node_modules/ajv/lib/vocabularies/discriminator/index.ts","../node_modules/ajv/lib/vocabularies/discriminator/types.ts","../node_modules/ajv/lib/vocabularies/draft7.ts","../node_modules/ajv/lib/vocabularies/format/format.ts","../node_modules/ajv/lib/vocabularies/format/index.ts","../node_modules/ajv/lib/vocabularies/metadata.ts","../node_modules/ajv/lib/vocabularies/validation/const.ts","../node_modules/ajv/lib/vocabularies/validation/enum.ts","../node_modules/ajv/lib/vocabularies/validation/index.ts","../node_modules/ajv/lib/vocabularies/validation/limitItems.ts","../node_modules/ajv/lib/vocabularies/validation/limitLength.ts","../node_modules/ajv/lib/vocabularies/validation/limitNumber.ts","../node_modules/ajv/lib/vocabularies/validation/limitProperties.ts","../node_modules/ajv/lib/vocabularies/validation/multipleOf.ts","../node_modules/ajv/lib/vocabularies/validation/pattern.ts","../node_modules/ajv/lib/vocabularies/validation/required.ts","../node_modules/ajv/lib/vocabularies/validation/uniqueItems.ts","../node_modules/ajv/node_modules/json-schema-traverse/index.js","../node_modules/fast-deep-equal/index.js","../node_modules/uri-js/src/util.ts","../node_modules/uri-js/src/regexps-uri.ts","../node_modules/uri-js/src/regexps-iri.ts","../node_modules/uri-js/node_modules/punycode/punycode.es6.js","../node_modules/uri-js/src/uri.ts","../node_modules/uri-js/src/schemes/http.ts","../node_modules/uri-js/src/schemes/https.ts","../node_modules/uri-js/src/schemes/ws.ts","../node_modules/uri-js/src/schemes/wss.ts","../node_modules/uri-js/src/schemes/mailto.ts","../node_modules/uri-js/src/schemes/urn.ts","../node_modules/uri-js/src/schemes/urn-uuid.ts","../node_modules/uri-js/src/index.ts"],"sourcesContent":["import type {AnySchemaObject} from \"./types\"\nimport AjvCore from \"./core\"\nimport draft7Vocabularies from \"./vocabularies/draft7\"\nimport discriminator from \"./vocabularies/discriminator\"\nimport * as draft7MetaSchema from \"./refs/json-schema-draft-07.json\"\n\nconst META_SUPPORT_DATA = [\"/properties\"]\n\nconst META_SCHEMA_ID = \"http://json-schema.org/draft-07/schema\"\n\nclass Ajv extends AjvCore {\n  _addVocabularies(): void {\n    super._addVocabularies()\n    draft7Vocabularies.forEach((v) => this.addVocabulary(v))\n    if (this.opts.discriminator) this.addKeyword(discriminator)\n  }\n\n  _addDefaultMetaSchema(): void {\n    super._addDefaultMetaSchema()\n    if (!this.opts.meta) return\n    const metaSchema = this.opts.$data\n      ? this.$dataMetaSchema(draft7MetaSchema, META_SUPPORT_DATA)\n      : draft7MetaSchema\n    this.addMetaSchema(metaSchema, META_SCHEMA_ID, false)\n    this.refs[\"http://json-schema.org/schema\"] = META_SCHEMA_ID\n  }\n\n  defaultMeta(): string | AnySchemaObject | undefined {\n    return (this.opts.defaultMeta =\n      super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : undefined))\n  }\n}\n\nmodule.exports = exports = Ajv\nObject.defineProperty(exports, \"__esModule\", {value: true})\n\nexport default Ajv\n\nexport {\n  Format,\n  FormatDefinition,\n  AsyncFormatDefinition,\n  KeywordDefinition,\n  KeywordErrorDefinition,\n  CodeKeywordDefinition,\n  MacroKeywordDefinition,\n  FuncKeywordDefinition,\n  Vocabulary,\n  Schema,\n  SchemaObject,\n  AnySchemaObject,\n  AsyncSchema,\n  AnySchema,\n  ValidateFunction,\n  AsyncValidateFunction,\n  SchemaValidateFunction,\n  ErrorObject,\n  ErrorNoParams,\n} from \"./types\"\n\nexport {Plugin, Options, CodeOptions, InstanceOptions, Logger, ErrorsTextOptions} from \"./core\"\nexport {SchemaCxt, SchemaObjCxt} from \"./compile\"\nexport {KeywordCxt} from \"./compile/validate\"\nexport {DefinedError} from \"./vocabularies/errors\"\nexport {JSONType} from \"./compile/rules\"\nexport {JSONSchemaType} from \"./types/json-schema\"\nexport {_, str, stringify, nil, Name, Code, CodeGen, CodeGenOptions} from \"./compile/codegen\"\nexport {default as ValidationError} from \"./runtime/validation_error\"\nexport {default as MissingRefError} from \"./compile/ref_error\"\n","export abstract class _CodeOrName {\n  abstract readonly str: string\n  abstract readonly names: UsedNames\n  abstract toString(): string\n  abstract emptyStr(): boolean\n}\n\nexport const IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i\n\nexport class Name extends _CodeOrName {\n  readonly str: string\n  constructor(s: string) {\n    super()\n    if (!IDENTIFIER.test(s)) throw new Error(\"CodeGen: name must be a valid identifier\")\n    this.str = s\n  }\n\n  toString(): string {\n    return this.str\n  }\n\n  emptyStr(): boolean {\n    return false\n  }\n\n  get names(): UsedNames {\n    return {[this.str]: 1}\n  }\n}\n\nexport class _Code extends _CodeOrName {\n  readonly _items: readonly CodeItem[]\n  private _str?: string\n  private _names?: UsedNames\n\n  constructor(code: string | readonly CodeItem[]) {\n    super()\n    this._items = typeof code === \"string\" ? [code] : code\n  }\n\n  toString(): string {\n    return this.str\n  }\n\n  emptyStr(): boolean {\n    if (this._items.length > 1) return false\n    const item = this._items[0]\n    return item === \"\" || item === '\"\"'\n  }\n\n  get str(): string {\n    return (this._str ??= this._items.reduce((s: string, c: CodeItem) => `${s}${c}`, \"\"))\n  }\n\n  get names(): UsedNames {\n    return (this._names ??= this._items.reduce((names: UsedNames, c) => {\n      if (c instanceof Name) names[c.str] = (names[c.str] || 0) + 1\n      return names\n    }, {}))\n  }\n}\n\nexport type CodeItem = Name | string | number | boolean | null\n\nexport type UsedNames = Record<string, number | undefined>\n\nexport type Code = _Code | Name\n\nexport type SafeExpr = Code | number | boolean | null\n\nexport const nil = new _Code(\"\")\n\ntype CodeArg = SafeExpr | string | undefined\n\nexport function _(strs: TemplateStringsArray, ...args: CodeArg[]): _Code {\n  const code: CodeItem[] = [strs[0]]\n  let i = 0\n  while (i < args.length) {\n    addCodeArg(code, args[i])\n    code.push(strs[++i])\n  }\n  return new _Code(code)\n}\n\nconst plus = new _Code(\"+\")\n\nexport function str(strs: TemplateStringsArray, ...args: (CodeArg | string[])[]): _Code {\n  const expr: CodeItem[] = [safeStringify(strs[0])]\n  let i = 0\n  while (i < args.length) {\n    expr.push(plus)\n    addCodeArg(expr, args[i])\n    expr.push(plus, safeStringify(strs[++i]))\n  }\n  optimize(expr)\n  return new _Code(expr)\n}\n\nexport function addCodeArg(code: CodeItem[], arg: CodeArg | string[]): void {\n  if (arg instanceof _Code) code.push(...arg._items)\n  else if (arg instanceof Name) code.push(arg)\n  else code.push(interpolate(arg))\n}\n\nfunction optimize(expr: CodeItem[]): void {\n  let i = 1\n  while (i < expr.length - 1) {\n    if (expr[i] === plus) {\n      const res = mergeExprItems(expr[i - 1], expr[i + 1])\n      if (res !== undefined) {\n        expr.splice(i - 1, 3, res)\n        continue\n      }\n      expr[i++] = \"+\"\n    }\n    i++\n  }\n}\n\nfunction mergeExprItems(a: CodeItem, b: CodeItem): CodeItem | undefined {\n  if (b === '\"\"') return a\n  if (a === '\"\"') return b\n  if (typeof a == \"string\") {\n    if (b instanceof Name || a[a.length - 1] !== '\"') return\n    if (typeof b != \"string\") return `${a.slice(0, -1)}${b}\"`\n    if (b[0] === '\"') return a.slice(0, -1) + b.slice(1)\n    return\n  }\n  if (typeof b == \"string\" && b[0] === '\"' && !(a instanceof Name)) return `\"${a}${b.slice(1)}`\n  return\n}\n\nexport function strConcat(c1: Code, c2: Code): Code {\n  return c2.emptyStr() ? c1 : c1.emptyStr() ? c2 : str`${c1}${c2}`\n}\n\n// TODO do not allow arrays here\nfunction interpolate(x?: string | string[] | number | boolean | null): SafeExpr | string {\n  return typeof x == \"number\" || typeof x == \"boolean\" || x === null\n    ? x\n    : safeStringify(Array.isArray(x) ? x.join(\",\") : x)\n}\n\nexport function stringify(x: unknown): Code {\n  return new _Code(safeStringify(x))\n}\n\nexport function safeStringify(x: unknown): string {\n  return JSON.stringify(x)\n    .replace(/\\u2028/g, \"\\\\u2028\")\n    .replace(/\\u2029/g, \"\\\\u2029\")\n}\n\nexport function getProperty(key: Code | string | number): Code {\n  return typeof key == \"string\" && IDENTIFIER.test(key) ? new _Code(`.${key}`) : _`[${key}]`\n}\n\n//Does best effort to format the name properly\nexport function getEsmExportName(key: Code | string | number): Code {\n  if (typeof key == \"string\" && IDENTIFIER.test(key)) {\n    return new _Code(`${key}`)\n  }\n  throw new Error(`CodeGen: invalid export name: ${key}, use explicit $id name mapping`)\n}\n\nexport function regexpCode(rx: RegExp): Code {\n  return new _Code(rx.toString())\n}\n","import type {ScopeValueSets, NameValue, ValueScope, ValueScopeName} from \"./scope\"\nimport {_, nil, _Code, Code, Name, UsedNames, CodeItem, addCodeArg, _CodeOrName} from \"./code\"\nimport {Scope, varKinds} from \"./scope\"\n\nexport {_, str, strConcat, nil, getProperty, stringify, regexpCode, Name, Code} from \"./code\"\nexport {Scope, ScopeStore, ValueScope, ValueScopeName, ScopeValueSets, varKinds} from \"./scope\"\n\n// type for expressions that can be safely inserted in code without quotes\nexport type SafeExpr = Code | number | boolean | null\n\n// type that is either Code of function that adds code to CodeGen instance using its methods\nexport type Block = Code | (() => void)\n\nexport const operators = {\n  GT: new _Code(\">\"),\n  GTE: new _Code(\">=\"),\n  LT: new _Code(\"<\"),\n  LTE: new _Code(\"<=\"),\n  EQ: new _Code(\"===\"),\n  NEQ: new _Code(\"!==\"),\n  NOT: new _Code(\"!\"),\n  OR: new _Code(\"||\"),\n  AND: new _Code(\"&&\"),\n  ADD: new _Code(\"+\"),\n}\n\nabstract class Node {\n  abstract readonly names: UsedNames\n\n  optimizeNodes(): this | ChildNode | ChildNode[] | undefined {\n    return this\n  }\n\n  optimizeNames(_names: UsedNames, _constants: Constants): this | undefined {\n    return this\n  }\n\n  // get count(): number {\n  //   return 1\n  // }\n}\n\nclass Def extends Node {\n  constructor(private readonly varKind: Name, private readonly name: Name, private rhs?: SafeExpr) {\n    super()\n  }\n\n  render({es5, _n}: CGOptions): string {\n    const varKind = es5 ? varKinds.var : this.varKind\n    const rhs = this.rhs === undefined ? \"\" : ` = ${this.rhs}`\n    return `${varKind} ${this.name}${rhs};` + _n\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this | undefined {\n    if (!names[this.name.str]) return\n    if (this.rhs) this.rhs = optimizeExpr(this.rhs, names, constants)\n    return this\n  }\n\n  get names(): UsedNames {\n    return this.rhs instanceof _CodeOrName ? this.rhs.names : {}\n  }\n}\n\nclass Assign extends Node {\n  constructor(readonly lhs: Code, public rhs: SafeExpr, private readonly sideEffects?: boolean) {\n    super()\n  }\n\n  render({_n}: CGOptions): string {\n    return `${this.lhs} = ${this.rhs};` + _n\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this | undefined {\n    if (this.lhs instanceof Name && !names[this.lhs.str] && !this.sideEffects) return\n    this.rhs = optimizeExpr(this.rhs, names, constants)\n    return this\n  }\n\n  get names(): UsedNames {\n    const names = this.lhs instanceof Name ? {} : {...this.lhs.names}\n    return addExprNames(names, this.rhs)\n  }\n}\n\nclass AssignOp extends Assign {\n  constructor(lhs: Code, private readonly op: Code, rhs: SafeExpr, sideEffects?: boolean) {\n    super(lhs, rhs, sideEffects)\n  }\n\n  render({_n}: CGOptions): string {\n    return `${this.lhs} ${this.op}= ${this.rhs};` + _n\n  }\n}\n\nclass Label extends Node {\n  readonly names: UsedNames = {}\n  constructor(readonly label: Name) {\n    super()\n  }\n\n  render({_n}: CGOptions): string {\n    return `${this.label}:` + _n\n  }\n}\n\nclass Break extends Node {\n  readonly names: UsedNames = {}\n  constructor(readonly label?: Code) {\n    super()\n  }\n\n  render({_n}: CGOptions): string {\n    const label = this.label ? ` ${this.label}` : \"\"\n    return `break${label};` + _n\n  }\n}\n\nclass Throw extends Node {\n  constructor(readonly error: Code) {\n    super()\n  }\n\n  render({_n}: CGOptions): string {\n    return `throw ${this.error};` + _n\n  }\n\n  get names(): UsedNames {\n    return this.error.names\n  }\n}\n\nclass AnyCode extends Node {\n  constructor(private code: SafeExpr) {\n    super()\n  }\n\n  render({_n}: CGOptions): string {\n    return `${this.code};` + _n\n  }\n\n  optimizeNodes(): this | undefined {\n    return `${this.code}` ? this : undefined\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this {\n    this.code = optimizeExpr(this.code, names, constants)\n    return this\n  }\n\n  get names(): UsedNames {\n    return this.code instanceof _CodeOrName ? this.code.names : {}\n  }\n}\n\nabstract class ParentNode extends Node {\n  constructor(readonly nodes: ChildNode[] = []) {\n    super()\n  }\n\n  render(opts: CGOptions): string {\n    return this.nodes.reduce((code, n) => code + n.render(opts), \"\")\n  }\n\n  optimizeNodes(): this | ChildNode | ChildNode[] | undefined {\n    const {nodes} = this\n    let i = nodes.length\n    while (i--) {\n      const n = nodes[i].optimizeNodes()\n      if (Array.isArray(n)) nodes.splice(i, 1, ...n)\n      else if (n) nodes[i] = n\n      else nodes.splice(i, 1)\n    }\n    return nodes.length > 0 ? this : undefined\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this | undefined {\n    const {nodes} = this\n    let i = nodes.length\n    while (i--) {\n      // iterating backwards improves 1-pass optimization\n      const n = nodes[i]\n      if (n.optimizeNames(names, constants)) continue\n      subtractNames(names, n.names)\n      nodes.splice(i, 1)\n    }\n    return nodes.length > 0 ? this : undefined\n  }\n\n  get names(): UsedNames {\n    return this.nodes.reduce((names: UsedNames, n) => addNames(names, n.names), {})\n  }\n\n  // get count(): number {\n  //   return this.nodes.reduce((c, n) => c + n.count, 1)\n  // }\n}\n\nabstract class BlockNode extends ParentNode {\n  render(opts: CGOptions): string {\n    return \"{\" + opts._n + super.render(opts) + \"}\" + opts._n\n  }\n}\n\nclass Root extends ParentNode {}\n\nclass Else extends BlockNode {\n  static readonly kind = \"else\"\n}\n\nclass If extends BlockNode {\n  static readonly kind = \"if\"\n  else?: If | Else\n  constructor(private condition: Code | boolean, nodes?: ChildNode[]) {\n    super(nodes)\n  }\n\n  render(opts: CGOptions): string {\n    let code = `if(${this.condition})` + super.render(opts)\n    if (this.else) code += \"else \" + this.else.render(opts)\n    return code\n  }\n\n  optimizeNodes(): If | ChildNode[] | undefined {\n    super.optimizeNodes()\n    const cond = this.condition\n    if (cond === true) return this.nodes // else is ignored here\n    let e = this.else\n    if (e) {\n      const ns = e.optimizeNodes()\n      e = this.else = Array.isArray(ns) ? new Else(ns) : (ns as Else | undefined)\n    }\n    if (e) {\n      if (cond === false) return e instanceof If ? e : e.nodes\n      if (this.nodes.length) return this\n      return new If(not(cond), e instanceof If ? [e] : e.nodes)\n    }\n    if (cond === false || !this.nodes.length) return undefined\n    return this\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this | undefined {\n    this.else = this.else?.optimizeNames(names, constants)\n    if (!(super.optimizeNames(names, constants) || this.else)) return\n    this.condition = optimizeExpr(this.condition, names, constants)\n    return this\n  }\n\n  get names(): UsedNames {\n    const names = super.names\n    addExprNames(names, this.condition)\n    if (this.else) addNames(names, this.else.names)\n    return names\n  }\n\n  // get count(): number {\n  //   return super.count + (this.else?.count || 0)\n  // }\n}\n\nabstract class For extends BlockNode {\n  static readonly kind = \"for\"\n}\n\nclass ForLoop extends For {\n  constructor(private iteration: Code) {\n    super()\n  }\n\n  render(opts: CGOptions): string {\n    return `for(${this.iteration})` + super.render(opts)\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this | undefined {\n    if (!super.optimizeNames(names, constants)) return\n    this.iteration = optimizeExpr(this.iteration, names, constants)\n    return this\n  }\n\n  get names(): UsedNames {\n    return addNames(super.names, this.iteration.names)\n  }\n}\n\nclass ForRange extends For {\n  constructor(\n    private readonly varKind: Name,\n    private readonly name: Name,\n    private readonly from: SafeExpr,\n    private readonly to: SafeExpr\n  ) {\n    super()\n  }\n\n  render(opts: CGOptions): string {\n    const varKind = opts.es5 ? varKinds.var : this.varKind\n    const {name, from, to} = this\n    return `for(${varKind} ${name}=${from}; ${name}<${to}; ${name}++)` + super.render(opts)\n  }\n\n  get names(): UsedNames {\n    const names = addExprNames(super.names, this.from)\n    return addExprNames(names, this.to)\n  }\n}\n\nclass ForIter extends For {\n  constructor(\n    private readonly loop: \"of\" | \"in\",\n    private readonly varKind: Name,\n    private readonly name: Name,\n    private iterable: Code\n  ) {\n    super()\n  }\n\n  render(opts: CGOptions): string {\n    return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts)\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this | undefined {\n    if (!super.optimizeNames(names, constants)) return\n    this.iterable = optimizeExpr(this.iterable, names, constants)\n    return this\n  }\n\n  get names(): UsedNames {\n    return addNames(super.names, this.iterable.names)\n  }\n}\n\nclass Func extends BlockNode {\n  static readonly kind = \"func\"\n  constructor(public name: Name, public args: Code, public async?: boolean) {\n    super()\n  }\n\n  render(opts: CGOptions): string {\n    const _async = this.async ? \"async \" : \"\"\n    return `${_async}function ${this.name}(${this.args})` + super.render(opts)\n  }\n}\n\nclass Return extends ParentNode {\n  static readonly kind = \"return\"\n\n  render(opts: CGOptions): string {\n    return \"return \" + super.render(opts)\n  }\n}\n\nclass Try extends BlockNode {\n  catch?: Catch\n  finally?: Finally\n\n  render(opts: CGOptions): string {\n    let code = \"try\" + super.render(opts)\n    if (this.catch) code += this.catch.render(opts)\n    if (this.finally) code += this.finally.render(opts)\n    return code\n  }\n\n  optimizeNodes(): this {\n    super.optimizeNodes()\n    this.catch?.optimizeNodes() as Catch | undefined\n    this.finally?.optimizeNodes() as Finally | undefined\n    return this\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this {\n    super.optimizeNames(names, constants)\n    this.catch?.optimizeNames(names, constants)\n    this.finally?.optimizeNames(names, constants)\n    return this\n  }\n\n  get names(): UsedNames {\n    const names = super.names\n    if (this.catch) addNames(names, this.catch.names)\n    if (this.finally) addNames(names, this.finally.names)\n    return names\n  }\n\n  // get count(): number {\n  //   return super.count + (this.catch?.count || 0) + (this.finally?.count || 0)\n  // }\n}\n\nclass Catch extends BlockNode {\n  static readonly kind = \"catch\"\n  constructor(readonly error: Name) {\n    super()\n  }\n\n  render(opts: CGOptions): string {\n    return `catch(${this.error})` + super.render(opts)\n  }\n}\n\nclass Finally extends BlockNode {\n  static readonly kind = \"finally\"\n  render(opts: CGOptions): string {\n    return \"finally\" + super.render(opts)\n  }\n}\n\ntype StartBlockNode = If | For | Func | Return | Try\n\ntype LeafNode = Def | Assign | Label | Break | Throw | AnyCode\n\ntype ChildNode = StartBlockNode | LeafNode\n\ntype EndBlockNodeType =\n  | typeof If\n  | typeof Else\n  | typeof For\n  | typeof Func\n  | typeof Return\n  | typeof Catch\n  | typeof Finally\n\ntype Constants = Record<string, SafeExpr | undefined>\n\nexport interface CodeGenOptions {\n  es5?: boolean\n  lines?: boolean\n  ownProperties?: boolean\n}\n\ninterface CGOptions extends CodeGenOptions {\n  _n: \"\\n\" | \"\"\n}\n\nexport class CodeGen {\n  readonly _scope: Scope\n  readonly _extScope: ValueScope\n  readonly _values: ScopeValueSets = {}\n  private readonly _nodes: ParentNode[]\n  private readonly _blockStarts: number[] = []\n  private readonly _constants: Constants = {}\n  private readonly opts: CGOptions\n\n  constructor(extScope: ValueScope, opts: CodeGenOptions = {}) {\n    this.opts = {...opts, _n: opts.lines ? \"\\n\" : \"\"}\n    this._extScope = extScope\n    this._scope = new Scope({parent: extScope})\n    this._nodes = [new Root()]\n  }\n\n  toString(): string {\n    return this._root.render(this.opts)\n  }\n\n  // returns unique name in the internal scope\n  name(prefix: string): Name {\n    return this._scope.name(prefix)\n  }\n\n  // reserves unique name in the external scope\n  scopeName(prefix: string): ValueScopeName {\n    return this._extScope.name(prefix)\n  }\n\n  // reserves unique name in the external scope and assigns value to it\n  scopeValue(prefixOrName: ValueScopeName | string, value: NameValue): Name {\n    const name = this._extScope.value(prefixOrName, value)\n    const vs = this._values[name.prefix] || (this._values[name.prefix] = new Set())\n    vs.add(name)\n    return name\n  }\n\n  getScopeValue(prefix: string, keyOrRef: unknown): ValueScopeName | undefined {\n    return this._extScope.getValue(prefix, keyOrRef)\n  }\n\n  // return code that assigns values in the external scope to the names that are used internally\n  // (same names that were returned by gen.scopeName or gen.scopeValue)\n  scopeRefs(scopeName: Name): Code {\n    return this._extScope.scopeRefs(scopeName, this._values)\n  }\n\n  scopeCode(): Code {\n    return this._extScope.scopeCode(this._values)\n  }\n\n  private _def(\n    varKind: Name,\n    nameOrPrefix: Name | string,\n    rhs?: SafeExpr,\n    constant?: boolean\n  ): Name {\n    const name = this._scope.toName(nameOrPrefix)\n    if (rhs !== undefined && constant) this._constants[name.str] = rhs\n    this._leafNode(new Def(varKind, name, rhs))\n    return name\n  }\n\n  // `const` declaration (`var` in es5 mode)\n  const(nameOrPrefix: Name | string, rhs: SafeExpr, _constant?: boolean): Name {\n    return this._def(varKinds.const, nameOrPrefix, rhs, _constant)\n  }\n\n  // `let` declaration with optional assignment (`var` in es5 mode)\n  let(nameOrPrefix: Name | string, rhs?: SafeExpr, _constant?: boolean): Name {\n    return this._def(varKinds.let, nameOrPrefix, rhs, _constant)\n  }\n\n  // `var` declaration with optional assignment\n  var(nameOrPrefix: Name | string, rhs?: SafeExpr, _constant?: boolean): Name {\n    return this._def(varKinds.var, nameOrPrefix, rhs, _constant)\n  }\n\n  // assignment code\n  assign(lhs: Code, rhs: SafeExpr, sideEffects?: boolean): CodeGen {\n    return this._leafNode(new Assign(lhs, rhs, sideEffects))\n  }\n\n  // `+=` code\n  add(lhs: Code, rhs: SafeExpr): CodeGen {\n    return this._leafNode(new AssignOp(lhs, operators.ADD, rhs))\n  }\n\n  // appends passed SafeExpr to code or executes Block\n  code(c: Block | SafeExpr): CodeGen {\n    if (typeof c == \"function\") c()\n    else if (c !== nil) this._leafNode(new AnyCode(c))\n    return this\n  }\n\n  // returns code for object literal for the passed argument list of key-value pairs\n  object(...keyValues: [Name | string, SafeExpr | string][]): _Code {\n    const code: CodeItem[] = [\"{\"]\n    for (const [key, value] of keyValues) {\n      if (code.length > 1) code.push(\",\")\n      code.push(key)\n      if (key !== value || this.opts.es5) {\n        code.push(\":\")\n        addCodeArg(code, value)\n      }\n    }\n    code.push(\"}\")\n    return new _Code(code)\n  }\n\n  // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)\n  if(condition: Code | boolean, thenBody?: Block, elseBody?: Block): CodeGen {\n    this._blockNode(new If(condition))\n\n    if (thenBody && elseBody) {\n      this.code(thenBody).else().code(elseBody).endIf()\n    } else if (thenBody) {\n      this.code(thenBody).endIf()\n    } else if (elseBody) {\n      throw new Error('CodeGen: \"else\" body without \"then\" body')\n    }\n    return this\n  }\n\n  // `else if` clause - invalid without `if` or after `else` clauses\n  elseIf(condition: Code | boolean): CodeGen {\n    return this._elseNode(new If(condition))\n  }\n\n  // `else` clause - only valid after `if` or `else if` clauses\n  else(): CodeGen {\n    return this._elseNode(new Else())\n  }\n\n  // end `if` statement (needed if gen.if was used only with condition)\n  endIf(): CodeGen {\n    return this._endBlockNode(If, Else)\n  }\n\n  private _for(node: For, forBody?: Block): CodeGen {\n    this._blockNode(node)\n    if (forBody) this.code(forBody).endFor()\n    return this\n  }\n\n  // a generic `for` clause (or statement if `forBody` is passed)\n  for(iteration: Code, forBody?: Block): CodeGen {\n    return this._for(new ForLoop(iteration), forBody)\n  }\n\n  // `for` statement for a range of values\n  forRange(\n    nameOrPrefix: Name | string,\n    from: SafeExpr,\n    to: SafeExpr,\n    forBody: (index: Name) => void,\n    varKind: Code = this.opts.es5 ? varKinds.var : varKinds.let\n  ): CodeGen {\n    const name = this._scope.toName(nameOrPrefix)\n    return this._for(new ForRange(varKind, name, from, to), () => forBody(name))\n  }\n\n  // `for-of` statement (in es5 mode replace with a normal for loop)\n  forOf(\n    nameOrPrefix: Name | string,\n    iterable: Code,\n    forBody: (item: Name) => void,\n    varKind: Code = varKinds.const\n  ): CodeGen {\n    const name = this._scope.toName(nameOrPrefix)\n    if (this.opts.es5) {\n      const arr = iterable instanceof Name ? iterable : this.var(\"_arr\", iterable)\n      return this.forRange(\"_i\", 0, _`${arr}.length`, (i) => {\n        this.var(name, _`${arr}[${i}]`)\n        forBody(name)\n      })\n    }\n    return this._for(new ForIter(\"of\", varKind, name, iterable), () => forBody(name))\n  }\n\n  // `for-in` statement.\n  // With option `ownProperties` replaced with a `for-of` loop for object keys\n  forIn(\n    nameOrPrefix: Name | string,\n    obj: Code,\n    forBody: (item: Name) => void,\n    varKind: Code = this.opts.es5 ? varKinds.var : varKinds.const\n  ): CodeGen {\n    if (this.opts.ownProperties) {\n      return this.forOf(nameOrPrefix, _`Object.keys(${obj})`, forBody)\n    }\n    const name = this._scope.toName(nameOrPrefix)\n    return this._for(new ForIter(\"in\", varKind, name, obj), () => forBody(name))\n  }\n\n  // end `for` loop\n  endFor(): CodeGen {\n    return this._endBlockNode(For)\n  }\n\n  // `label` statement\n  label(label: Name): CodeGen {\n    return this._leafNode(new Label(label))\n  }\n\n  // `break` statement\n  break(label?: Code): CodeGen {\n    return this._leafNode(new Break(label))\n  }\n\n  // `return` statement\n  return(value: Block | SafeExpr): CodeGen {\n    const node = new Return()\n    this._blockNode(node)\n    this.code(value)\n    if (node.nodes.length !== 1) throw new Error('CodeGen: \"return\" should have one node')\n    return this._endBlockNode(Return)\n  }\n\n  // `try` statement\n  try(tryBody: Block, catchCode?: (e: Name) => void, finallyCode?: Block): CodeGen {\n    if (!catchCode && !finallyCode) throw new Error('CodeGen: \"try\" without \"catch\" and \"finally\"')\n    const node = new Try()\n    this._blockNode(node)\n    this.code(tryBody)\n    if (catchCode) {\n      const error = this.name(\"e\")\n      this._currNode = node.catch = new Catch(error)\n      catchCode(error)\n    }\n    if (finallyCode) {\n      this._currNode = node.finally = new Finally()\n      this.code(finallyCode)\n    }\n    return this._endBlockNode(Catch, Finally)\n  }\n\n  // `throw` statement\n  throw(error: Code): CodeGen {\n    return this._leafNode(new Throw(error))\n  }\n\n  // start self-balancing block\n  block(body?: Block, nodeCount?: number): CodeGen {\n    this._blockStarts.push(this._nodes.length)\n    if (body) this.code(body).endBlock(nodeCount)\n    return this\n  }\n\n  // end the current self-balancing block\n  endBlock(nodeCount?: number): CodeGen {\n    const len = this._blockStarts.pop()\n    if (len === undefined) throw new Error(\"CodeGen: not in self-balancing block\")\n    const toClose = this._nodes.length - len\n    if (toClose < 0 || (nodeCount !== undefined && toClose !== nodeCount)) {\n      throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`)\n    }\n    this._nodes.length = len\n    return this\n  }\n\n  // `function` heading (or definition if funcBody is passed)\n  func(name: Name, args: Code = nil, async?: boolean, funcBody?: Block): CodeGen {\n    this._blockNode(new Func(name, args, async))\n    if (funcBody) this.code(funcBody).endFunc()\n    return this\n  }\n\n  // end function definition\n  endFunc(): CodeGen {\n    return this._endBlockNode(Func)\n  }\n\n  optimize(n = 1): void {\n    while (n-- > 0) {\n      this._root.optimizeNodes()\n      this._root.optimizeNames(this._root.names, this._constants)\n    }\n  }\n\n  private _leafNode(node: LeafNode): CodeGen {\n    this._currNode.nodes.push(node)\n    return this\n  }\n\n  private _blockNode(node: StartBlockNode): void {\n    this._currNode.nodes.push(node)\n    this._nodes.push(node)\n  }\n\n  private _endBlockNode(N1: EndBlockNodeType, N2?: EndBlockNodeType): CodeGen {\n    const n = this._currNode\n    if (n instanceof N1 || (N2 && n instanceof N2)) {\n      this._nodes.pop()\n      return this\n    }\n    throw new Error(`CodeGen: not in block \"${N2 ? `${N1.kind}/${N2.kind}` : N1.kind}\"`)\n  }\n\n  private _elseNode(node: If | Else): CodeGen {\n    const n = this._currNode\n    if (!(n instanceof If)) {\n      throw new Error('CodeGen: \"else\" without \"if\"')\n    }\n    this._currNode = n.else = node\n    return this\n  }\n\n  private get _root(): Root {\n    return this._nodes[0] as Root\n  }\n\n  private get _currNode(): ParentNode {\n    const ns = this._nodes\n    return ns[ns.length - 1]\n  }\n\n  private set _currNode(node: ParentNode) {\n    const ns = this._nodes\n    ns[ns.length - 1] = node\n  }\n\n  // get nodeCount(): number {\n  //   return this._root.count\n  // }\n}\n\nfunction addNames(names: UsedNames, from: UsedNames): UsedNames {\n  for (const n in from) names[n] = (names[n] || 0) + (from[n] || 0)\n  return names\n}\n\nfunction addExprNames(names: UsedNames, from: SafeExpr): UsedNames {\n  return from instanceof _CodeOrName ? addNames(names, from.names) : names\n}\n\nfunction optimizeExpr<T extends SafeExpr | Code>(expr: T, names: UsedNames, constants: Constants): T\nfunction optimizeExpr(expr: SafeExpr, names: UsedNames, constants: Constants): SafeExpr {\n  if (expr instanceof Name) return replaceName(expr)\n  if (!canOptimize(expr)) return expr\n  return new _Code(\n    expr._items.reduce((items: CodeItem[], c: SafeExpr | string) => {\n      if (c instanceof Name) c = replaceName(c)\n      if (c instanceof _Code) items.push(...c._items)\n      else items.push(c)\n      return items\n    }, [])\n  )\n\n  function replaceName(n: Name): SafeExpr {\n    const c = constants[n.str]\n    if (c === undefined || names[n.str] !== 1) return n\n    delete names[n.str]\n    return c\n  }\n\n  function canOptimize(e: SafeExpr): e is _Code {\n    return (\n      e instanceof _Code &&\n      e._items.some(\n        (c) => c instanceof Name && names[c.str] === 1 && constants[c.str] !== undefined\n      )\n    )\n  }\n}\n\nfunction subtractNames(names: UsedNames, from: UsedNames): void {\n  for (const n in from) names[n] = (names[n] || 0) - (from[n] || 0)\n}\n\nexport function not<T extends Code | SafeExpr>(x: T): T\nexport function not(x: Code | SafeExpr): Code | SafeExpr {\n  return typeof x == \"boolean\" || typeof x == \"number\" || x === null ? !x : _`!${par(x)}`\n}\n\nconst andCode = mappend(operators.AND)\n\n// boolean AND (&&) expression with the passed arguments\nexport function and(...args: Code[]): Code {\n  return args.reduce(andCode)\n}\n\nconst orCode = mappend(operators.OR)\n\n// boolean OR (||) expression with the passed arguments\nexport function or(...args: Code[]): Code {\n  return args.reduce(orCode)\n}\n\ntype MAppend = (x: Code, y: Code) => Code\n\nfunction mappend(op: Code): MAppend {\n  return (x, y) => (x === nil ? y : y === nil ? x : _`${par(x)} ${op} ${par(y)}`)\n}\n\nfunction par(x: Code): Code {\n  return x instanceof Name ? x : _`(${x})`\n}\n","import {_, nil, Code, Name} from \"./code\"\n\ninterface NameGroup {\n  prefix: string\n  index: number\n}\n\nexport interface NameValue {\n  ref: ValueReference // this is the reference to any value that can be referred to from generated code via `globals` var in the closure\n  key?: unknown // any key to identify a global to avoid duplicates, if not passed ref is used\n  code?: Code // this is the code creating the value needed for standalone code wit_out closure - can be a primitive value, function or import (`require`)\n}\n\nexport type ValueReference = unknown // possibly make CodeGen parameterized type on this type\n\nclass ValueError extends Error {\n  readonly value?: NameValue\n  constructor(name: ValueScopeName) {\n    super(`CodeGen: \"code\" for ${name} not defined`)\n    this.value = name.value\n  }\n}\n\ninterface ScopeOptions {\n  prefixes?: Set<string>\n  parent?: Scope\n}\n\ninterface ValueScopeOptions extends ScopeOptions {\n  scope: ScopeStore\n  es5?: boolean\n  lines?: boolean\n}\n\nexport type ScopeStore = Record<string, ValueReference[] | undefined>\n\ntype ScopeValues = {\n  [Prefix in string]?: Map<unknown, ValueScopeName>\n}\n\nexport type ScopeValueSets = {\n  [Prefix in string]?: Set<ValueScopeName>\n}\n\nexport enum UsedValueState {\n  Started,\n  Completed,\n}\n\nexport type UsedScopeValues = {\n  [Prefix in string]?: Map<ValueScopeName, UsedValueState | undefined>\n}\n\nexport const varKinds = {\n  const: new Name(\"const\"),\n  let: new Name(\"let\"),\n  var: new Name(\"var\"),\n}\n\nexport class Scope {\n  protected readonly _names: {[Prefix in string]?: NameGroup} = {}\n  protected readonly _prefixes?: Set<string>\n  protected readonly _parent?: Scope\n\n  constructor({prefixes, parent}: ScopeOptions = {}) {\n    this._prefixes = prefixes\n    this._parent = parent\n  }\n\n  toName(nameOrPrefix: Name | string): Name {\n    return nameOrPrefix instanceof Name ? nameOrPrefix : this.name(nameOrPrefix)\n  }\n\n  name(prefix: string): Name {\n    return new Name(this._newName(prefix))\n  }\n\n  protected _newName(prefix: string): string {\n    const ng = this._names[prefix] || this._nameGroup(prefix)\n    return `${prefix}${ng.index++}`\n  }\n\n  private _nameGroup(prefix: string): NameGroup {\n    if (this._parent?._prefixes?.has(prefix) || (this._prefixes && !this._prefixes.has(prefix))) {\n      throw new Error(`CodeGen: prefix \"${prefix}\" is not allowed in this scope`)\n    }\n    return (this._names[prefix] = {prefix, index: 0})\n  }\n}\n\ninterface ScopePath {\n  property: string\n  itemIndex: number\n}\n\nexport class ValueScopeName extends Name {\n  readonly prefix: string\n  value?: NameValue\n  scopePath?: Code\n\n  constructor(prefix: string, nameStr: string) {\n    super(nameStr)\n    this.prefix = prefix\n  }\n\n  setValue(value: NameValue, {property, itemIndex}: ScopePath): void {\n    this.value = value\n    this.scopePath = _`.${new Name(property)}[${itemIndex}]`\n  }\n}\n\ninterface VSOptions extends ValueScopeOptions {\n  _n: Code\n}\n\nconst line = _`\\n`\n\nexport class ValueScope extends Scope {\n  protected readonly _values: ScopeValues = {}\n  protected readonly _scope: ScopeStore\n  readonly opts: VSOptions\n\n  constructor(opts: ValueScopeOptions) {\n    super(opts)\n    this._scope = opts.scope\n    this.opts = {...opts, _n: opts.lines ? line : nil}\n  }\n\n  get(): ScopeStore {\n    return this._scope\n  }\n\n  name(prefix: string): ValueScopeName {\n    return new ValueScopeName(prefix, this._newName(prefix))\n  }\n\n  value(nameOrPrefix: ValueScopeName | string, value: NameValue): ValueScopeName {\n    if (value.ref === undefined) throw new Error(\"CodeGen: ref must be passed in value\")\n    const name = this.toName(nameOrPrefix) as ValueScopeName\n    const {prefix} = name\n    const valueKey = value.key ?? value.ref\n    let vs = this._values[prefix]\n    if (vs) {\n      const _name = vs.get(valueKey)\n      if (_name) return _name\n    } else {\n      vs = this._values[prefix] = new Map()\n    }\n    vs.set(valueKey, name)\n\n    const s = this._scope[prefix] || (this._scope[prefix] = [])\n    const itemIndex = s.length\n    s[itemIndex] = value.ref\n    name.setValue(value, {property: prefix, itemIndex})\n    return name\n  }\n\n  getValue(prefix: string, keyOrRef: unknown): ValueScopeName | undefined {\n    const vs = this._values[prefix]\n    if (!vs) return\n    return vs.get(keyOrRef)\n  }\n\n  scopeRefs(scopeName: Name, values: ScopeValues | ScopeValueSets = this._values): Code {\n    return this._reduceValues(values, (name: ValueScopeName) => {\n      if (name.scopePath === undefined) throw new Error(`CodeGen: name \"${name}\" has no value`)\n      return _`${scopeName}${name.scopePath}`\n    })\n  }\n\n  scopeCode(\n    values: ScopeValues | ScopeValueSets = this._values,\n    usedValues?: UsedScopeValues,\n    getCode?: (n: ValueScopeName) => Code | undefined\n  ): Code {\n    return this._reduceValues(\n      values,\n      (name: ValueScopeName) => {\n        if (name.value === undefined) throw new Error(`CodeGen: name \"${name}\" has no value`)\n        return name.value.code\n      },\n      usedValues,\n      getCode\n    )\n  }\n\n  private _reduceValues(\n    values: ScopeValues | ScopeValueSets,\n    valueCode: (n: ValueScopeName) => Code | undefined,\n    usedValues: UsedScopeValues = {},\n    getCode?: (n: ValueScopeName) => Code | undefined\n  ): Code {\n    let code: Code = nil\n    for (const prefix in values) {\n      const vs = values[prefix]\n      if (!vs) continue\n      const nameSet = (usedValues[prefix] = usedValues[prefix] || new Map())\n      vs.forEach((name: ValueScopeName) => {\n        if (nameSet.has(name)) return\n        nameSet.set(name, UsedValueState.Started)\n        let c = valueCode(name)\n        if (c) {\n          const def = this.opts.es5 ? varKinds.var : varKinds.const\n          code = _`${code}${def} ${name} = ${c};${this.opts._n}`\n        } else if ((c = getCode?.(name))) {\n          code = _`${code}${c}${this.opts._n}`\n        } else {\n          throw new ValueError(name)\n        }\n        nameSet.set(name, UsedValueState.Completed)\n      })\n    }\n    return code\n  }\n}\n","import type {KeywordErrorCxt, KeywordErrorDefinition} from \"../types\"\nimport type {SchemaCxt} from \"./index\"\nimport {CodeGen, _, str, strConcat, Code, Name} from \"./codegen\"\nimport {SafeExpr} from \"./codegen/code\"\nimport {getErrorPath, Type} from \"./util\"\nimport N from \"./names\"\n\nexport const keywordError: KeywordErrorDefinition = {\n  message: ({keyword}) => str`must pass \"${keyword}\" keyword validation`,\n}\n\nexport const keyword$DataError: KeywordErrorDefinition = {\n  message: ({keyword, schemaType}) =>\n    schemaType\n      ? str`\"${keyword}\" keyword must be ${schemaType} ($data)`\n      : str`\"${keyword}\" keyword is invalid ($data)`,\n}\n\nexport interface ErrorPaths {\n  instancePath?: Code\n  schemaPath?: string\n  parentSchema?: boolean\n}\n\nexport function reportError(\n  cxt: KeywordErrorCxt,\n  error: KeywordErrorDefinition = keywordError,\n  errorPaths?: ErrorPaths,\n  overrideAllErrors?: boolean\n): void {\n  const {it} = cxt\n  const {gen, compositeRule, allErrors} = it\n  const errObj = errorObjectCode(cxt, error, errorPaths)\n  if (overrideAllErrors ?? (compositeRule || allErrors)) {\n    addError(gen, errObj)\n  } else {\n    returnErrors(it, _`[${errObj}]`)\n  }\n}\n\nexport function reportExtraError(\n  cxt: KeywordErrorCxt,\n  error: KeywordErrorDefinition = keywordError,\n  errorPaths?: ErrorPaths\n): void {\n  const {it} = cxt\n  const {gen, compositeRule, allErrors} = it\n  const errObj = errorObjectCode(cxt, error, errorPaths)\n  addError(gen, errObj)\n  if (!(compositeRule || allErrors)) {\n    returnErrors(it, N.vErrors)\n  }\n}\n\nexport function resetErrorsCount(gen: CodeGen, errsCount: Name): void {\n  gen.assign(N.errors, errsCount)\n  gen.if(_`${N.vErrors} !== null`, () =>\n    gen.if(\n      errsCount,\n      () => gen.assign(_`${N.vErrors}.length`, errsCount),\n      () => gen.assign(N.vErrors, null)\n    )\n  )\n}\n\nexport function extendErrors({\n  gen,\n  keyword,\n  schemaValue,\n  data,\n  errsCount,\n  it,\n}: KeywordErrorCxt): void {\n  /* istanbul ignore if */\n  if (errsCount === undefined) throw new Error(\"ajv implementation error\")\n  const err = gen.name(\"err\")\n  gen.forRange(\"i\", errsCount, N.errors, (i) => {\n    gen.const(err, _`${N.vErrors}[${i}]`)\n    gen.if(_`${err}.instancePath === undefined`, () =>\n      gen.assign(_`${err}.instancePath`, strConcat(N.instancePath, it.errorPath))\n    )\n    gen.assign(_`${err}.schemaPath`, str`${it.errSchemaPath}/${keyword}`)\n    if (it.opts.verbose) {\n      gen.assign(_`${err}.schema`, schemaValue)\n      gen.assign(_`${err}.data`, data)\n    }\n  })\n}\n\nfunction addError(gen: CodeGen, errObj: Code): void {\n  const err = gen.const(\"err\", errObj)\n  gen.if(\n    _`${N.vErrors} === null`,\n    () => gen.assign(N.vErrors, _`[${err}]`),\n    _`${N.vErrors}.push(${err})`\n  )\n  gen.code(_`${N.errors}++`)\n}\n\nfunction returnErrors(it: SchemaCxt, errs: Code): void {\n  const {gen, validateName, schemaEnv} = it\n  if (schemaEnv.$async) {\n    gen.throw(_`new ${it.ValidationError as Name}(${errs})`)\n  } else {\n    gen.assign(_`${validateName}.errors`, errs)\n    gen.return(false)\n  }\n}\n\nconst E = {\n  keyword: new Name(\"keyword\"),\n  schemaPath: new Name(\"schemaPath\"), // also used in JTD errors\n  params: new Name(\"params\"),\n  propertyName: new Name(\"propertyName\"),\n  message: new Name(\"message\"),\n  schema: new Name(\"schema\"),\n  parentSchema: new Name(\"parentSchema\"),\n}\n\nfunction errorObjectCode(\n  cxt: KeywordErrorCxt,\n  error: KeywordErrorDefinition,\n  errorPaths?: ErrorPaths\n): Code {\n  const {createErrors} = cxt.it\n  if (createErrors === false) return _`{}`\n  return errorObject(cxt, error, errorPaths)\n}\n\nfunction errorObject(\n  cxt: KeywordErrorCxt,\n  error: KeywordErrorDefinition,\n  errorPaths: ErrorPaths = {}\n): Code {\n  const {gen, it} = cxt\n  const keyValues: [Name, SafeExpr | string][] = [\n    errorInstancePath(it, errorPaths),\n    errorSchemaPath(cxt, errorPaths),\n  ]\n  extraErrorProps(cxt, error, keyValues)\n  return gen.object(...keyValues)\n}\n\nfunction errorInstancePath({errorPath}: SchemaCxt, {instancePath}: ErrorPaths): [Name, Code] {\n  const instPath = instancePath\n    ? str`${errorPath}${getErrorPath(instancePath, Type.Str)}`\n    : errorPath\n  return [N.instancePath, strConcat(N.instancePath, instPath)]\n}\n\nfunction errorSchemaPath(\n  {keyword, it: {errSchemaPath}}: KeywordErrorCxt,\n  {schemaPath, parentSchema}: ErrorPaths\n): [Name, string | Code] {\n  let schPath = parentSchema ? errSchemaPath : str`${errSchemaPath}/${keyword}`\n  if (schemaPath) {\n    schPath = str`${schPath}${getErrorPath(schemaPath, Type.Str)}`\n  }\n  return [E.schemaPath, schPath]\n}\n\nfunction extraErrorProps(\n  cxt: KeywordErrorCxt,\n  {params, message}: KeywordErrorDefinition,\n  keyValues: [Name, SafeExpr | string][]\n): void {\n  const {keyword, data, schemaValue, it} = cxt\n  const {opts, propertyName, topSchemaRef, schemaPath} = it\n  keyValues.push(\n    [E.keyword, keyword],\n    [E.params, typeof params == \"function\" ? params(cxt) : params || _`{}`]\n  )\n  if (opts.messages) {\n    keyValues.push([E.message, typeof message == \"function\" ? message(cxt) : message])\n  }\n  if (opts.verbose) {\n    keyValues.push(\n      [E.schema, schemaValue],\n      [E.parentSchema, _`${topSchemaRef}${schemaPath}`],\n      [N.data, data]\n    )\n  }\n  if (propertyName) keyValues.push([E.propertyName, propertyName])\n}\n","import type {\n  AnySchema,\n  AnySchemaObject,\n  AnyValidateFunction,\n  AsyncValidateFunction,\n  EvaluatedProperties,\n  EvaluatedItems,\n} from \"../types\"\nimport type Ajv from \"../core\"\nimport type {InstanceOptions} from \"../core\"\nimport {CodeGen, _, nil, stringify, Name, Code, ValueScopeName} from \"./codegen\"\nimport ValidationError from \"../runtime/validation_error\"\nimport N from \"./names\"\nimport {LocalRefs, getFullPath, _getFullPath, inlineRef, normalizeId, resolveUrl} from \"./resolve\"\nimport {schemaHasRulesButRef, unescapeFragment} from \"./util\"\nimport {validateFunctionCode} from \"./validate\"\nimport * as URI from \"uri-js\"\nimport {JSONType} from \"./rules\"\n\nexport type SchemaRefs = {\n  [Ref in string]?: SchemaEnv | AnySchema\n}\n\nexport interface SchemaCxt {\n  readonly gen: CodeGen\n  readonly allErrors?: boolean // validation mode - whether to collect all errors or break on error\n  readonly data: Name // Name with reference to the current part of data instance\n  readonly parentData: Name // should be used in keywords modifying data\n  readonly parentDataProperty: Code | number // should be used in keywords modifying data\n  readonly dataNames: Name[]\n  readonly dataPathArr: (Code | number)[]\n  readonly dataLevel: number // the level of the currently validated data,\n  // it can be used to access both the property names and the data on all levels from the top.\n  dataTypes: JSONType[] // data types applied to the current part of data instance\n  definedProperties: Set<string> // set of properties to keep track of for required checks\n  readonly topSchemaRef: Code\n  readonly validateName: Name\n  evaluated?: Name\n  readonly ValidationError?: Name\n  readonly schema: AnySchema // current schema object - equal to parentSchema passed via KeywordCxt\n  readonly schemaEnv: SchemaEnv\n  readonly rootId: string\n  baseId: string // the current schema base URI that should be used as the base for resolving URIs in references (\\$ref)\n  readonly schemaPath: Code // the run-time expression that evaluates to the property name of the current schema\n  readonly errSchemaPath: string // this is actual string, should not be changed to Code\n  readonly errorPath: Code\n  readonly propertyName?: Name\n  readonly compositeRule?: boolean // true indicates that the current schema is inside the compound keyword,\n  // where failing some rule doesn't mean validation failure (`anyOf`, `oneOf`, `not`, `if`).\n  // This flag is used to determine whether you can return validation result immediately after any error in case the option `allErrors` is not `true.\n  // You only need to use it if you have many steps in your keywords and potentially can define multiple errors.\n  props?: EvaluatedProperties | Name // properties evaluated by this schema - used by parent schema or assigned to validation function\n  items?: EvaluatedItems | Name // last item evaluated by this schema - used by parent schema or assigned to validation function\n  jtdDiscriminator?: string\n  jtdMetadata?: boolean\n  readonly createErrors?: boolean\n  readonly opts: InstanceOptions // Ajv instance option.\n  readonly self: Ajv // current Ajv instance\n}\n\nexport interface SchemaObjCxt extends SchemaCxt {\n  readonly schema: AnySchemaObject\n}\ninterface SchemaEnvArgs {\n  readonly schema: AnySchema\n  readonly schemaId?: \"$id\" | \"id\"\n  readonly root?: SchemaEnv\n  readonly baseId?: string\n  readonly schemaPath?: string\n  readonly localRefs?: LocalRefs\n  readonly meta?: boolean\n}\n\nexport class SchemaEnv implements SchemaEnvArgs {\n  readonly schema: AnySchema\n  readonly schemaId?: \"$id\" | \"id\"\n  readonly root: SchemaEnv\n  baseId: string // TODO possibly, it should be readonly\n  schemaPath?: string\n  localRefs?: LocalRefs\n  readonly meta?: boolean\n  readonly $async?: boolean // true if the current schema is asynchronous.\n  readonly refs: SchemaRefs = {}\n  readonly dynamicAnchors: {[Ref in string]?: true} = {}\n  validate?: AnyValidateFunction\n  validateName?: ValueScopeName\n  serialize?: (data: unknown) => string\n  serializeName?: ValueScopeName\n  parse?: (data: string) => unknown\n  parseName?: ValueScopeName\n\n  constructor(env: SchemaEnvArgs) {\n    let schema: AnySchemaObject | undefined\n    if (typeof env.schema == \"object\") schema = env.schema\n    this.schema = env.schema\n    this.schemaId = env.schemaId\n    this.root = env.root || this\n    this.baseId = env.baseId ?? normalizeId(schema?.[env.schemaId || \"$id\"])\n    this.schemaPath = env.schemaPath\n    this.localRefs = env.localRefs\n    this.meta = env.meta\n    this.$async = schema?.$async\n    this.refs = {}\n  }\n}\n\n// let codeSize = 0\n// let nodeCount = 0\n\n// Compiles schema in SchemaEnv\nexport function compileSchema(this: Ajv, sch: SchemaEnv): SchemaEnv {\n  // TODO refactor - remove compilations\n  const _sch = getCompilingSchema.call(this, sch)\n  if (_sch) return _sch\n  const rootId = getFullPath(this.opts.uriResolver, sch.root.baseId) // TODO if getFullPath removed 1 tests fails\n  const {es5, lines} = this.opts.code\n  const {ownProperties} = this.opts\n  const gen = new CodeGen(this.scope, {es5, lines, ownProperties})\n  let _ValidationError\n  if (sch.$async) {\n    _ValidationError = gen.scopeValue(\"Error\", {\n      ref: ValidationError,\n      code: _`require(\"ajv/dist/runtime/validation_error\").default`,\n    })\n  }\n\n  const validateName = gen.scopeName(\"validate\")\n  sch.validateName = validateName\n\n  const schemaCxt: SchemaCxt = {\n    gen,\n    allErrors: this.opts.allErrors,\n    data: N.data,\n    parentData: N.parentData,\n    parentDataProperty: N.parentDataProperty,\n    dataNames: [N.data],\n    dataPathArr: [nil], // TODO can its length be used as dataLevel if nil is removed?\n    dataLevel: 0,\n    dataTypes: [],\n    definedProperties: new Set<string>(),\n    topSchemaRef: gen.scopeValue(\n      \"schema\",\n      this.opts.code.source === true\n        ? {ref: sch.schema, code: stringify(sch.schema)}\n        : {ref: sch.schema}\n    ),\n    validateName,\n    ValidationError: _ValidationError,\n    schema: sch.schema,\n    schemaEnv: sch,\n    rootId,\n    baseId: sch.baseId || rootId,\n    schemaPath: nil,\n    errSchemaPath: sch.schemaPath || (this.opts.jtd ? \"\" : \"#\"),\n    errorPath: _`\"\"`,\n    opts: this.opts,\n    self: this,\n  }\n\n  let sourceCode: string | undefined\n  try {\n    this._compilations.add(sch)\n    validateFunctionCode(schemaCxt)\n    gen.optimize(this.opts.code.optimize)\n    // gen.optimize(1)\n    const validateCode = gen.toString()\n    sourceCode = `${gen.scopeRefs(N.scope)}return ${validateCode}`\n    // console.log((codeSize += sourceCode.length), (nodeCount += gen.nodeCount))\n    if (this.opts.code.process) sourceCode = this.opts.code.process(sourceCode, sch)\n    // console.log(\"\\n\\n\\n *** \\n\", sourceCode)\n    const makeValidate = new Function(`${N.self}`, `${N.scope}`, sourceCode)\n    const validate: AnyValidateFunction = makeValidate(this, this.scope.get())\n    this.scope.value(validateName, {ref: validate})\n\n    validate.errors = null\n    validate.schema = sch.schema\n    validate.schemaEnv = sch\n    if (sch.$async) (validate as AsyncValidateFunction).$async = true\n    if (this.opts.code.source === true) {\n      validate.source = {validateName, validateCode, scopeValues: gen._values}\n    }\n    if (this.opts.unevaluated) {\n      const {props, items} = schemaCxt\n      validate.evaluated = {\n        props: props instanceof Name ? undefined : props,\n        items: items instanceof Name ? undefined : items,\n        dynamicProps: props instanceof Name,\n        dynamicItems: items instanceof Name,\n      }\n      if (validate.source) validate.source.evaluated = stringify(validate.evaluated)\n    }\n    sch.validate = validate\n    return sch\n  } catch (e) {\n    delete sch.validate\n    delete sch.validateName\n    if (sourceCode) this.logger.error(\"Error compiling schema, function code:\", sourceCode)\n    // console.log(\"\\n\\n\\n *** \\n\", sourceCode, this.opts)\n    throw e\n  } finally {\n    this._compilations.delete(sch)\n  }\n}\n\nexport function resolveRef(\n  this: Ajv,\n  root: SchemaEnv,\n  baseId: string,\n  ref: string\n): AnySchema | SchemaEnv | undefined {\n  ref = resolveUrl(this.opts.uriResolver, baseId, ref)\n  const schOrFunc = root.refs[ref]\n  if (schOrFunc) return schOrFunc\n\n  let _sch = resolve.call(this, root, ref)\n  if (_sch === undefined) {\n    const schema = root.localRefs?.[ref] // TODO maybe localRefs should hold SchemaEnv\n    const {schemaId} = this.opts\n    if (schema) _sch = new SchemaEnv({schema, schemaId, root, baseId})\n  }\n\n  if (_sch === undefined) return\n  return (root.refs[ref] = inlineOrCompile.call(this, _sch))\n}\n\nfunction inlineOrCompile(this: Ajv, sch: SchemaEnv): AnySchema | SchemaEnv {\n  if (inlineRef(sch.schema, this.opts.inlineRefs)) return sch.schema\n  return sch.validate ? sch : compileSchema.call(this, sch)\n}\n\n// Index of schema compilation in the currently compiled list\nexport function getCompilingSchema(this: Ajv, schEnv: SchemaEnv): SchemaEnv | void {\n  for (const sch of this._compilations) {\n    if (sameSchemaEnv(sch, schEnv)) return sch\n  }\n}\n\nfunction sameSchemaEnv(s1: SchemaEnv, s2: SchemaEnv): boolean {\n  return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId\n}\n\n// resolve and compile the references ($ref)\n// TODO returns AnySchemaObject (if the schema can be inlined) or validation function\nfunction resolve(\n  this: Ajv,\n  root: SchemaEnv, // information about the root schema for the current schema\n  ref: string // reference to resolve\n): SchemaEnv | undefined {\n  let sch\n  while (typeof (sch = this.refs[ref]) == \"string\") ref = sch\n  return sch || this.schemas[ref] || resolveSchema.call(this, root, ref)\n}\n\n// Resolve schema, its root and baseId\nexport function resolveSchema(\n  this: Ajv,\n  root: SchemaEnv, // root object with properties schema, refs TODO below SchemaEnv is assigned to it\n  ref: string // reference to resolve\n): SchemaEnv | undefined {\n  const p = this.opts.uriResolver.parse(ref)\n  const refPath = _getFullPath(this.opts.uriResolver, p)\n  let baseId = getFullPath(this.opts.uriResolver, root.baseId, undefined)\n  // TODO `Object.keys(root.schema).length > 0` should not be needed - but removing breaks 2 tests\n  if (Object.keys(root.schema).length > 0 && refPath === baseId) {\n    return getJsonPointer.call(this, p, root)\n  }\n\n  const id = normalizeId(refPath)\n  const schOrRef = this.refs[id] || this.schemas[id]\n  if (typeof schOrRef == \"string\") {\n    const sch = resolveSchema.call(this, root, schOrRef)\n    if (typeof sch?.schema !== \"object\") return\n    return getJsonPointer.call(this, p, sch)\n  }\n\n  if (typeof schOrRef?.schema !== \"object\") return\n  if (!schOrRef.validate) compileSchema.call(this, schOrRef)\n  if (id === normalizeId(ref)) {\n    const {schema} = schOrRef\n    const {schemaId} = this.opts\n    const schId = schema[schemaId]\n    if (schId) baseId = resolveUrl(this.opts.uriResolver, baseId, schId)\n    return new SchemaEnv({schema, schemaId, root, baseId})\n  }\n  return getJsonPointer.call(this, p, schOrRef)\n}\n\nconst PREVENT_SCOPE_CHANGE = new Set([\n  \"properties\",\n  \"patternProperties\",\n  \"enum\",\n  \"dependencies\",\n  \"definitions\",\n])\n\nfunction getJsonPointer(\n  this: Ajv,\n  parsedRef: URI.URIComponents,\n  {baseId, schema, root}: SchemaEnv\n): SchemaEnv | undefined {\n  if (parsedRef.fragment?.[0] !== \"/\") return\n  for (const part of parsedRef.fragment.slice(1).split(\"/\")) {\n    if (typeof schema === \"boolean\") return\n    const partSchema = schema[unescapeFragment(part)]\n    if (partSchema === undefined) return\n    schema = partSchema\n    // TODO PREVENT_SCOPE_CHANGE could be defined in keyword def?\n    const schId = typeof schema === \"object\" && schema[this.opts.schemaId]\n    if (!PREVENT_SCOPE_CHANGE.has(part) && schId) {\n      baseId = resolveUrl(this.opts.uriResolver, baseId, schId)\n    }\n  }\n  let env: SchemaEnv | undefined\n  if (typeof schema != \"boolean\" && schema.$ref && !schemaHasRulesButRef(schema, this.RULES)) {\n    const $ref = resolveUrl(this.opts.uriResolver, baseId, schema.$ref)\n    env = resolveSchema.call(this, root, $ref)\n  }\n  // even though resolution failed we need to return SchemaEnv to throw exception\n  // so that compileAsync loads missing schema.\n  const {schemaId} = this.opts\n  env = env || new SchemaEnv({schema, schemaId, root, baseId})\n  if (env.schema !== env.root.schema) return env\n  return undefined\n}\n","import {Name} from \"./codegen\"\n\nconst names = {\n  // validation function arguments\n  data: new Name(\"data\"), // data passed to validation function\n  // args passed from referencing schema\n  valCxt: new Name(\"valCxt\"), // validation/data context - should not be used directly, it is destructured to the names below\n  instancePath: new Name(\"instancePath\"),\n  parentData: new Name(\"parentData\"),\n  parentDataProperty: new Name(\"parentDataProperty\"),\n  rootData: new Name(\"rootData\"), // root data - same as the data passed to the first/top validation function\n  dynamicAnchors: new Name(\"dynamicAnchors\"), // used to support recursiveRef and dynamicRef\n  // function scoped variables\n  vErrors: new Name(\"vErrors\"), // null or array of validation errors\n  errors: new Name(\"errors\"), // counter of validation errors\n  this: new Name(\"this\"),\n  // \"globals\"\n  self: new Name(\"self\"),\n  scope: new Name(\"scope\"),\n  // JTD serialize/parse name for JSON string and position\n  json: new Name(\"json\"),\n  jsonPos: new Name(\"jsonPos\"),\n  jsonLen: new Name(\"jsonLen\"),\n  jsonPart: new Name(\"jsonPart\"),\n}\n\nexport default names\n","import {resolveUrl, normalizeId, getFullPath} from \"./resolve\"\nimport type {UriResolver} from \"../types\"\n\nexport default class MissingRefError extends Error {\n  readonly missingRef: string\n  readonly missingSchema: string\n\n  constructor(resolver: UriResolver, baseId: string, ref: string, msg?: string) {\n    super(msg || `can't resolve reference ${ref} from id ${baseId}`)\n    this.missingRef = resolveUrl(resolver, baseId, ref)\n    this.missingSchema = normalizeId(getFullPath(resolver, this.missingRef))\n  }\n}\n","import type {AnySchema, AnySchemaObject, UriResolver} from \"../types\"\nimport type Ajv from \"../ajv\"\nimport type {URIComponents} from \"uri-js\"\nimport {eachItem} from \"./util\"\nimport * as equal from \"fast-deep-equal\"\nimport * as traverse from \"json-schema-traverse\"\n\n// the hash of local references inside the schema (created by getSchemaRefs), used for inline resolution\nexport type LocalRefs = {[Ref in string]?: AnySchemaObject}\n\n// TODO refactor to use keyword definitions\nconst SIMPLE_INLINED = new Set([\n  \"type\",\n  \"format\",\n  \"pattern\",\n  \"maxLength\",\n  \"minLength\",\n  \"maxProperties\",\n  \"minProperties\",\n  \"maxItems\",\n  \"minItems\",\n  \"maximum\",\n  \"minimum\",\n  \"uniqueItems\",\n  \"multipleOf\",\n  \"required\",\n  \"enum\",\n  \"const\",\n])\n\nexport function inlineRef(schema: AnySchema, limit: boolean | number = true): boolean {\n  if (typeof schema == \"boolean\") return true\n  if (limit === true) return !hasRef(schema)\n  if (!limit) return false\n  return countKeys(schema) <= limit\n}\n\nconst REF_KEYWORDS = new Set([\n  \"$ref\",\n  \"$recursiveRef\",\n  \"$recursiveAnchor\",\n  \"$dynamicRef\",\n  \"$dynamicAnchor\",\n])\n\nfunction hasRef(schema: AnySchemaObject): boolean {\n  for (const key in schema) {\n    if (REF_KEYWORDS.has(key)) return true\n    const sch = schema[key]\n    if (Array.isArray(sch) && sch.some(hasRef)) return true\n    if (typeof sch == \"object\" && hasRef(sch)) return true\n  }\n  return false\n}\n\nfunction countKeys(schema: AnySchemaObject): number {\n  let count = 0\n  for (const key in schema) {\n    if (key === \"$ref\") return Infinity\n    count++\n    if (SIMPLE_INLINED.has(key)) continue\n    if (typeof schema[key] == \"object\") {\n      eachItem(schema[key], (sch) => (count += countKeys(sch)))\n    }\n    if (count === Infinity) return Infinity\n  }\n  return count\n}\n\nexport function getFullPath(resolver: UriResolver, id = \"\", normalize?: boolean): string {\n  if (normalize !== false) id = normalizeId(id)\n  const p = resolver.parse(id)\n  return _getFullPath(resolver, p)\n}\n\nexport function _getFullPath(resolver: UriResolver, p: URIComponents): string {\n  const serialized = resolver.serialize(p)\n  return serialized.split(\"#\")[0] + \"#\"\n}\n\nconst TRAILING_SLASH_HASH = /#\\/?$/\nexport function normalizeId(id: string | undefined): string {\n  return id ? id.replace(TRAILING_SLASH_HASH, \"\") : \"\"\n}\n\nexport function resolveUrl(resolver: UriResolver, baseId: string, id: string): string {\n  id = normalizeId(id)\n  return resolver.resolve(baseId, id)\n}\n\nconst ANCHOR = /^[a-z_][-a-z0-9._]*$/i\n\nexport function getSchemaRefs(this: Ajv, schema: AnySchema, baseId: string): LocalRefs {\n  if (typeof schema == \"boolean\") return {}\n  const {schemaId, uriResolver} = this.opts\n  const schId = normalizeId(schema[schemaId] || baseId)\n  const baseIds: {[JsonPtr in string]?: string} = {\"\": schId}\n  const pathPrefix = getFullPath(uriResolver, schId, false)\n  const localRefs: LocalRefs = {}\n  const schemaRefs: Set<string> = new Set()\n\n  traverse(schema, {allKeys: true}, (sch, jsonPtr, _, parentJsonPtr) => {\n    if (parentJsonPtr === undefined) return\n    const fullPath = pathPrefix + jsonPtr\n    let baseId = baseIds[parentJsonPtr]\n    if (typeof sch[schemaId] == \"string\") baseId = addRef.call(this, sch[schemaId])\n    addAnchor.call(this, sch.$anchor)\n    addAnchor.call(this, sch.$dynamicAnchor)\n    baseIds[jsonPtr] = baseId\n\n    function addRef(this: Ajv, ref: string): string {\n      // eslint-disable-next-line @typescript-eslint/unbound-method\n      const _resolve = this.opts.uriResolver.resolve\n      ref = normalizeId(baseId ? _resolve(baseId, ref) : ref)\n      if (schemaRefs.has(ref)) throw ambiguos(ref)\n      schemaRefs.add(ref)\n      let schOrRef = this.refs[ref]\n      if (typeof schOrRef == \"string\") schOrRef = this.refs[schOrRef]\n      if (typeof schOrRef == \"object\") {\n        checkAmbiguosRef(sch, schOrRef.schema, ref)\n      } else if (ref !== normalizeId(fullPath)) {\n        if (ref[0] === \"#\") {\n          checkAmbiguosRef(sch, localRefs[ref], ref)\n          localRefs[ref] = sch\n        } else {\n          this.refs[ref] = fullPath\n        }\n      }\n      return ref\n    }\n\n    function addAnchor(this: Ajv, anchor: unknown): void {\n      if (typeof anchor == \"string\") {\n        if (!ANCHOR.test(anchor)) throw new Error(`invalid anchor \"${anchor}\"`)\n        addRef.call(this, `#${anchor}`)\n      }\n    }\n  })\n\n  return localRefs\n\n  function checkAmbiguosRef(sch1: AnySchema, sch2: AnySchema | undefined, ref: string): void {\n    if (sch2 !== undefined && !equal(sch1, sch2)) throw ambiguos(ref)\n  }\n\n  function ambiguos(ref: string): Error {\n    return new Error(`reference \"${ref}\" resolves to more than one schema`)\n  }\n}\n","import type {AddedKeywordDefinition} from \"../types\"\n\nconst _jsonTypes = [\"string\", \"number\", \"integer\", \"boolean\", \"null\", \"object\", \"array\"] as const\n\nexport type JSONType = typeof _jsonTypes[number]\n\nconst jsonTypes: Set<string> = new Set(_jsonTypes)\n\nexport function isJSONType(x: unknown): x is JSONType {\n  return typeof x == \"string\" && jsonTypes.has(x)\n}\n\ntype ValidationTypes = {\n  [K in JSONType]: boolean | RuleGroup | undefined\n}\n\nexport interface ValidationRules {\n  rules: RuleGroup[]\n  post: RuleGroup\n  all: {[Key in string]?: boolean | Rule} // rules that have to be validated\n  keywords: {[Key in string]?: boolean} // all known keywords (superset of \"all\")\n  types: ValidationTypes\n}\n\nexport interface RuleGroup {\n  type?: JSONType\n  rules: Rule[]\n}\n\n// This interface wraps KeywordDefinition because definition can have multiple keywords\nexport interface Rule {\n  keyword: string\n  definition: AddedKeywordDefinition\n}\n\nexport function getRules(): ValidationRules {\n  const groups: Record<\"number\" | \"string\" | \"array\" | \"object\", RuleGroup> = {\n    number: {type: \"number\", rules: []},\n    string: {type: \"string\", rules: []},\n    array: {type: \"array\", rules: []},\n    object: {type: \"object\", rules: []},\n  }\n  return {\n    types: {...groups, integer: true, boolean: true, null: true},\n    rules: [{rules: []}, groups.number, groups.string, groups.array, groups.object],\n    post: {rules: []},\n    all: {},\n    keywords: {},\n  }\n}\n","import type {AnySchema, EvaluatedProperties, EvaluatedItems} from \"../types\"\nimport type {SchemaCxt, SchemaObjCxt} from \".\"\nimport {_, getProperty, Code, Name, CodeGen} from \"./codegen\"\nimport {_Code} from \"./codegen/code\"\nimport type {Rule, ValidationRules} from \"./rules\"\n\n// TODO refactor to use Set\nexport function toHash<T extends string = string>(arr: T[]): {[K in T]?: true} {\n  const hash: {[K in T]?: true} = {}\n  for (const item of arr) hash[item] = true\n  return hash\n}\n\nexport function alwaysValidSchema(it: SchemaCxt, schema: AnySchema): boolean | void {\n  if (typeof schema == \"boolean\") return schema\n  if (Object.keys(schema).length === 0) return true\n  checkUnknownRules(it, schema)\n  return !schemaHasRules(schema, it.self.RULES.all)\n}\n\nexport function checkUnknownRules(it: SchemaCxt, schema: AnySchema = it.schema): void {\n  const {opts, self} = it\n  if (!opts.strictSchema) return\n  if (typeof schema === \"boolean\") return\n  const rules = self.RULES.keywords\n  for (const key in schema) {\n    if (!rules[key]) checkStrictMode(it, `unknown keyword: \"${key}\"`)\n  }\n}\n\nexport function schemaHasRules(\n  schema: AnySchema,\n  rules: {[Key in string]?: boolean | Rule}\n): boolean {\n  if (typeof schema == \"boolean\") return !schema\n  for (const key in schema) if (rules[key]) return true\n  return false\n}\n\nexport function schemaHasRulesButRef(schema: AnySchema, RULES: ValidationRules): boolean {\n  if (typeof schema == \"boolean\") return !schema\n  for (const key in schema) if (key !== \"$ref\" && RULES.all[key]) return true\n  return false\n}\n\nexport function schemaRefOrVal(\n  {topSchemaRef, schemaPath}: SchemaObjCxt,\n  schema: unknown,\n  keyword: string,\n  $data?: string | false\n): Code | number | boolean {\n  if (!$data) {\n    if (typeof schema == \"number\" || typeof schema == \"boolean\") return schema\n    if (typeof schema == \"string\") return _`${schema}`\n  }\n  return _`${topSchemaRef}${schemaPath}${getProperty(keyword)}`\n}\n\nexport function unescapeFragment(str: string): string {\n  return unescapeJsonPointer(decodeURIComponent(str))\n}\n\nexport function escapeFragment(str: string | number): string {\n  return encodeURIComponent(escapeJsonPointer(str))\n}\n\nexport function escapeJsonPointer(str: string | number): string {\n  if (typeof str == \"number\") return `${str}`\n  return str.replace(/~/g, \"~0\").replace(/\\//g, \"~1\")\n}\n\nexport function unescapeJsonPointer(str: string): string {\n  return str.replace(/~1/g, \"/\").replace(/~0/g, \"~\")\n}\n\nexport function eachItem<T>(xs: T | T[], f: (x: T) => void): void {\n  if (Array.isArray(xs)) {\n    for (const x of xs) f(x)\n  } else {\n    f(xs)\n  }\n}\n\ntype SomeEvaluated = EvaluatedProperties | EvaluatedItems\n\ntype MergeEvaluatedFunc<T extends SomeEvaluated> = (\n  gen: CodeGen,\n  from: Name | T,\n  to: Name | Exclude<T, true> | undefined,\n  toName?: typeof Name\n) => Name | T\n\ninterface MakeMergeFuncArgs<T extends SomeEvaluated> {\n  mergeNames: (gen: CodeGen, from: Name, to: Name) => void\n  mergeToName: (gen: CodeGen, from: T, to: Name) => void\n  mergeValues: (from: T, to: Exclude<T, true>) => T\n  resultToName: (gen: CodeGen, res?: T) => Name\n}\n\nfunction makeMergeEvaluated<T extends SomeEvaluated>({\n  mergeNames,\n  mergeToName,\n  mergeValues,\n  resultToName,\n}: MakeMergeFuncArgs<T>): MergeEvaluatedFunc<T> {\n  return (gen, from, to, toName) => {\n    const res =\n      to === undefined\n        ? from\n        : to instanceof Name\n        ? (from instanceof Name ? mergeNames(gen, from, to) : mergeToName(gen, from, to), to)\n        : from instanceof Name\n        ? (mergeToName(gen, to, from), from)\n        : mergeValues(from, to)\n    return toName === Name && !(res instanceof Name) ? resultToName(gen, res) : res\n  }\n}\n\ninterface MergeEvaluated {\n  props: MergeEvaluatedFunc<EvaluatedProperties>\n  items: MergeEvaluatedFunc<EvaluatedItems>\n}\n\nexport const mergeEvaluated: MergeEvaluated = {\n  props: makeMergeEvaluated({\n    mergeNames: (gen, from, to) =>\n      gen.if(_`${to} !== true && ${from} !== undefined`, () => {\n        gen.if(\n          _`${from} === true`,\n          () => gen.assign(to, true),\n          () => gen.assign(to, _`${to} || {}`).code(_`Object.assign(${to}, ${from})`)\n        )\n      }),\n    mergeToName: (gen, from, to) =>\n      gen.if(_`${to} !== true`, () => {\n        if (from === true) {\n          gen.assign(to, true)\n        } else {\n          gen.assign(to, _`${to} || {}`)\n          setEvaluated(gen, to, from)\n        }\n      }),\n    mergeValues: (from, to) => (from === true ? true : {...from, ...to}),\n    resultToName: evaluatedPropsToName,\n  }),\n  items: makeMergeEvaluated({\n    mergeNames: (gen, from, to) =>\n      gen.if(_`${to} !== true && ${from} !== undefined`, () =>\n        gen.assign(to, _`${from} === true ? true : ${to} > ${from} ? ${to} : ${from}`)\n      ),\n    mergeToName: (gen, from, to) =>\n      gen.if(_`${to} !== true`, () =>\n        gen.assign(to, from === true ? true : _`${to} > ${from} ? ${to} : ${from}`)\n      ),\n    mergeValues: (from, to) => (from === true ? true : Math.max(from, to)),\n    resultToName: (gen, items) => gen.var(\"items\", items),\n  }),\n}\n\nexport function evaluatedPropsToName(gen: CodeGen, ps?: EvaluatedProperties): Name {\n  if (ps === true) return gen.var(\"props\", true)\n  const props = gen.var(\"props\", _`{}`)\n  if (ps !== undefined) setEvaluated(gen, props, ps)\n  return props\n}\n\nexport function setEvaluated(gen: CodeGen, props: Name, ps: {[K in string]?: true}): void {\n  Object.keys(ps).forEach((p) => gen.assign(_`${props}${getProperty(p)}`, true))\n}\n\nconst snippets: {[S in string]?: _Code} = {}\n\nexport function useFunc(gen: CodeGen, f: {code: string}): Name {\n  return gen.scopeValue(\"func\", {\n    ref: f,\n    code: snippets[f.code] || (snippets[f.code] = new _Code(f.code)),\n  })\n}\n\nexport enum Type {\n  Num,\n  Str,\n}\n\nexport function getErrorPath(\n  dataProp: Name | string | number,\n  dataPropType?: Type,\n  jsPropertySyntax?: boolean\n): Code | string {\n  // let path\n  if (dataProp instanceof Name) {\n    const isNumber = dataPropType === Type.Num\n    return jsPropertySyntax\n      ? isNumber\n        ? _`\"[\" + ${dataProp} + \"]\"`\n        : _`\"['\" + ${dataProp} + \"']\"`\n      : isNumber\n      ? _`\"/\" + ${dataProp}`\n      : _`\"/\" + ${dataProp}.replace(/~/g, \"~0\").replace(/\\\\//g, \"~1\")` // TODO maybe use global escapePointer\n  }\n  return jsPropertySyntax ? getProperty(dataProp).toString() : \"/\" + escapeJsonPointer(dataProp)\n}\n\nexport function checkStrictMode(\n  it: SchemaCxt,\n  msg: string,\n  mode: boolean | \"log\" = it.opts.strictSchema\n): void {\n  if (!mode) return\n  msg = `strict mode: ${msg}`\n  if (mode === true) throw new Error(msg)\n  it.self.logger.warn(msg)\n}\n","import type {AnySchemaObject} from \"../../types\"\nimport type {SchemaObjCxt} from \"..\"\nimport type {JSONType, RuleGroup, Rule} from \"../rules\"\n\nexport function schemaHasRulesForType(\n  {schema, self}: SchemaObjCxt,\n  type: JSONType\n): boolean | undefined {\n  const group = self.RULES.types[type]\n  return group && group !== true && shouldUseGroup(schema, group)\n}\n\nexport function shouldUseGroup(schema: AnySchemaObject, group: RuleGroup): boolean {\n  return group.rules.some((rule) => shouldUseRule(schema, rule))\n}\n\nexport function shouldUseRule(schema: AnySchemaObject, rule: Rule): boolean | undefined {\n  return (\n    schema[rule.keyword] !== undefined ||\n    rule.definition.implements?.some((kwd) => schema[kwd] !== undefined)\n  )\n}\n","import type {KeywordErrorDefinition, KeywordErrorCxt} from \"../../types\"\nimport type {SchemaCxt} from \"..\"\nimport {reportError} from \"../errors\"\nimport {_, Name} from \"../codegen\"\nimport N from \"../names\"\n\nconst boolError: KeywordErrorDefinition = {\n  message: \"boolean schema is false\",\n}\n\nexport function topBoolOrEmptySchema(it: SchemaCxt): void {\n  const {gen, schema, validateName} = it\n  if (schema === false) {\n    falseSchemaError(it, false)\n  } else if (typeof schema == \"object\" && schema.$async === true) {\n    gen.return(N.data)\n  } else {\n    gen.assign(_`${validateName}.errors`, null)\n    gen.return(true)\n  }\n}\n\nexport function boolOrEmptySchema(it: SchemaCxt, valid: Name): void {\n  const {gen, schema} = it\n  if (schema === false) {\n    gen.var(valid, false) // TODO var\n    falseSchemaError(it)\n  } else {\n    gen.var(valid, true) // TODO var\n  }\n}\n\nfunction falseSchemaError(it: SchemaCxt, overrideAllErrors?: boolean): void {\n  const {gen, data} = it\n  // TODO maybe some other interface should be used for non-keyword validation errors...\n  const cxt: KeywordErrorCxt = {\n    gen,\n    keyword: \"false schema\",\n    data,\n    schema: false,\n    schemaCode: false,\n    schemaValue: false,\n    params: {},\n    it,\n  }\n  reportError(cxt, boolError, undefined, overrideAllErrors)\n}\n","import type {\n  KeywordErrorDefinition,\n  KeywordErrorCxt,\n  ErrorObject,\n  AnySchemaObject,\n} from \"../../types\"\nimport type {SchemaObjCxt} from \"..\"\nimport {isJSONType, JSONType} from \"../rules\"\nimport {schemaHasRulesForType} from \"./applicability\"\nimport {reportError} from \"../errors\"\nimport {_, nil, and, not, operators, Code, Name} from \"../codegen\"\nimport {toHash, schemaRefOrVal} from \"../util\"\n\nexport enum DataType {\n  Correct,\n  Wrong,\n}\n\nexport function getSchemaTypes(schema: AnySchemaObject): JSONType[] {\n  const types = getJSONTypes(schema.type)\n  const hasNull = types.includes(\"null\")\n  if (hasNull) {\n    if (schema.nullable === false) throw new Error(\"type: null contradicts nullable: false\")\n  } else {\n    if (!types.length && schema.nullable !== undefined) {\n      throw new Error('\"nullable\" cannot be used without \"type\"')\n    }\n    if (schema.nullable === true) types.push(\"null\")\n  }\n  return types\n}\n\nexport function getJSONTypes(ts: unknown | unknown[]): JSONType[] {\n  const types: unknown[] = Array.isArray(ts) ? ts : ts ? [ts] : []\n  if (types.every(isJSONType)) return types\n  throw new Error(\"type must be JSONType or JSONType[]: \" + types.join(\",\"))\n}\n\nexport function coerceAndCheckDataType(it: SchemaObjCxt, types: JSONType[]): boolean {\n  const {gen, data, opts} = it\n  const coerceTo = coerceToTypes(types, opts.coerceTypes)\n  const checkTypes =\n    types.length > 0 &&\n    !(coerceTo.length === 0 && types.length === 1 && schemaHasRulesForType(it, types[0]))\n  if (checkTypes) {\n    const wrongType = checkDataTypes(types, data, opts.strictNumbers, DataType.Wrong)\n    gen.if(wrongType, () => {\n      if (coerceTo.length) coerceData(it, types, coerceTo)\n      else reportTypeError(it)\n    })\n  }\n  return checkTypes\n}\n\nconst COERCIBLE: Set<JSONType> = new Set([\"string\", \"number\", \"integer\", \"boolean\", \"null\"])\nfunction coerceToTypes(types: JSONType[], coerceTypes?: boolean | \"array\"): JSONType[] {\n  return coerceTypes\n    ? types.filter((t) => COERCIBLE.has(t) || (coerceTypes === \"array\" && t === \"array\"))\n    : []\n}\n\nfunction coerceData(it: SchemaObjCxt, types: JSONType[], coerceTo: JSONType[]): void {\n  const {gen, data, opts} = it\n  const dataType = gen.let(\"dataType\", _`typeof ${data}`)\n  const coerced = gen.let(\"coerced\", _`undefined`)\n  if (opts.coerceTypes === \"array\") {\n    gen.if(_`${dataType} == 'object' && Array.isArray(${data}) && ${data}.length == 1`, () =>\n      gen\n        .assign(data, _`${data}[0]`)\n        .assign(dataType, _`typeof ${data}`)\n        .if(checkDataTypes(types, data, opts.strictNumbers), () => gen.assign(coerced, data))\n    )\n  }\n  gen.if(_`${coerced} !== undefined`)\n  for (const t of coerceTo) {\n    if (COERCIBLE.has(t) || (t === \"array\" && opts.coerceTypes === \"array\")) {\n      coerceSpecificType(t)\n    }\n  }\n  gen.else()\n  reportTypeError(it)\n  gen.endIf()\n\n  gen.if(_`${coerced} !== undefined`, () => {\n    gen.assign(data, coerced)\n    assignParentData(it, coerced)\n  })\n\n  function coerceSpecificType(t: string): void {\n    switch (t) {\n      case \"string\":\n        gen\n          .elseIf(_`${dataType} == \"number\" || ${dataType} == \"boolean\"`)\n          .assign(coerced, _`\"\" + ${data}`)\n          .elseIf(_`${data} === null`)\n          .assign(coerced, _`\"\"`)\n        return\n      case \"number\":\n        gen\n          .elseIf(\n            _`${dataType} == \"boolean\" || ${data} === null\n              || (${dataType} == \"string\" && ${data} && ${data} == +${data})`\n          )\n          .assign(coerced, _`+${data}`)\n        return\n      case \"integer\":\n        gen\n          .elseIf(\n            _`${dataType} === \"boolean\" || ${data} === null\n              || (${dataType} === \"string\" && ${data} && ${data} == +${data} && !(${data} % 1))`\n          )\n          .assign(coerced, _`+${data}`)\n        return\n      case \"boolean\":\n        gen\n          .elseIf(_`${data} === \"false\" || ${data} === 0 || ${data} === null`)\n          .assign(coerced, false)\n          .elseIf(_`${data} === \"true\" || ${data} === 1`)\n          .assign(coerced, true)\n        return\n      case \"null\":\n        gen.elseIf(_`${data} === \"\" || ${data} === 0 || ${data} === false`)\n        gen.assign(coerced, null)\n        return\n\n      case \"array\":\n        gen\n          .elseIf(\n            _`${dataType} === \"string\" || ${dataType} === \"number\"\n              || ${dataType} === \"boolean\" || ${data} === null`\n          )\n          .assign(coerced, _`[${data}]`)\n    }\n  }\n}\n\nfunction assignParentData({gen, parentData, parentDataProperty}: SchemaObjCxt, expr: Name): void {\n  // TODO use gen.property\n  gen.if(_`${parentData} !== undefined`, () =>\n    gen.assign(_`${parentData}[${parentDataProperty}]`, expr)\n  )\n}\n\nexport function checkDataType(\n  dataType: JSONType,\n  data: Name,\n  strictNums?: boolean | \"log\",\n  correct = DataType.Correct\n): Code {\n  const EQ = correct === DataType.Correct ? operators.EQ : operators.NEQ\n  let cond: Code\n  switch (dataType) {\n    case \"null\":\n      return _`${data} ${EQ} null`\n    case \"array\":\n      cond = _`Array.isArray(${data})`\n      break\n    case \"object\":\n      cond = _`${data} && typeof ${data} == \"object\" && !Array.isArray(${data})`\n      break\n    case \"integer\":\n      cond = numCond(_`!(${data} % 1) && !isNaN(${data})`)\n      break\n    case \"number\":\n      cond = numCond()\n      break\n    default:\n      return _`typeof ${data} ${EQ} ${dataType}`\n  }\n  return correct === DataType.Correct ? cond : not(cond)\n\n  function numCond(_cond: Code = nil): Code {\n    return and(_`typeof ${data} == \"number\"`, _cond, strictNums ? _`isFinite(${data})` : nil)\n  }\n}\n\nexport function checkDataTypes(\n  dataTypes: JSONType[],\n  data: Name,\n  strictNums?: boolean | \"log\",\n  correct?: DataType\n): Code {\n  if (dataTypes.length === 1) {\n    return checkDataType(dataTypes[0], data, strictNums, correct)\n  }\n  let cond: Code\n  const types = toHash(dataTypes)\n  if (types.array && types.object) {\n    const notObj = _`typeof ${data} != \"object\"`\n    cond = types.null ? notObj : _`!${data} || ${notObj}`\n    delete types.null\n    delete types.array\n    delete types.object\n  } else {\n    cond = nil\n  }\n  if (types.number) delete types.integer\n  for (const t in types) cond = and(cond, checkDataType(t as JSONType, data, strictNums, correct))\n  return cond\n}\n\nexport type TypeError = ErrorObject<\"type\", {type: string}>\n\nconst typeError: KeywordErrorDefinition = {\n  message: ({schema}) => `must be ${schema}`,\n  params: ({schema, schemaValue}) =>\n    typeof schema == \"string\" ? _`{type: ${schema}}` : _`{type: ${schemaValue}}`,\n}\n\nexport function reportTypeError(it: SchemaObjCxt): void {\n  const cxt = getTypeErrorContext(it)\n  reportError(cxt, typeError)\n}\n\nfunction getTypeErrorContext(it: SchemaObjCxt): KeywordErrorCxt {\n  const {gen, data, schema} = it\n  const schemaCode = schemaRefOrVal(it, schema, \"type\")\n  return {\n    gen,\n    keyword: \"type\",\n    data,\n    schema: schema.type,\n    schemaCode,\n    schemaValue: schemaCode,\n    parentSchema: schema,\n    params: {},\n    it,\n  }\n}\n","import type {SchemaObjCxt} from \"..\"\nimport {_, getProperty, stringify} from \"../codegen\"\nimport {checkStrictMode} from \"../util\"\n\nexport function assignDefaults(it: SchemaObjCxt, ty?: string): void {\n  const {properties, items} = it.schema\n  if (ty === \"object\" && properties) {\n    for (const key in properties) {\n      assignDefault(it, key, properties[key].default)\n    }\n  } else if (ty === \"array\" && Array.isArray(items)) {\n    items.forEach((sch, i: number) => assignDefault(it, i, sch.default))\n  }\n}\n\nfunction assignDefault(it: SchemaObjCxt, prop: string | number, defaultValue: unknown): void {\n  const {gen, compositeRule, data, opts} = it\n  if (defaultValue === undefined) return\n  const childData = _`${data}${getProperty(prop)}`\n  if (compositeRule) {\n    checkStrictMode(it, `default is ignored for: ${childData}`)\n    return\n  }\n\n  let condition = _`${childData} === undefined`\n  if (opts.useDefaults === \"empty\") {\n    condition = _`${condition} || ${childData} === null || ${childData} === \"\"`\n  }\n  // `${childData} === undefined` +\n  // (opts.useDefaults === \"empty\" ? ` || ${childData} === null || ${childData} === \"\"` : \"\")\n  gen.if(condition, _`${childData} = ${stringify(defaultValue)}`)\n}\n","import type {\n  AddedKeywordDefinition,\n  AnySchema,\n  AnySchemaObject,\n  KeywordErrorCxt,\n  KeywordCxtParams,\n} from \"../../types\"\nimport type {SchemaCxt, SchemaObjCxt} from \"..\"\nimport type {InstanceOptions} from \"../../core\"\nimport {boolOrEmptySchema, topBoolOrEmptySchema} from \"./boolSchema\"\nimport {coerceAndCheckDataType, getSchemaTypes} from \"./dataType\"\nimport {shouldUseGroup, shouldUseRule} from \"./applicability\"\nimport {checkDataType, checkDataTypes, reportTypeError, DataType} from \"./dataType\"\nimport {assignDefaults} from \"./defaults\"\nimport {funcKeywordCode, macroKeywordCode, validateKeywordUsage, validSchemaType} from \"./keyword\"\nimport {getSubschema, extendSubschemaData, SubschemaArgs, extendSubschemaMode} from \"./subschema\"\nimport {_, nil, str, or, not, getProperty, Block, Code, Name, CodeGen} from \"../codegen\"\nimport N from \"../names\"\nimport {resolveUrl} from \"../resolve\"\nimport {\n  schemaRefOrVal,\n  schemaHasRulesButRef,\n  checkUnknownRules,\n  checkStrictMode,\n  unescapeJsonPointer,\n  mergeEvaluated,\n} from \"../util\"\nimport type {JSONType, Rule, RuleGroup} from \"../rules\"\nimport {\n  ErrorPaths,\n  reportError,\n  reportExtraError,\n  resetErrorsCount,\n  keyword$DataError,\n} from \"../errors\"\n\n// schema compilation - generates validation function, subschemaCode (below) is used for subschemas\nexport function validateFunctionCode(it: SchemaCxt): void {\n  if (isSchemaObj(it)) {\n    checkKeywords(it)\n    if (schemaCxtHasRules(it)) {\n      topSchemaObjCode(it)\n      return\n    }\n  }\n  validateFunction(it, () => topBoolOrEmptySchema(it))\n}\n\nfunction validateFunction(\n  {gen, validateName, schema, schemaEnv, opts}: SchemaCxt,\n  body: Block\n): void {\n  if (opts.code.es5) {\n    gen.func(validateName, _`${N.data}, ${N.valCxt}`, schemaEnv.$async, () => {\n      gen.code(_`\"use strict\"; ${funcSourceUrl(schema, opts)}`)\n      destructureValCxtES5(gen, opts)\n      gen.code(body)\n    })\n  } else {\n    gen.func(validateName, _`${N.data}, ${destructureValCxt(opts)}`, schemaEnv.$async, () =>\n      gen.code(funcSourceUrl(schema, opts)).code(body)\n    )\n  }\n}\n\nfunction destructureValCxt(opts: InstanceOptions): Code {\n  return _`{${N.instancePath}=\"\", ${N.parentData}, ${N.parentDataProperty}, ${N.rootData}=${\n    N.data\n  }${opts.dynamicRef ? _`, ${N.dynamicAnchors}={}` : nil}}={}`\n}\n\nfunction destructureValCxtES5(gen: CodeGen, opts: InstanceOptions): void {\n  gen.if(\n    N.valCxt,\n    () => {\n      gen.var(N.instancePath, _`${N.valCxt}.${N.instancePath}`)\n      gen.var(N.parentData, _`${N.valCxt}.${N.parentData}`)\n      gen.var(N.parentDataProperty, _`${N.valCxt}.${N.parentDataProperty}`)\n      gen.var(N.rootData, _`${N.valCxt}.${N.rootData}`)\n      if (opts.dynamicRef) gen.var(N.dynamicAnchors, _`${N.valCxt}.${N.dynamicAnchors}`)\n    },\n    () => {\n      gen.var(N.instancePath, _`\"\"`)\n      gen.var(N.parentData, _`undefined`)\n      gen.var(N.parentDataProperty, _`undefined`)\n      gen.var(N.rootData, N.data)\n      if (opts.dynamicRef) gen.var(N.dynamicAnchors, _`{}`)\n    }\n  )\n}\n\nfunction topSchemaObjCode(it: SchemaObjCxt): void {\n  const {schema, opts, gen} = it\n  validateFunction(it, () => {\n    if (opts.$comment && schema.$comment) commentKeyword(it)\n    checkNoDefault(it)\n    gen.let(N.vErrors, null)\n    gen.let(N.errors, 0)\n    if (opts.unevaluated) resetEvaluated(it)\n    typeAndKeywords(it)\n    returnResults(it)\n  })\n  return\n}\n\nfunction resetEvaluated(it: SchemaObjCxt): void {\n  // TODO maybe some hook to execute it in the end to check whether props/items are Name, as in assignEvaluated\n  const {gen, validateName} = it\n  it.evaluated = gen.const(\"evaluated\", _`${validateName}.evaluated`)\n  gen.if(_`${it.evaluated}.dynamicProps`, () => gen.assign(_`${it.evaluated}.props`, _`undefined`))\n  gen.if(_`${it.evaluated}.dynamicItems`, () => gen.assign(_`${it.evaluated}.items`, _`undefined`))\n}\n\nfunction funcSourceUrl(schema: AnySchema, opts: InstanceOptions): Code {\n  const schId = typeof schema == \"object\" && schema[opts.schemaId]\n  return schId && (opts.code.source || opts.code.process) ? _`/*# sourceURL=${schId} */` : nil\n}\n\n// schema compilation - this function is used recursively to generate code for sub-schemas\nfunction subschemaCode(it: SchemaCxt, valid: Name): void {\n  if (isSchemaObj(it)) {\n    checkKeywords(it)\n    if (schemaCxtHasRules(it)) {\n      subSchemaObjCode(it, valid)\n      return\n    }\n  }\n  boolOrEmptySchema(it, valid)\n}\n\nfunction schemaCxtHasRules({schema, self}: SchemaCxt): boolean {\n  if (typeof schema == \"boolean\") return !schema\n  for (const key in schema) if (self.RULES.all[key]) return true\n  return false\n}\n\nfunction isSchemaObj(it: SchemaCxt): it is SchemaObjCxt {\n  return typeof it.schema != \"boolean\"\n}\n\nfunction subSchemaObjCode(it: SchemaObjCxt, valid: Name): void {\n  const {schema, gen, opts} = it\n  if (opts.$comment && schema.$comment) commentKeyword(it)\n  updateContext(it)\n  checkAsyncSchema(it)\n  const errsCount = gen.const(\"_errs\", N.errors)\n  typeAndKeywords(it, errsCount)\n  // TODO var\n  gen.var(valid, _`${errsCount} === ${N.errors}`)\n}\n\nfunction checkKeywords(it: SchemaObjCxt): void {\n  checkUnknownRules(it)\n  checkRefsAndKeywords(it)\n}\n\nfunction typeAndKeywords(it: SchemaObjCxt, errsCount?: Name): void {\n  if (it.opts.jtd) return schemaKeywords(it, [], false, errsCount)\n  const types = getSchemaTypes(it.schema)\n  const checkedTypes = coerceAndCheckDataType(it, types)\n  schemaKeywords(it, types, !checkedTypes, errsCount)\n}\n\nfunction checkRefsAndKeywords(it: SchemaObjCxt): void {\n  const {schema, errSchemaPath, opts, self} = it\n  if (schema.$ref && opts.ignoreKeywordsWithRef && schemaHasRulesButRef(schema, self.RULES)) {\n    self.logger.warn(`$ref: keywords ignored in schema at path \"${errSchemaPath}\"`)\n  }\n}\n\nfunction checkNoDefault(it: SchemaObjCxt): void {\n  const {schema, opts} = it\n  if (schema.default !== undefined && opts.useDefaults && opts.strictSchema) {\n    checkStrictMode(it, \"default is ignored in the schema root\")\n  }\n}\n\nfunction updateContext(it: SchemaObjCxt): void {\n  const schId = it.schema[it.opts.schemaId]\n  if (schId) it.baseId = resolveUrl(it.opts.uriResolver, it.baseId, schId)\n}\n\nfunction checkAsyncSchema(it: SchemaObjCxt): void {\n  if (it.schema.$async && !it.schemaEnv.$async) throw new Error(\"async schema in sync schema\")\n}\n\nfunction commentKeyword({gen, schemaEnv, schema, errSchemaPath, opts}: SchemaObjCxt): void {\n  const msg = schema.$comment\n  if (opts.$comment === true) {\n    gen.code(_`${N.self}.logger.log(${msg})`)\n  } else if (typeof opts.$comment == \"function\") {\n    const schemaPath = str`${errSchemaPath}/$comment`\n    const rootName = gen.scopeValue(\"root\", {ref: schemaEnv.root})\n    gen.code(_`${N.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`)\n  }\n}\n\nfunction returnResults(it: SchemaCxt): void {\n  const {gen, schemaEnv, validateName, ValidationError, opts} = it\n  if (schemaEnv.$async) {\n    // TODO assign unevaluated\n    gen.if(\n      _`${N.errors} === 0`,\n      () => gen.return(N.data),\n      () => gen.throw(_`new ${ValidationError as Name}(${N.vErrors})`)\n    )\n  } else {\n    gen.assign(_`${validateName}.errors`, N.vErrors)\n    if (opts.unevaluated) assignEvaluated(it)\n    gen.return(_`${N.errors} === 0`)\n  }\n}\n\nfunction assignEvaluated({gen, evaluated, props, items}: SchemaCxt): void {\n  if (props instanceof Name) gen.assign(_`${evaluated}.props`, props)\n  if (items instanceof Name) gen.assign(_`${evaluated}.items`, items)\n}\n\nfunction schemaKeywords(\n  it: SchemaObjCxt,\n  types: JSONType[],\n  typeErrors: boolean,\n  errsCount?: Name\n): void {\n  const {gen, schema, data, allErrors, opts, self} = it\n  const {RULES} = self\n  if (schema.$ref && (opts.ignoreKeywordsWithRef || !schemaHasRulesButRef(schema, RULES))) {\n    gen.block(() => keywordCode(it, \"$ref\", (RULES.all.$ref as Rule).definition)) // TODO typecast\n    return\n  }\n  if (!opts.jtd) checkStrictTypes(it, types)\n  gen.block(() => {\n    for (const group of RULES.rules) groupKeywords(group)\n    groupKeywords(RULES.post)\n  })\n\n  function groupKeywords(group: RuleGroup): void {\n    if (!shouldUseGroup(schema, group)) return\n    if (group.type) {\n      gen.if(checkDataType(group.type, data, opts.strictNumbers))\n      iterateKeywords(it, group)\n      if (types.length === 1 && types[0] === group.type && typeErrors) {\n        gen.else()\n        reportTypeError(it)\n      }\n      gen.endIf()\n    } else {\n      iterateKeywords(it, group)\n    }\n    // TODO make it \"ok\" call?\n    if (!allErrors) gen.if(_`${N.errors} === ${errsCount || 0}`)\n  }\n}\n\nfunction iterateKeywords(it: SchemaObjCxt, group: RuleGroup): void {\n  const {\n    gen,\n    schema,\n    opts: {useDefaults},\n  } = it\n  if (useDefaults) assignDefaults(it, group.type)\n  gen.block(() => {\n    for (const rule of group.rules) {\n      if (shouldUseRule(schema, rule)) {\n        keywordCode(it, rule.keyword, rule.definition, group.type)\n      }\n    }\n  })\n}\n\nfunction checkStrictTypes(it: SchemaObjCxt, types: JSONType[]): void {\n  if (it.schemaEnv.meta || !it.opts.strictTypes) return\n  checkContextTypes(it, types)\n  if (!it.opts.allowUnionTypes) checkMultipleTypes(it, types)\n  checkKeywordTypes(it, it.dataTypes)\n}\n\nfunction checkContextTypes(it: SchemaObjCxt, types: JSONType[]): void {\n  if (!types.length) return\n  if (!it.dataTypes.length) {\n    it.dataTypes = types\n    return\n  }\n  types.forEach((t) => {\n    if (!includesType(it.dataTypes, t)) {\n      strictTypesError(it, `type \"${t}\" not allowed by context \"${it.dataTypes.join(\",\")}\"`)\n    }\n  })\n  narrowSchemaTypes(it, types)\n}\n\nfunction checkMultipleTypes(it: SchemaObjCxt, ts: JSONType[]): void {\n  if (ts.length > 1 && !(ts.length === 2 && ts.includes(\"null\"))) {\n    strictTypesError(it, \"use allowUnionTypes to allow union type keyword\")\n  }\n}\n\nfunction checkKeywordTypes(it: SchemaObjCxt, ts: JSONType[]): void {\n  const rules = it.self.RULES.all\n  for (const keyword in rules) {\n    const rule = rules[keyword]\n    if (typeof rule == \"object\" && shouldUseRule(it.schema, rule)) {\n      const {type} = rule.definition\n      if (type.length && !type.some((t) => hasApplicableType(ts, t))) {\n        strictTypesError(it, `missing type \"${type.join(\",\")}\" for keyword \"${keyword}\"`)\n      }\n    }\n  }\n}\n\nfunction hasApplicableType(schTs: JSONType[], kwdT: JSONType): boolean {\n  return schTs.includes(kwdT) || (kwdT === \"number\" && schTs.includes(\"integer\"))\n}\n\nfunction includesType(ts: JSONType[], t: JSONType): boolean {\n  return ts.includes(t) || (t === \"integer\" && ts.includes(\"number\"))\n}\n\nfunction narrowSchemaTypes(it: SchemaObjCxt, withTypes: JSONType[]): void {\n  const ts: JSONType[] = []\n  for (const t of it.dataTypes) {\n    if (includesType(withTypes, t)) ts.push(t)\n    else if (withTypes.includes(\"integer\") && t === \"number\") ts.push(\"integer\")\n  }\n  it.dataTypes = ts\n}\n\nfunction strictTypesError(it: SchemaObjCxt, msg: string): void {\n  const schemaPath = it.schemaEnv.baseId + it.errSchemaPath\n  msg += ` at \"${schemaPath}\" (strictTypes)`\n  checkStrictMode(it, msg, it.opts.strictTypes)\n}\n\nexport class KeywordCxt implements KeywordErrorCxt {\n  readonly gen: CodeGen\n  readonly allErrors?: boolean\n  readonly keyword: string\n  readonly data: Name // Name referencing the current level of the data instance\n  readonly $data?: string | false\n  schema: any // keyword value in the schema\n  readonly schemaValue: Code | number | boolean // Code reference to keyword schema value or primitive value\n  readonly schemaCode: Code | number | boolean // Code reference to resolved schema value (different if schema is $data)\n  readonly schemaType: JSONType[] // allowed type(s) of keyword value in the schema\n  readonly parentSchema: AnySchemaObject\n  readonly errsCount?: Name // Name reference to the number of validation errors collected before this keyword,\n  // requires option trackErrors in keyword definition\n  params: KeywordCxtParams // object to pass parameters to error messages from keyword code\n  readonly it: SchemaObjCxt // schema compilation context (schema is guaranteed to be an object, not boolean)\n  readonly def: AddedKeywordDefinition\n\n  constructor(it: SchemaObjCxt, def: AddedKeywordDefinition, keyword: string) {\n    validateKeywordUsage(it, def, keyword)\n    this.gen = it.gen\n    this.allErrors = it.allErrors\n    this.keyword = keyword\n    this.data = it.data\n    this.schema = it.schema[keyword]\n    this.$data = def.$data && it.opts.$data && this.schema && this.schema.$data\n    this.schemaValue = schemaRefOrVal(it, this.schema, keyword, this.$data)\n    this.schemaType = def.schemaType\n    this.parentSchema = it.schema\n    this.params = {}\n    this.it = it\n    this.def = def\n\n    if (this.$data) {\n      this.schemaCode = it.gen.const(\"vSchema\", getData(this.$data, it))\n    } else {\n      this.schemaCode = this.schemaValue\n      if (!validSchemaType(this.schema, def.schemaType, def.allowUndefined)) {\n        throw new Error(`${keyword} value must be ${JSON.stringify(def.schemaType)}`)\n      }\n    }\n\n    if (\"code\" in def ? def.trackErrors : def.errors !== false) {\n      this.errsCount = it.gen.const(\"_errs\", N.errors)\n    }\n  }\n\n  result(condition: Code, successAction?: () => void, failAction?: () => void): void {\n    this.failResult(not(condition), successAction, failAction)\n  }\n\n  failResult(condition: Code, successAction?: () => void, failAction?: () => void): void {\n    this.gen.if(condition)\n    if (failAction) failAction()\n    else this.error()\n    if (successAction) {\n      this.gen.else()\n      successAction()\n      if (this.allErrors) this.gen.endIf()\n    } else {\n      if (this.allErrors) this.gen.endIf()\n      else this.gen.else()\n    }\n  }\n\n  pass(condition: Code, failAction?: () => void): void {\n    this.failResult(not(condition), undefined, failAction)\n  }\n\n  fail(condition?: Code): void {\n    if (condition === undefined) {\n      this.error()\n      if (!this.allErrors) this.gen.if(false) // this branch will be removed by gen.optimize\n      return\n    }\n    this.gen.if(condition)\n    this.error()\n    if (this.allErrors) this.gen.endIf()\n    else this.gen.else()\n  }\n\n  fail$data(condition: Code): void {\n    if (!this.$data) return this.fail(condition)\n    const {schemaCode} = this\n    this.fail(_`${schemaCode} !== undefined && (${or(this.invalid$data(), condition)})`)\n  }\n\n  error(append?: boolean, errorParams?: KeywordCxtParams, errorPaths?: ErrorPaths): void {\n    if (errorParams) {\n      this.setParams(errorParams)\n      this._error(append, errorPaths)\n      this.setParams({})\n      return\n    }\n    this._error(append, errorPaths)\n  }\n\n  private _error(append?: boolean, errorPaths?: ErrorPaths): void {\n    ;(append ? reportExtraError : reportError)(this, this.def.error, errorPaths)\n  }\n\n  $dataError(): void {\n    reportError(this, this.def.$dataError || keyword$DataError)\n  }\n\n  reset(): void {\n    if (this.errsCount === undefined) throw new Error('add \"trackErrors\" to keyword definition')\n    resetErrorsCount(this.gen, this.errsCount)\n  }\n\n  ok(cond: Code | boolean): void {\n    if (!this.allErrors) this.gen.if(cond)\n  }\n\n  setParams(obj: KeywordCxtParams, assign?: true): void {\n    if (assign) Object.assign(this.params, obj)\n    else this.params = obj\n  }\n\n  block$data(valid: Name, codeBlock: () => void, $dataValid: Code = nil): void {\n    this.gen.block(() => {\n      this.check$data(valid, $dataValid)\n      codeBlock()\n    })\n  }\n\n  check$data(valid: Name = nil, $dataValid: Code = nil): void {\n    if (!this.$data) return\n    const {gen, schemaCode, schemaType, def} = this\n    gen.if(or(_`${schemaCode} === undefined`, $dataValid))\n    if (valid !== nil) gen.assign(valid, true)\n    if (schemaType.length || def.validateSchema) {\n      gen.elseIf(this.invalid$data())\n      this.$dataError()\n      if (valid !== nil) gen.assign(valid, false)\n    }\n    gen.else()\n  }\n\n  invalid$data(): Code {\n    const {gen, schemaCode, schemaType, def, it} = this\n    return or(wrong$DataType(), invalid$DataSchema())\n\n    function wrong$DataType(): Code {\n      if (schemaType.length) {\n        /* istanbul ignore if */\n        if (!(schemaCode instanceof Name)) throw new Error(\"ajv implementation error\")\n        const st = Array.isArray(schemaType) ? schemaType : [schemaType]\n        return _`${checkDataTypes(st, schemaCode, it.opts.strictNumbers, DataType.Wrong)}`\n      }\n      return nil\n    }\n\n    function invalid$DataSchema(): Code {\n      if (def.validateSchema) {\n        const validateSchemaRef = gen.scopeValue(\"validate$data\", {ref: def.validateSchema}) // TODO value.code for standalone\n        return _`!${validateSchemaRef}(${schemaCode})`\n      }\n      return nil\n    }\n  }\n\n  subschema(appl: SubschemaArgs, valid: Name): SchemaCxt {\n    const subschema = getSubschema(this.it, appl)\n    extendSubschemaData(subschema, this.it, appl)\n    extendSubschemaMode(subschema, appl)\n    const nextContext = {...this.it, ...subschema, items: undefined, props: undefined}\n    subschemaCode(nextContext, valid)\n    return nextContext\n  }\n\n  mergeEvaluated(schemaCxt: SchemaCxt, toName?: typeof Name): void {\n    const {it, gen} = this\n    if (!it.opts.unevaluated) return\n    if (it.props !== true && schemaCxt.props !== undefined) {\n      it.props = mergeEvaluated.props(gen, schemaCxt.props, it.props, toName)\n    }\n    if (it.items !== true && schemaCxt.items !== undefined) {\n      it.items = mergeEvaluated.items(gen, schemaCxt.items, it.items, toName)\n    }\n  }\n\n  mergeValidEvaluated(schemaCxt: SchemaCxt, valid: Name): boolean | void {\n    const {it, gen} = this\n    if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {\n      gen.if(valid, () => this.mergeEvaluated(schemaCxt, Name))\n      return true\n    }\n  }\n}\n\nfunction keywordCode(\n  it: SchemaObjCxt,\n  keyword: string,\n  def: AddedKeywordDefinition,\n  ruleType?: JSONType\n): void {\n  const cxt = new KeywordCxt(it, def, keyword)\n  if (\"code\" in def) {\n    def.code(cxt, ruleType)\n  } else if (cxt.$data && def.validate) {\n    funcKeywordCode(cxt, def)\n  } else if (\"macro\" in def) {\n    macroKeywordCode(cxt, def)\n  } else if (def.compile || def.validate) {\n    funcKeywordCode(cxt, def)\n  }\n}\n\nconst JSON_POINTER = /^\\/(?:[^~]|~0|~1)*$/\nconst RELATIVE_JSON_POINTER = /^([0-9]+)(#|\\/(?:[^~]|~0|~1)*)?$/\nexport function getData(\n  $data: string,\n  {dataLevel, dataNames, dataPathArr}: SchemaCxt\n): Code | number {\n  let jsonPointer\n  let data: Code\n  if ($data === \"\") return N.rootData\n  if ($data[0] === \"/\") {\n    if (!JSON_POINTER.test($data)) throw new Error(`Invalid JSON-pointer: ${$data}`)\n    jsonPointer = $data\n    data = N.rootData\n  } else {\n    const matches = RELATIVE_JSON_POINTER.exec($data)\n    if (!matches) throw new Error(`Invalid JSON-pointer: ${$data}`)\n    const up: number = +matches[1]\n    jsonPointer = matches[2]\n    if (jsonPointer === \"#\") {\n      if (up >= dataLevel) throw new Error(errorMsg(\"property/index\", up))\n      return dataPathArr[dataLevel - up]\n    }\n    if (up > dataLevel) throw new Error(errorMsg(\"data\", up))\n    data = dataNames[dataLevel - up]\n    if (!jsonPointer) return data\n  }\n\n  let expr = data\n  const segments = jsonPointer.split(\"/\")\n  for (const segment of segments) {\n    if (segment) {\n      data = _`${data}${getProperty(unescapeJsonPointer(segment))}`\n      expr = _`${expr} && ${data}`\n    }\n  }\n  return expr\n\n  function errorMsg(pointerType: string, up: number): string {\n    return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`\n  }\n}\n","import type {KeywordCxt} from \".\"\nimport type {\n  AnySchema,\n  SchemaValidateFunction,\n  AnyValidateFunction,\n  AddedKeywordDefinition,\n  MacroKeywordDefinition,\n  FuncKeywordDefinition,\n} from \"../../types\"\nimport type {SchemaObjCxt} from \"..\"\nimport {_, nil, not, stringify, Code, Name, CodeGen} from \"../codegen\"\nimport N from \"../names\"\nimport type {JSONType} from \"../rules\"\nimport {callValidateCode} from \"../../vocabularies/code\"\nimport {extendErrors} from \"../errors\"\n\ntype KeywordCompilationResult = AnySchema | SchemaValidateFunction | AnyValidateFunction\n\nexport function macroKeywordCode(cxt: KeywordCxt, def: MacroKeywordDefinition): void {\n  const {gen, keyword, schema, parentSchema, it} = cxt\n  const macroSchema = def.macro.call(it.self, schema, parentSchema, it)\n  const schemaRef = useKeyword(gen, keyword, macroSchema)\n  if (it.opts.validateSchema !== false) it.self.validateSchema(macroSchema, true)\n\n  const valid = gen.name(\"valid\")\n  cxt.subschema(\n    {\n      schema: macroSchema,\n      schemaPath: nil,\n      errSchemaPath: `${it.errSchemaPath}/${keyword}`,\n      topSchemaRef: schemaRef,\n      compositeRule: true,\n    },\n    valid\n  )\n  cxt.pass(valid, () => cxt.error(true))\n}\n\nexport function funcKeywordCode(cxt: KeywordCxt, def: FuncKeywordDefinition): void {\n  const {gen, keyword, schema, parentSchema, $data, it} = cxt\n  checkAsyncKeyword(it, def)\n  const validate =\n    !$data && def.compile ? def.compile.call(it.self, schema, parentSchema, it) : def.validate\n  const validateRef = useKeyword(gen, keyword, validate)\n  const valid = gen.let(\"valid\")\n  cxt.block$data(valid, validateKeyword)\n  cxt.ok(def.valid ?? valid)\n\n  function validateKeyword(): void {\n    if (def.errors === false) {\n      assignValid()\n      if (def.modifying) modifyData(cxt)\n      reportErrs(() => cxt.error())\n    } else {\n      const ruleErrs = def.async ? validateAsync() : validateSync()\n      if (def.modifying) modifyData(cxt)\n      reportErrs(() => addErrs(cxt, ruleErrs))\n    }\n  }\n\n  function validateAsync(): Name {\n    const ruleErrs = gen.let(\"ruleErrs\", null)\n    gen.try(\n      () => assignValid(_`await `),\n      (e) =>\n        gen.assign(valid, false).if(\n          _`${e} instanceof ${it.ValidationError as Name}`,\n          () => gen.assign(ruleErrs, _`${e}.errors`),\n          () => gen.throw(e)\n        )\n    )\n    return ruleErrs\n  }\n\n  function validateSync(): Code {\n    const validateErrs = _`${validateRef}.errors`\n    gen.assign(validateErrs, null)\n    assignValid(nil)\n    return validateErrs\n  }\n\n  function assignValid(_await: Code = def.async ? _`await ` : nil): void {\n    const passCxt = it.opts.passContext ? N.this : N.self\n    const passSchema = !((\"compile\" in def && !$data) || def.schema === false)\n    gen.assign(\n      valid,\n      _`${_await}${callValidateCode(cxt, validateRef, passCxt, passSchema)}`,\n      def.modifying\n    )\n  }\n\n  function reportErrs(errors: () => void): void {\n    gen.if(not(def.valid ?? valid), errors)\n  }\n}\n\nfunction modifyData(cxt: KeywordCxt): void {\n  const {gen, data, it} = cxt\n  gen.if(it.parentData, () => gen.assign(data, _`${it.parentData}[${it.parentDataProperty}]`))\n}\n\nfunction addErrs(cxt: KeywordCxt, errs: Code): void {\n  const {gen} = cxt\n  gen.if(\n    _`Array.isArray(${errs})`,\n    () => {\n      gen\n        .assign(N.vErrors, _`${N.vErrors} === null ? ${errs} : ${N.vErrors}.concat(${errs})`)\n        .assign(N.errors, _`${N.vErrors}.length`)\n      extendErrors(cxt)\n    },\n    () => cxt.error()\n  )\n}\n\nfunction checkAsyncKeyword({schemaEnv}: SchemaObjCxt, def: FuncKeywordDefinition): void {\n  if (def.async && !schemaEnv.$async) throw new Error(\"async keyword in sync schema\")\n}\n\nfunction useKeyword(gen: CodeGen, keyword: string, result?: KeywordCompilationResult): Name {\n  if (result === undefined) throw new Error(`keyword \"${keyword}\" failed to compile`)\n  return gen.scopeValue(\n    \"keyword\",\n    typeof result == \"function\" ? {ref: result} : {ref: result, code: stringify(result)}\n  )\n}\n\nexport function validSchemaType(\n  schema: unknown,\n  schemaType: JSONType[],\n  allowUndefined = false\n): boolean {\n  // TODO add tests\n  return (\n    !schemaType.length ||\n    schemaType.some((st) =>\n      st === \"array\"\n        ? Array.isArray(schema)\n        : st === \"object\"\n        ? schema && typeof schema == \"object\" && !Array.isArray(schema)\n        : typeof schema == st || (allowUndefined && typeof schema == \"undefined\")\n    )\n  )\n}\n\nexport function validateKeywordUsage(\n  {schema, opts, self, errSchemaPath}: SchemaObjCxt,\n  def: AddedKeywordDefinition,\n  keyword: string\n): void {\n  /* istanbul ignore if */\n  if (Array.isArray(def.keyword) ? !def.keyword.includes(keyword) : def.keyword !== keyword) {\n    throw new Error(\"ajv implementation error\")\n  }\n\n  const deps = def.dependencies\n  if (deps?.some((kwd) => !Object.prototype.hasOwnProperty.call(schema, kwd))) {\n    throw new Error(`parent schema must have dependencies of ${keyword}: ${deps.join(\",\")}`)\n  }\n\n  if (def.validateSchema) {\n    const valid = def.validateSchema(schema[keyword])\n    if (!valid) {\n      const msg =\n        `keyword \"${keyword}\" value is invalid at path \"${errSchemaPath}\": ` +\n        self.errorsText(def.validateSchema.errors)\n      if (opts.validateSchema === \"log\") self.logger.error(msg)\n      else throw new Error(msg)\n    }\n  }\n}\n","import type {AnySchema} from \"../../types\"\nimport type {SchemaObjCxt} from \"..\"\nimport {_, str, getProperty, Code, Name} from \"../codegen\"\nimport {escapeFragment, getErrorPath, Type} from \"../util\"\nimport type {JSONType} from \"../rules\"\n\nexport interface SubschemaContext {\n  // TODO use Optional? align with SchemCxt property types\n  schema: AnySchema\n  schemaPath: Code\n  errSchemaPath: string\n  topSchemaRef?: Code\n  errorPath?: Code\n  dataLevel?: number\n  dataTypes?: JSONType[]\n  data?: Name\n  parentData?: Name\n  parentDataProperty?: Code | number\n  dataNames?: Name[]\n  dataPathArr?: (Code | number)[]\n  propertyName?: Name\n  jtdDiscriminator?: string\n  jtdMetadata?: boolean\n  compositeRule?: true\n  createErrors?: boolean\n  allErrors?: boolean\n}\n\nexport type SubschemaArgs = Partial<{\n  keyword: string\n  schemaProp: string | number\n  schema: AnySchema\n  schemaPath: Code\n  errSchemaPath: string\n  topSchemaRef: Code\n  data: Name | Code\n  dataProp: Code | string | number\n  dataTypes: JSONType[]\n  definedProperties: Set<string>\n  propertyName: Name\n  dataPropType: Type\n  jtdDiscriminator: string\n  jtdMetadata: boolean\n  compositeRule: true\n  createErrors: boolean\n  allErrors: boolean\n}>\n\nexport function getSubschema(\n  it: SchemaObjCxt,\n  {keyword, schemaProp, schema, schemaPath, errSchemaPath, topSchemaRef}: SubschemaArgs\n): SubschemaContext {\n  if (keyword !== undefined && schema !== undefined) {\n    throw new Error('both \"keyword\" and \"schema\" passed, only one allowed')\n  }\n\n  if (keyword !== undefined) {\n    const sch = it.schema[keyword]\n    return schemaProp === undefined\n      ? {\n          schema: sch,\n          schemaPath: _`${it.schemaPath}${getProperty(keyword)}`,\n          errSchemaPath: `${it.errSchemaPath}/${keyword}`,\n        }\n      : {\n          schema: sch[schemaProp],\n          schemaPath: _`${it.schemaPath}${getProperty(keyword)}${getProperty(schemaProp)}`,\n          errSchemaPath: `${it.errSchemaPath}/${keyword}/${escapeFragment(schemaProp)}`,\n        }\n  }\n\n  if (schema !== undefined) {\n    if (schemaPath === undefined || errSchemaPath === undefined || topSchemaRef === undefined) {\n      throw new Error('\"schemaPath\", \"errSchemaPath\" and \"topSchemaRef\" are required with \"schema\"')\n    }\n    return {\n      schema,\n      schemaPath,\n      topSchemaRef,\n      errSchemaPath,\n    }\n  }\n\n  throw new Error('either \"keyword\" or \"schema\" must be passed')\n}\n\nexport function extendSubschemaData(\n  subschema: SubschemaContext,\n  it: SchemaObjCxt,\n  {dataProp, dataPropType: dpType, data, dataTypes, propertyName}: SubschemaArgs\n): void {\n  if (data !== undefined && dataProp !== undefined) {\n    throw new Error('both \"data\" and \"dataProp\" passed, only one allowed')\n  }\n\n  const {gen} = it\n\n  if (dataProp !== undefined) {\n    const {errorPath, dataPathArr, opts} = it\n    const nextData = gen.let(\"data\", _`${it.data}${getProperty(dataProp)}`, true)\n    dataContextProps(nextData)\n    subschema.errorPath = str`${errorPath}${getErrorPath(dataProp, dpType, opts.jsPropertySyntax)}`\n    subschema.parentDataProperty = _`${dataProp}`\n    subschema.dataPathArr = [...dataPathArr, subschema.parentDataProperty]\n  }\n\n  if (data !== undefined) {\n    const nextData = data instanceof Name ? data : gen.let(\"data\", data, true) // replaceable if used once?\n    dataContextProps(nextData)\n    if (propertyName !== undefined) subschema.propertyName = propertyName\n    // TODO something is possibly wrong here with not changing parentDataProperty and not appending dataPathArr\n  }\n\n  if (dataTypes) subschema.dataTypes = dataTypes\n\n  function dataContextProps(_nextData: Name): void {\n    subschema.data = _nextData\n    subschema.dataLevel = it.dataLevel + 1\n    subschema.dataTypes = []\n    it.definedProperties = new Set<string>()\n    subschema.parentData = it.data\n    subschema.dataNames = [...it.dataNames, _nextData]\n  }\n}\n\nexport function extendSubschemaMode(\n  subschema: SubschemaContext,\n  {jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors}: SubschemaArgs\n): void {\n  if (compositeRule !== undefined) subschema.compositeRule = compositeRule\n  if (createErrors !== undefined) subschema.createErrors = createErrors\n  if (allErrors !== undefined) subschema.allErrors = allErrors\n  subschema.jtdDiscriminator = jtdDiscriminator // not inherited\n  subschema.jtdMetadata = jtdMetadata // not inherited\n}\n","export {\n  Format,\n  FormatDefinition,\n  AsyncFormatDefinition,\n  KeywordDefinition,\n  KeywordErrorDefinition,\n  CodeKeywordDefinition,\n  MacroKeywordDefinition,\n  FuncKeywordDefinition,\n  Vocabulary,\n  Schema,\n  SchemaObject,\n  AnySchemaObject,\n  AsyncSchema,\n  AnySchema,\n  ValidateFunction,\n  AsyncValidateFunction,\n  AnyValidateFunction,\n  ErrorObject,\n  ErrorNoParams,\n} from \"./types\"\n\nexport {SchemaCxt, SchemaObjCxt} from \"./compile\"\nexport interface Plugin<Opts> {\n  (ajv: Ajv, options?: Opts): Ajv\n  [prop: string]: any\n}\n\nexport {KeywordCxt} from \"./compile/validate\"\nexport {DefinedError} from \"./vocabularies/errors\"\nexport {JSONType} from \"./compile/rules\"\nexport {JSONSchemaType} from \"./types/json-schema\"\nexport {JTDSchemaType, SomeJTDSchemaType, JTDDataType} from \"./types/jtd-schema\"\nexport {_, str, stringify, nil, Name, Code, CodeGen, CodeGenOptions} from \"./compile/codegen\"\n\nimport type {\n  Schema,\n  AnySchema,\n  AnySchemaObject,\n  SchemaObject,\n  AsyncSchema,\n  Vocabulary,\n  KeywordDefinition,\n  AddedKeywordDefinition,\n  AnyValidateFunction,\n  ValidateFunction,\n  AsyncValidateFunction,\n  ErrorObject,\n  Format,\n  AddedFormat,\n  RegExpEngine,\n  UriResolver,\n} from \"./types\"\nimport type {JSONSchemaType} from \"./types/json-schema\"\nimport type {JTDSchemaType, SomeJTDSchemaType, JTDDataType} from \"./types/jtd-schema\"\nimport ValidationError from \"./runtime/validation_error\"\nimport MissingRefError from \"./compile/ref_error\"\nimport {getRules, ValidationRules, Rule, RuleGroup, JSONType} from \"./compile/rules\"\nimport {SchemaEnv, compileSchema, resolveSchema} from \"./compile\"\nimport {Code, ValueScope} from \"./compile/codegen\"\nimport {normalizeId, getSchemaRefs} from \"./compile/resolve\"\nimport {getJSONTypes} from \"./compile/validate/dataType\"\nimport {eachItem} from \"./compile/util\"\nimport * as $dataRefSchema from \"./refs/data.json\"\n\nimport DefaultUriResolver from \"./runtime/uri\"\n\nconst defaultRegExp: RegExpEngine = (str, flags) => new RegExp(str, flags)\ndefaultRegExp.code = \"new RegExp\"\n\nconst META_IGNORE_OPTIONS: (keyof Options)[] = [\"removeAdditional\", \"useDefaults\", \"coerceTypes\"]\nconst EXT_SCOPE_NAMES = new Set([\n  \"validate\",\n  \"serialize\",\n  \"parse\",\n  \"wrapper\",\n  \"root\",\n  \"schema\",\n  \"keyword\",\n  \"pattern\",\n  \"formats\",\n  \"validate$data\",\n  \"func\",\n  \"obj\",\n  \"Error\",\n])\n\nexport type Options = CurrentOptions & DeprecatedOptions\n\nexport interface CurrentOptions {\n  // strict mode options (NEW)\n  strict?: boolean | \"log\"\n  strictSchema?: boolean | \"log\"\n  strictNumbers?: boolean | \"log\"\n  strictTypes?: boolean | \"log\"\n  strictTuples?: boolean | \"log\"\n  strictRequired?: boolean | \"log\"\n  allowMatchingProperties?: boolean // disables a strict mode restriction\n  allowUnionTypes?: boolean\n  validateFormats?: boolean\n  // validation and reporting options:\n  $data?: boolean\n  allErrors?: boolean\n  verbose?: boolean\n  discriminator?: boolean\n  unicodeRegExp?: boolean\n  timestamp?: \"string\" | \"date\" // JTD only\n  parseDate?: boolean // JTD only\n  allowDate?: boolean // JTD only\n  $comment?:\n    | true\n    | ((comment: string, schemaPath?: string, rootSchema?: AnySchemaObject) => unknown)\n  formats?: {[Name in string]?: Format}\n  keywords?: Vocabulary\n  schemas?: AnySchema[] | {[Key in string]?: AnySchema}\n  logger?: Logger | false\n  loadSchema?: (uri: string) => Promise<AnySchemaObject>\n  // options to modify validated data:\n  removeAdditional?: boolean | \"all\" | \"failing\"\n  useDefaults?: boolean | \"empty\"\n  coerceTypes?: boolean | \"array\"\n  // advanced options:\n  next?: boolean // NEW\n  unevaluated?: boolean // NEW\n  dynamicRef?: boolean // NEW\n  schemaId?: \"id\" | \"$id\"\n  jtd?: boolean // NEW\n  meta?: SchemaObject | boolean\n  defaultMeta?: string | AnySchemaObject\n  validateSchema?: boolean | \"log\"\n  addUsedSchema?: boolean\n  inlineRefs?: boolean | number\n  passContext?: boolean\n  loopRequired?: number\n  loopEnum?: number // NEW\n  ownProperties?: boolean\n  multipleOfPrecision?: number\n  int32range?: boolean // JTD only\n  messages?: boolean\n  code?: CodeOptions // NEW\n  uriResolver?: UriResolver\n}\n\nexport interface CodeOptions {\n  es5?: boolean\n  esm?: boolean\n  lines?: boolean\n  optimize?: boolean | number\n  formats?: Code // code to require (or construct) map of available formats - for standalone code\n  source?: boolean\n  process?: (code: string, schema?: SchemaEnv) => string\n  regExp?: RegExpEngine\n}\n\ninterface InstanceCodeOptions extends CodeOptions {\n  regExp: RegExpEngine\n  optimize: number\n}\n\ninterface DeprecatedOptions {\n  /** @deprecated */\n  ignoreKeywordsWithRef?: boolean\n  /** @deprecated */\n  jsPropertySyntax?: boolean // added instead of jsonPointers\n  /** @deprecated */\n  unicode?: boolean\n}\n\ninterface RemovedOptions {\n  format?: boolean\n  errorDataPath?: \"object\" | \"property\"\n  nullable?: boolean // \"nullable\" keyword is supported by default\n  jsonPointers?: boolean\n  extendRefs?: true | \"ignore\" | \"fail\"\n  missingRefs?: true | \"ignore\" | \"fail\"\n  processCode?: (code: string, schema?: SchemaEnv) => string\n  sourceCode?: boolean\n  strictDefaults?: boolean\n  strictKeywords?: boolean\n  uniqueItems?: boolean\n  unknownFormats?: true | string[] | \"ignore\"\n  cache?: any\n  serialize?: (schema: AnySchema) => unknown\n  ajvErrors?: boolean\n}\n\ntype OptionsInfo<T extends RemovedOptions | DeprecatedOptions> = {\n  [K in keyof T]-?: string | undefined\n}\n\nconst removedOptions: OptionsInfo<RemovedOptions> = {\n  errorDataPath: \"\",\n  format: \"`validateFormats: false` can be used instead.\",\n  nullable: '\"nullable\" keyword is supported by default.',\n  jsonPointers: \"Deprecated jsPropertySyntax can be used instead.\",\n  extendRefs: \"Deprecated ignoreKeywordsWithRef can be used instead.\",\n  missingRefs: \"Pass empty schema with $id that should be ignored to ajv.addSchema.\",\n  processCode: \"Use option `code: {process: (code, schemaEnv: object) => string}`\",\n  sourceCode: \"Use option `code: {source: true}`\",\n  strictDefaults: \"It is default now, see option `strict`.\",\n  strictKeywords: \"It is default now, see option `strict`.\",\n  uniqueItems: '\"uniqueItems\" keyword is always validated.',\n  unknownFormats: \"Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).\",\n  cache: \"Map is used as cache, schema object as key.\",\n  serialize: \"Map is used as cache, schema object as key.\",\n  ajvErrors: \"It is default now.\",\n}\n\nconst deprecatedOptions: OptionsInfo<DeprecatedOptions> = {\n  ignoreKeywordsWithRef: \"\",\n  jsPropertySyntax: \"\",\n  unicode: '\"minLength\"/\"maxLength\" account for unicode characters by default.',\n}\n\ntype RequiredInstanceOptions = {\n  [K in\n    | \"strictSchema\"\n    | \"strictNumbers\"\n    | \"strictTypes\"\n    | \"strictTuples\"\n    | \"strictRequired\"\n    | \"inlineRefs\"\n    | \"loopRequired\"\n    | \"loopEnum\"\n    | \"meta\"\n    | \"messages\"\n    | \"schemaId\"\n    | \"addUsedSchema\"\n    | \"validateSchema\"\n    | \"validateFormats\"\n    | \"int32range\"\n    | \"unicodeRegExp\"\n    | \"uriResolver\"]: NonNullable<Options[K]>\n} & {code: InstanceCodeOptions}\n\nexport type InstanceOptions = Options & RequiredInstanceOptions\n\nconst MAX_EXPRESSION = 200\n\n// eslint-disable-next-line complexity\nfunction requiredOptions(o: Options): RequiredInstanceOptions {\n  const s = o.strict\n  const _optz = o.code?.optimize\n  const optimize = _optz === true || _optz === undefined ? 1 : _optz || 0\n  const regExp = o.code?.regExp ?? defaultRegExp\n  const uriResolver = o.uriResolver ?? DefaultUriResolver\n  return {\n    strictSchema: o.strictSchema ?? s ?? true,\n    strictNumbers: o.strictNumbers ?? s ?? true,\n    strictTypes: o.strictTypes ?? s ?? \"log\",\n    strictTuples: o.strictTuples ?? s ?? \"log\",\n    strictRequired: o.strictRequired ?? s ?? false,\n    code: o.code ? {...o.code, optimize, regExp} : {optimize, regExp},\n    loopRequired: o.loopRequired ?? MAX_EXPRESSION,\n    loopEnum: o.loopEnum ?? MAX_EXPRESSION,\n    meta: o.meta ?? true,\n    messages: o.messages ?? true,\n    inlineRefs: o.inlineRefs ?? true,\n    schemaId: o.schemaId ?? \"$id\",\n    addUsedSchema: o.addUsedSchema ?? true,\n    validateSchema: o.validateSchema ?? true,\n    validateFormats: o.validateFormats ?? true,\n    unicodeRegExp: o.unicodeRegExp ?? true,\n    int32range: o.int32range ?? true,\n    uriResolver: uriResolver,\n  }\n}\n\nexport interface Logger {\n  log(...args: unknown[]): unknown\n  warn(...args: unknown[]): unknown\n  error(...args: unknown[]): unknown\n}\n\nexport default class Ajv {\n  opts: InstanceOptions\n  errors?: ErrorObject[] | null // errors from the last validation\n  logger: Logger\n  // shared external scope values for compiled functions\n  readonly scope: ValueScope\n  readonly schemas: {[Key in string]?: SchemaEnv} = {}\n  readonly refs: {[Ref in string]?: SchemaEnv | string} = {}\n  readonly formats: {[Name in string]?: AddedFormat} = {}\n  readonly RULES: ValidationRules\n  readonly _compilations: Set<SchemaEnv> = new Set()\n  private readonly _loading: {[Ref in string]?: Promise<AnySchemaObject>} = {}\n  private readonly _cache: Map<AnySchema, SchemaEnv> = new Map()\n  private readonly _metaOpts: InstanceOptions\n\n  static ValidationError = ValidationError\n  static MissingRefError = MissingRefError\n\n  constructor(opts: Options = {}) {\n    opts = this.opts = {...opts, ...requiredOptions(opts)}\n    const {es5, lines} = this.opts.code\n\n    this.scope = new ValueScope({scope: {}, prefixes: EXT_SCOPE_NAMES, es5, lines})\n    this.logger = getLogger(opts.logger)\n    const formatOpt = opts.validateFormats\n    opts.validateFormats = false\n\n    this.RULES = getRules()\n    checkOptions.call(this, removedOptions, opts, \"NOT SUPPORTED\")\n    checkOptions.call(this, deprecatedOptions, opts, \"DEPRECATED\", \"warn\")\n    this._metaOpts = getMetaSchemaOptions.call(this)\n\n    if (opts.formats) addInitialFormats.call(this)\n    this._addVocabularies()\n    this._addDefaultMetaSchema()\n    if (opts.keywords) addInitialKeywords.call(this, opts.keywords)\n    if (typeof opts.meta == \"object\") this.addMetaSchema(opts.meta)\n    addInitialSchemas.call(this)\n    opts.validateFormats = formatOpt\n  }\n\n  _addVocabularies(): void {\n    this.addKeyword(\"$async\")\n  }\n\n  _addDefaultMetaSchema(): void {\n    const {$data, meta, schemaId} = this.opts\n    let _dataRefSchema: SchemaObject = $dataRefSchema\n    if (schemaId === \"id\") {\n      _dataRefSchema = {...$dataRefSchema}\n      _dataRefSchema.id = _dataRefSchema.$id\n      delete _dataRefSchema.$id\n    }\n    if (meta && $data) this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false)\n  }\n\n  defaultMeta(): string | AnySchemaObject | undefined {\n    const {meta, schemaId} = this.opts\n    return (this.opts.defaultMeta = typeof meta == \"object\" ? meta[schemaId] || meta : undefined)\n  }\n\n  // Validate data using schema\n  // AnySchema will be compiled and cached using schema itself as a key for Map\n  validate(schema: Schema | string, data: unknown): boolean\n  validate(schemaKeyRef: AnySchema | string, data: unknown): boolean | Promise<unknown>\n  validate<T>(schema: Schema | JSONSchemaType<T> | string, data: unknown): data is T\n  // Separated for type inference to work\n  // eslint-disable-next-line @typescript-eslint/unified-signatures\n  validate<T>(schema: JTDSchemaType<T>, data: unknown): data is T\n  // This overload is only intended for typescript inference, the first\n  // argument prevents manual type annotation from matching this overload\n  validate<N extends never, T extends SomeJTDSchemaType>(\n    schema: T,\n    data: unknown\n  ): data is JTDDataType<T>\n  validate<T>(schema: AsyncSchema, data: unknown | T): Promise<T>\n  validate<T>(schemaKeyRef: AnySchema | string, data: unknown): data is T | Promise<T>\n  validate<T>(\n    schemaKeyRef: AnySchema | string, // key, ref or schema object\n    data: unknown | T // to be validated\n  ): boolean | Promise<T> {\n    let v: AnyValidateFunction | undefined\n    if (typeof schemaKeyRef == \"string\") {\n      v = this.getSchema<T>(schemaKeyRef)\n      if (!v) throw new Error(`no schema with key or ref \"${schemaKeyRef}\"`)\n    } else {\n      v = this.compile<T>(schemaKeyRef)\n    }\n\n    const valid = v(data)\n    if (!(\"$async\" in v)) this.errors = v.errors\n    return valid\n  }\n\n  // Create validation function for passed schema\n  // _meta: true if schema is a meta-schema. Used internally to compile meta schemas of user-defined keywords.\n  compile<T = unknown>(schema: Schema | JSONSchemaType<T>, _meta?: boolean): ValidateFunction<T>\n  // Separated for type inference to work\n  // eslint-disable-next-line @typescript-eslint/unified-signatures\n  compile<T = unknown>(schema: JTDSchemaType<T>, _meta?: boolean): ValidateFunction<T>\n  // This overload is only intended for typescript inference, the first\n  // argument prevents manual type annotation from matching this overload\n  compile<N extends never, T extends SomeJTDSchemaType>(\n    schema: T,\n    _meta?: boolean\n  ): ValidateFunction<JTDDataType<T>>\n  compile<T = unknown>(schema: AsyncSchema, _meta?: boolean): AsyncValidateFunction<T>\n  compile<T = unknown>(schema: AnySchema, _meta?: boolean): AnyValidateFunction<T>\n  compile<T = unknown>(schema: AnySchema, _meta?: boolean): AnyValidateFunction<T> {\n    const sch = this._addSchema(schema, _meta)\n    return (sch.validate || this._compileSchemaEnv(sch)) as AnyValidateFunction<T>\n  }\n\n  // Creates validating function for passed schema with asynchronous loading of missing schemas.\n  // `loadSchema` option should be a function that accepts schema uri and returns promise that resolves with the schema.\n  // TODO allow passing schema URI\n  // meta - optional true to compile meta-schema\n  compileAsync<T = unknown>(\n    schema: SchemaObject | JSONSchemaType<T>,\n    _meta?: boolean\n  ): Promise<ValidateFunction<T>>\n  // Separated for type inference to work\n  // eslint-disable-next-line @typescript-eslint/unified-signatures\n  compileAsync<T = unknown>(schema: JTDSchemaType<T>, _meta?: boolean): Promise<ValidateFunction<T>>\n  compileAsync<T = unknown>(schema: AsyncSchema, meta?: boolean): Promise<AsyncValidateFunction<T>>\n  // eslint-disable-next-line @typescript-eslint/unified-signatures\n  compileAsync<T = unknown>(\n    schema: AnySchemaObject,\n    meta?: boolean\n  ): Promise<AnyValidateFunction<T>>\n  compileAsync<T = unknown>(\n    schema: AnySchemaObject,\n    meta?: boolean\n  ): Promise<AnyValidateFunction<T>> {\n    if (typeof this.opts.loadSchema != \"function\") {\n      throw new Error(\"options.loadSchema should be a function\")\n    }\n    const {loadSchema} = this.opts\n    return runCompileAsync.call(this, schema, meta)\n\n    async function runCompileAsync(\n      this: Ajv,\n      _schema: AnySchemaObject,\n      _meta?: boolean\n    ): Promise<AnyValidateFunction> {\n      await loadMetaSchema.call(this, _schema.$schema)\n      const sch = this._addSchema(_schema, _meta)\n      return sch.validate || _compileAsync.call(this, sch)\n    }\n\n    async function loadMetaSchema(this: Ajv, $ref?: string): Promise<void> {\n      if ($ref && !this.getSchema($ref)) {\n        await runCompileAsync.call(this, {$ref}, true)\n      }\n    }\n\n    async function _compileAsync(this: Ajv, sch: SchemaEnv): Promise<AnyValidateFunction> {\n      try {\n        return this._compileSchemaEnv(sch)\n      } catch (e) {\n        if (!(e instanceof MissingRefError)) throw e\n        checkLoaded.call(this, e)\n        await loadMissingSchema.call(this, e.missingSchema)\n        return _compileAsync.call(this, sch)\n      }\n    }\n\n    function checkLoaded(this: Ajv, {missingSchema: ref, missingRef}: MissingRefError): void {\n      if (this.refs[ref]) {\n        throw new Error(`AnySchema ${ref} is loaded but ${missingRef} cannot be resolved`)\n      }\n    }\n\n    async function loadMissingSchema(this: Ajv, ref: string): Promise<void> {\n      const _schema = await _loadSchema.call(this, ref)\n      if (!this.refs[ref]) await loadMetaSchema.call(this, _schema.$schema)\n      if (!this.refs[ref]) this.addSchema(_schema, ref, meta)\n    }\n\n    async function _loadSchema(this: Ajv, ref: string): Promise<AnySchemaObject> {\n      const p = this._loading[ref]\n      if (p) return p\n      try {\n        return await (this._loading[ref] = loadSchema(ref))\n      } finally {\n        delete this._loading[ref]\n      }\n    }\n  }\n\n  // Adds schema to the instance\n  addSchema(\n    schema: AnySchema | AnySchema[], // If array is passed, `key` will be ignored\n    key?: string, // Optional schema key. Can be passed to `validate` method instead of schema object or id/ref. One schema per instance can have empty `id` and `key`.\n    _meta?: boolean, // true if schema is a meta-schema. Used internally, addMetaSchema should be used instead.\n    _validateSchema = this.opts.validateSchema // false to skip schema validation. Used internally, option validateSchema should be used instead.\n  ): Ajv {\n    if (Array.isArray(schema)) {\n      for (const sch of schema) this.addSchema(sch, undefined, _meta, _validateSchema)\n      return this\n    }\n    let id: string | undefined\n    if (typeof schema === \"object\") {\n      const {schemaId} = this.opts\n      id = schema[schemaId]\n      if (id !== undefined && typeof id != \"string\") {\n        throw new Error(`schema ${schemaId} must be string`)\n      }\n    }\n    key = normalizeId(key || id)\n    this._checkUnique(key)\n    this.schemas[key] = this._addSchema(schema, _meta, key, _validateSchema, true)\n    return this\n  }\n\n  // Add schema that will be used to validate other schemas\n  // options in META_IGNORE_OPTIONS are alway set to false\n  addMetaSchema(\n    schema: AnySchemaObject,\n    key?: string, // schema key\n    _validateSchema = this.opts.validateSchema // false to skip schema validation, can be used to override validateSchema option for meta-schema\n  ): Ajv {\n    this.addSchema(schema, key, true, _validateSchema)\n    return this\n  }\n\n  //  Validate schema against its meta-schema\n  validateSchema(schema: AnySchema, throwOrLogError?: boolean): boolean | Promise<unknown> {\n    if (typeof schema == \"boolean\") return true\n    let $schema: string | AnySchemaObject | undefined\n    $schema = schema.$schema\n    if ($schema !== undefined && typeof $schema != \"string\") {\n      throw new Error(\"$schema must be a string\")\n    }\n    $schema = $schema || this.opts.defaultMeta || this.defaultMeta()\n    if (!$schema) {\n      this.logger.warn(\"meta-schema not available\")\n      this.errors = null\n      return true\n    }\n    const valid = this.validate($schema, schema)\n    if (!valid && throwOrLogError) {\n      const message = \"schema is invalid: \" + this.errorsText()\n      if (this.opts.validateSchema === \"log\") this.logger.error(message)\n      else throw new Error(message)\n    }\n    return valid\n  }\n\n  // Get compiled schema by `key` or `ref`.\n  // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)\n  getSchema<T = unknown>(keyRef: string): AnyValidateFunction<T> | undefined {\n    let sch\n    while (typeof (sch = getSchEnv.call(this, keyRef)) == \"string\") keyRef = sch\n    if (sch === undefined) {\n      const {schemaId} = this.opts\n      const root = new SchemaEnv({schema: {}, schemaId})\n      sch = resolveSchema.call(this, root, keyRef)\n      if (!sch) return\n      this.refs[keyRef] = sch\n    }\n    return (sch.validate || this._compileSchemaEnv(sch)) as AnyValidateFunction<T> | undefined\n  }\n\n  // Remove cached schema(s).\n  // If no parameter is passed all schemas but meta-schemas are removed.\n  // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.\n  // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.\n  removeSchema(schemaKeyRef?: AnySchema | string | RegExp): Ajv {\n    if (schemaKeyRef instanceof RegExp) {\n      this._removeAllSchemas(this.schemas, schemaKeyRef)\n      this._removeAllSchemas(this.refs, schemaKeyRef)\n      return this\n    }\n    switch (typeof schemaKeyRef) {\n      case \"undefined\":\n        this._removeAllSchemas(this.schemas)\n        this._removeAllSchemas(this.refs)\n        this._cache.clear()\n        return this\n      case \"string\": {\n        const sch = getSchEnv.call(this, schemaKeyRef)\n        if (typeof sch == \"object\") this._cache.delete(sch.schema)\n        delete this.schemas[schemaKeyRef]\n        delete this.refs[schemaKeyRef]\n        return this\n      }\n      case \"object\": {\n        const cacheKey = schemaKeyRef\n        this._cache.delete(cacheKey)\n        let id = schemaKeyRef[this.opts.schemaId]\n        if (id) {\n          id = normalizeId(id)\n          delete this.schemas[id]\n          delete this.refs[id]\n        }\n        return this\n      }\n      default:\n        throw new Error(\"ajv.removeSchema: invalid parameter\")\n    }\n  }\n\n  // add \"vocabulary\" - a collection of keywords\n  addVocabulary(definitions: Vocabulary): Ajv {\n    for (const def of definitions) this.addKeyword(def)\n    return this\n  }\n\n  addKeyword(\n    kwdOrDef: string | KeywordDefinition,\n    def?: KeywordDefinition // deprecated\n  ): Ajv {\n    let keyword: string | string[]\n    if (typeof kwdOrDef == \"string\") {\n      keyword = kwdOrDef\n      if (typeof def == \"object\") {\n        this.logger.warn(\"these parameters are deprecated, see docs for addKeyword\")\n        def.keyword = keyword\n      }\n    } else if (typeof kwdOrDef == \"object\" && def === undefined) {\n      def = kwdOrDef\n      keyword = def.keyword\n      if (Array.isArray(keyword) && !keyword.length) {\n        throw new Error(\"addKeywords: keyword must be string or non-empty array\")\n      }\n    } else {\n      throw new Error(\"invalid addKeywords parameters\")\n    }\n\n    checkKeyword.call(this, keyword, def)\n    if (!def) {\n      eachItem(keyword, (kwd) => addRule.call(this, kwd))\n      return this\n    }\n    keywordMetaschema.call(this, def)\n    const definition: AddedKeywordDefinition = {\n      ...def,\n      type: getJSONTypes(def.type),\n      schemaType: getJSONTypes(def.schemaType),\n    }\n    eachItem(\n      keyword,\n      definition.type.length === 0\n        ? (k) => addRule.call(this, k, definition)\n        : (k) => definition.type.forEach((t) => addRule.call(this, k, definition, t))\n    )\n    return this\n  }\n\n  getKeyword(keyword: string): AddedKeywordDefinition | boolean {\n    const rule = this.RULES.all[keyword]\n    return typeof rule == \"object\" ? rule.definition : !!rule\n  }\n\n  // Remove keyword\n  removeKeyword(keyword: string): Ajv {\n    // TODO return type should be Ajv\n    const {RULES} = this\n    delete RULES.keywords[keyword]\n    delete RULES.all[keyword]\n    for (const group of RULES.rules) {\n      const i = group.rules.findIndex((rule) => rule.keyword === keyword)\n      if (i >= 0) group.rules.splice(i, 1)\n    }\n    return this\n  }\n\n  // Add format\n  addFormat(name: string, format: Format): Ajv {\n    if (typeof format == \"string\") format = new RegExp(format)\n    this.formats[name] = format\n    return this\n  }\n\n  errorsText(\n    errors: ErrorObject[] | null | undefined = this.errors, // optional array of validation errors\n    {separator = \", \", dataVar = \"data\"}: ErrorsTextOptions = {} // optional options with properties `separator` and `dataVar`\n  ): string {\n    if (!errors || errors.length === 0) return \"No errors\"\n    return errors\n      .map((e) => `${dataVar}${e.instancePath} ${e.message}`)\n      .reduce((text, msg) => text + separator + msg)\n  }\n\n  $dataMetaSchema(metaSchema: AnySchemaObject, keywordsJsonPointers: string[]): AnySchemaObject {\n    const rules = this.RULES.all\n    metaSchema = JSON.parse(JSON.stringify(metaSchema))\n    for (const jsonPointer of keywordsJsonPointers) {\n      const segments = jsonPointer.split(\"/\").slice(1) // first segment is an empty string\n      let keywords = metaSchema\n      for (const seg of segments) keywords = keywords[seg] as AnySchemaObject\n\n      for (const key in rules) {\n        const rule = rules[key]\n        if (typeof rule != \"object\") continue\n        const {$data} = rule.definition\n        const schema = keywords[key] as AnySchemaObject | undefined\n        if ($data && schema) keywords[key] = schemaOrData(schema)\n      }\n    }\n\n    return metaSchema\n  }\n\n  private _removeAllSchemas(schemas: {[Ref in string]?: SchemaEnv | string}, regex?: RegExp): void {\n    for (const keyRef in schemas) {\n      const sch = schemas[keyRef]\n      if (!regex || regex.test(keyRef)) {\n        if (typeof sch == \"string\") {\n          delete schemas[keyRef]\n        } else if (sch && !sch.meta) {\n          this._cache.delete(sch.schema)\n          delete schemas[keyRef]\n        }\n      }\n    }\n  }\n\n  _addSchema(\n    schema: AnySchema,\n    meta?: boolean,\n    baseId?: string,\n    validateSchema = this.opts.validateSchema,\n    addSchema = this.opts.addUsedSchema\n  ): SchemaEnv {\n    let id: string | undefined\n    const {schemaId} = this.opts\n    if (typeof schema == \"object\") {\n      id = schema[schemaId]\n    } else {\n      if (this.opts.jtd) throw new Error(\"schema must be object\")\n      else if (typeof schema != \"boolean\") throw new Error(\"schema must be object or boolean\")\n    }\n    let sch = this._cache.get(schema)\n    if (sch !== undefined) return sch\n\n    baseId = normalizeId(id || baseId)\n    const localRefs = getSchemaRefs.call(this, schema, baseId)\n    sch = new SchemaEnv({schema, schemaId, meta, baseId, localRefs})\n    this._cache.set(sch.schema, sch)\n    if (addSchema && !baseId.startsWith(\"#\")) {\n      // TODO atm it is allowed to overwrite schemas without id (instead of not adding them)\n      if (baseId) this._checkUnique(baseId)\n      this.refs[baseId] = sch\n    }\n    if (validateSchema) this.validateSchema(schema, true)\n    return sch\n  }\n\n  private _checkUnique(id: string): void {\n    if (this.schemas[id] || this.refs[id]) {\n      throw new Error(`schema with key or id \"${id}\" already exists`)\n    }\n  }\n\n  private _compileSchemaEnv(sch: SchemaEnv): AnyValidateFunction {\n    if (sch.meta) this._compileMetaSchema(sch)\n    else compileSchema.call(this, sch)\n\n    /* istanbul ignore if */\n    if (!sch.validate) throw new Error(\"ajv implementation error\")\n    return sch.validate\n  }\n\n  private _compileMetaSchema(sch: SchemaEnv): void {\n    const currentOpts = this.opts\n    this.opts = this._metaOpts\n    try {\n      compileSchema.call(this, sch)\n    } finally {\n      this.opts = currentOpts\n    }\n  }\n}\n\nexport interface ErrorsTextOptions {\n  separator?: string\n  dataVar?: string\n}\n\nfunction checkOptions(\n  this: Ajv,\n  checkOpts: OptionsInfo<RemovedOptions | DeprecatedOptions>,\n  options: Options & RemovedOptions,\n  msg: string,\n  log: \"warn\" | \"error\" = \"error\"\n): void {\n  for (const key in checkOpts) {\n    const opt = key as keyof typeof checkOpts\n    if (opt in options) this.logger[log](`${msg}: option ${key}. ${checkOpts[opt]}`)\n  }\n}\n\nfunction getSchEnv(this: Ajv, keyRef: string): SchemaEnv | string | undefined {\n  keyRef = normalizeId(keyRef) // TODO tests fail without this line\n  return this.schemas[keyRef] || this.refs[keyRef]\n}\n\nfunction addInitialSchemas(this: Ajv): void {\n  const optsSchemas = this.opts.schemas\n  if (!optsSchemas) return\n  if (Array.isArray(optsSchemas)) this.addSchema(optsSchemas)\n  else for (const key in optsSchemas) this.addSchema(optsSchemas[key] as AnySchema, key)\n}\n\nfunction addInitialFormats(this: Ajv): void {\n  for (const name in this.opts.formats) {\n    const format = this.opts.formats[name]\n    if (format) this.addFormat(name, format)\n  }\n}\n\nfunction addInitialKeywords(\n  this: Ajv,\n  defs: Vocabulary | {[K in string]?: KeywordDefinition}\n): void {\n  if (Array.isArray(defs)) {\n    this.addVocabulary(defs)\n    return\n  }\n  this.logger.warn(\"keywords option as map is deprecated, pass array\")\n  for (const keyword in defs) {\n    const def = defs[keyword] as KeywordDefinition\n    if (!def.keyword) def.keyword = keyword\n    this.addKeyword(def)\n  }\n}\n\nfunction getMetaSchemaOptions(this: Ajv): InstanceOptions {\n  const metaOpts = {...this.opts}\n  for (const opt of META_IGNORE_OPTIONS) delete metaOpts[opt]\n  return metaOpts\n}\n\nconst noLogs = {log() {}, warn() {}, error() {}}\n\nfunction getLogger(logger?: Partial<Logger> | false): Logger {\n  if (logger === false) return noLogs\n  if (logger === undefined) return console\n  if (logger.log && logger.warn && logger.error) return logger as Logger\n  throw new Error(\"logger must implement log, warn and error methods\")\n}\n\nconst KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i\n\nfunction checkKeyword(this: Ajv, keyword: string | string[], def?: KeywordDefinition): void {\n  const {RULES} = this\n  eachItem(keyword, (kwd) => {\n    if (RULES.keywords[kwd]) throw new Error(`Keyword ${kwd} is already defined`)\n    if (!KEYWORD_NAME.test(kwd)) throw new Error(`Keyword ${kwd} has invalid name`)\n  })\n  if (!def) return\n  if (def.$data && !(\"code\" in def || \"validate\" in def)) {\n    throw new Error('$data keyword must have \"code\" or \"validate\" function')\n  }\n}\n\nfunction addRule(\n  this: Ajv,\n  keyword: string,\n  definition?: AddedKeywordDefinition,\n  dataType?: JSONType\n): void {\n  const post = definition?.post\n  if (dataType && post) throw new Error('keyword with \"post\" flag cannot have \"type\"')\n  const {RULES} = this\n  let ruleGroup = post ? RULES.post : RULES.rules.find(({type: t}) => t === dataType)\n  if (!ruleGroup) {\n    ruleGroup = {type: dataType, rules: []}\n    RULES.rules.push(ruleGroup)\n  }\n  RULES.keywords[keyword] = true\n  if (!definition) return\n\n  const rule: Rule = {\n    keyword,\n    definition: {\n      ...definition,\n      type: getJSONTypes(definition.type),\n      schemaType: getJSONTypes(definition.schemaType),\n    },\n  }\n  if (definition.before) addBeforeRule.call(this, ruleGroup, rule, definition.before)\n  else ruleGroup.rules.push(rule)\n  RULES.all[keyword] = rule\n  definition.implements?.forEach((kwd) => this.addKeyword(kwd))\n}\n\nfunction addBeforeRule(this: Ajv, ruleGroup: RuleGroup, rule: Rule, before: string): void {\n  const i = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before)\n  if (i >= 0) {\n    ruleGroup.rules.splice(i, 0, rule)\n  } else {\n    ruleGroup.rules.push(rule)\n    this.logger.warn(`rule ${before} is not defined`)\n  }\n}\n\nfunction keywordMetaschema(this: Ajv, def: KeywordDefinition): void {\n  let {metaSchema} = def\n  if (metaSchema === undefined) return\n  if (def.$data && this.opts.$data) metaSchema = schemaOrData(metaSchema)\n  def.validateSchema = this.compile(metaSchema, true)\n}\n\nconst $dataRef = {\n  $ref: \"https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#\",\n}\n\nfunction schemaOrData(schema: AnySchema): AnySchemaObject {\n  return {anyOf: [schema, $dataRef]}\n}\n","// https://github.com/ajv-validator/ajv/issues/889\nimport * as equal from \"fast-deep-equal\"\n\ntype Equal = typeof equal & {code: string}\n;(equal as Equal).code = 'require(\"ajv/dist/runtime/equal\").default'\n\nexport default equal as Equal\n","// https://mathiasbynens.be/notes/javascript-encoding\n// https://github.com/bestiejs/punycode.js - punycode.ucs2.decode\nexport default function ucs2length(str: string): number {\n  const len = str.length\n  let length = 0\n  let pos = 0\n  let value: number\n  while (pos < len) {\n    length++\n    value = str.charCodeAt(pos++)\n    if (value >= 0xd800 && value <= 0xdbff && pos < len) {\n      // high surrogate, and there is a next character\n      value = str.charCodeAt(pos)\n      if ((value & 0xfc00) === 0xdc00) pos++ // low surrogate\n    }\n  }\n  return length\n}\n\nucs2length.code = 'require(\"ajv/dist/runtime/ucs2length\").default'\n","import * as uri from \"uri-js\"\n\ntype URI = typeof uri & {code: string}\n;(uri as URI).code = 'require(\"ajv/dist/runtime/uri\").default'\n\nexport default uri as URI\n","import type {ErrorObject} from \"../types\"\n\nexport default class ValidationError extends Error {\n  readonly errors: Partial<ErrorObject>[]\n  readonly ajv: true\n  readonly validation: true\n\n  constructor(errors: Partial<ErrorObject>[]) {\n    super(\"validation failed\")\n    this.errors = errors\n    this.ajv = this.validation = true\n  }\n}\n","import type {\n  CodeKeywordDefinition,\n  ErrorObject,\n  KeywordErrorDefinition,\n  AnySchema,\n} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, not, Name} from \"../../compile/codegen\"\nimport {alwaysValidSchema, checkStrictMode, Type} from \"../../compile/util\"\n\nexport type AdditionalItemsError = ErrorObject<\"additionalItems\", {limit: number}, AnySchema>\n\nconst error: KeywordErrorDefinition = {\n  message: ({params: {len}}) => str`must NOT have more than ${len} items`,\n  params: ({params: {len}}) => _`{limit: ${len}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"additionalItems\" as const,\n  type: \"array\",\n  schemaType: [\"boolean\", \"object\"],\n  before: \"uniqueItems\",\n  error,\n  code(cxt: KeywordCxt) {\n    const {parentSchema, it} = cxt\n    const {items} = parentSchema\n    if (!Array.isArray(items)) {\n      checkStrictMode(it, '\"additionalItems\" is ignored when \"items\" is not an array of schemas')\n      return\n    }\n    validateAdditionalItems(cxt, items)\n  },\n}\n\nexport function validateAdditionalItems(cxt: KeywordCxt, items: AnySchema[]): void {\n  const {gen, schema, data, keyword, it} = cxt\n  it.items = true\n  const len = gen.const(\"len\", _`${data}.length`)\n  if (schema === false) {\n    cxt.setParams({len: items.length})\n    cxt.pass(_`${len} <= ${items.length}`)\n  } else if (typeof schema == \"object\" && !alwaysValidSchema(it, schema)) {\n    const valid = gen.var(\"valid\", _`${len} <= ${items.length}`) // TODO var\n    gen.if(not(valid), () => validateItems(valid))\n    cxt.ok(valid)\n  }\n\n  function validateItems(valid: Name): void {\n    gen.forRange(\"i\", items.length, len, (i) => {\n      cxt.subschema({keyword, dataProp: i, dataPropType: Type.Num}, valid)\n      if (!it.allErrors) gen.if(not(valid), () => gen.break())\n    })\n  }\n}\n\nexport default def\n","import type {\n  CodeKeywordDefinition,\n  AddedKeywordDefinition,\n  ErrorObject,\n  KeywordErrorDefinition,\n  AnySchema,\n} from \"../../types\"\nimport {allSchemaProperties, usePattern, isOwnProperty} from \"../code\"\nimport {_, nil, or, not, Code, Name} from \"../../compile/codegen\"\nimport N from \"../../compile/names\"\nimport type {SubschemaArgs} from \"../../compile/validate/subschema\"\nimport {alwaysValidSchema, schemaRefOrVal, Type} from \"../../compile/util\"\n\nexport type AdditionalPropertiesError = ErrorObject<\n  \"additionalProperties\",\n  {additionalProperty: string},\n  AnySchema\n>\n\nconst error: KeywordErrorDefinition = {\n  message: \"must NOT have additional properties\",\n  params: ({params}) => _`{additionalProperty: ${params.additionalProperty}}`,\n}\n\nconst def: CodeKeywordDefinition & AddedKeywordDefinition = {\n  keyword: \"additionalProperties\",\n  type: [\"object\"],\n  schemaType: [\"boolean\", \"object\"],\n  allowUndefined: true,\n  trackErrors: true,\n  error,\n  code(cxt) {\n    const {gen, schema, parentSchema, data, errsCount, it} = cxt\n    /* istanbul ignore if */\n    if (!errsCount) throw new Error(\"ajv implementation error\")\n    const {allErrors, opts} = it\n    it.props = true\n    if (opts.removeAdditional !== \"all\" && alwaysValidSchema(it, schema)) return\n    const props = allSchemaProperties(parentSchema.properties)\n    const patProps = allSchemaProperties(parentSchema.patternProperties)\n    checkAdditionalProperties()\n    cxt.ok(_`${errsCount} === ${N.errors}`)\n\n    function checkAdditionalProperties(): void {\n      gen.forIn(\"key\", data, (key: Name) => {\n        if (!props.length && !patProps.length) additionalPropertyCode(key)\n        else gen.if(isAdditional(key), () => additionalPropertyCode(key))\n      })\n    }\n\n    function isAdditional(key: Name): Code {\n      let definedProp: Code\n      if (props.length > 8) {\n        // TODO maybe an option instead of hard-coded 8?\n        const propsSchema = schemaRefOrVal(it, parentSchema.properties, \"properties\")\n        definedProp = isOwnProperty(gen, propsSchema as Code, key)\n      } else if (props.length) {\n        definedProp = or(...props.map((p) => _`${key} === ${p}`))\n      } else {\n        definedProp = nil\n      }\n      if (patProps.length) {\n        definedProp = or(definedProp, ...patProps.map((p) => _`${usePattern(cxt, p)}.test(${key})`))\n      }\n      return not(definedProp)\n    }\n\n    function deleteAdditional(key: Name): void {\n      gen.code(_`delete ${data}[${key}]`)\n    }\n\n    function additionalPropertyCode(key: Name): void {\n      if (opts.removeAdditional === \"all\" || (opts.removeAdditional && schema === false)) {\n        deleteAdditional(key)\n        return\n      }\n\n      if (schema === false) {\n        cxt.setParams({additionalProperty: key})\n        cxt.error()\n        if (!allErrors) gen.break()\n        return\n      }\n\n      if (typeof schema == \"object\" && !alwaysValidSchema(it, schema)) {\n        const valid = gen.name(\"valid\")\n        if (opts.removeAdditional === \"failing\") {\n          applyAdditionalSchema(key, valid, false)\n          gen.if(not(valid), () => {\n            cxt.reset()\n            deleteAdditional(key)\n          })\n        } else {\n          applyAdditionalSchema(key, valid)\n          if (!allErrors) gen.if(not(valid), () => gen.break())\n        }\n      }\n    }\n\n    function applyAdditionalSchema(key: Name, valid: Name, errors?: false): void {\n      const subschema: SubschemaArgs = {\n        keyword: \"additionalProperties\",\n        dataProp: key,\n        dataPropType: Type.Str,\n      }\n      if (errors === false) {\n        Object.assign(subschema, {\n          compositeRule: true,\n          createErrors: false,\n          allErrors: false,\n        })\n      }\n      cxt.subschema(subschema, valid)\n    }\n  },\n}\n\nexport default def\n","import type {CodeKeywordDefinition, AnySchema} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {alwaysValidSchema} from \"../../compile/util\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"allOf\",\n  schemaType: \"array\",\n  code(cxt: KeywordCxt) {\n    const {gen, schema, it} = cxt\n    /* istanbul ignore if */\n    if (!Array.isArray(schema)) throw new Error(\"ajv implementation error\")\n    const valid = gen.name(\"valid\")\n    schema.forEach((sch: AnySchema, i: number) => {\n      if (alwaysValidSchema(it, sch)) return\n      const schCxt = cxt.subschema({keyword: \"allOf\", schemaProp: i}, valid)\n      cxt.ok(valid)\n      cxt.mergeEvaluated(schCxt)\n    })\n  },\n}\n\nexport default def\n","import type {CodeKeywordDefinition, ErrorNoParams, AnySchema} from \"../../types\"\nimport {validateUnion} from \"../code\"\n\nexport type AnyOfError = ErrorNoParams<\"anyOf\", AnySchema[]>\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"anyOf\",\n  schemaType: \"array\",\n  trackErrors: true,\n  code: validateUnion,\n  error: {message: \"must match a schema in anyOf\"},\n}\n\nexport default def\n","import type {\n  CodeKeywordDefinition,\n  KeywordErrorDefinition,\n  ErrorObject,\n  AnySchema,\n} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, Name} from \"../../compile/codegen\"\nimport {alwaysValidSchema, checkStrictMode, Type} from \"../../compile/util\"\n\nexport type ContainsError = ErrorObject<\n  \"contains\",\n  {minContains: number; maxContains?: number},\n  AnySchema\n>\n\nconst error: KeywordErrorDefinition = {\n  message: ({params: {min, max}}) =>\n    max === undefined\n      ? str`must contain at least ${min} valid item(s)`\n      : str`must contain at least ${min} and no more than ${max} valid item(s)`,\n  params: ({params: {min, max}}) =>\n    max === undefined ? _`{minContains: ${min}}` : _`{minContains: ${min}, maxContains: ${max}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"contains\",\n  type: \"array\",\n  schemaType: [\"object\", \"boolean\"],\n  before: \"uniqueItems\",\n  trackErrors: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, schema, parentSchema, data, it} = cxt\n    let min: number\n    let max: number | undefined\n    const {minContains, maxContains} = parentSchema\n    if (it.opts.next) {\n      min = minContains === undefined ? 1 : minContains\n      max = maxContains\n    } else {\n      min = 1\n    }\n    const len = gen.const(\"len\", _`${data}.length`)\n    cxt.setParams({min, max})\n    if (max === undefined && min === 0) {\n      checkStrictMode(it, `\"minContains\" == 0 without \"maxContains\": \"contains\" keyword ignored`)\n      return\n    }\n    if (max !== undefined && min > max) {\n      checkStrictMode(it, `\"minContains\" > \"maxContains\" is always invalid`)\n      cxt.fail()\n      return\n    }\n    if (alwaysValidSchema(it, schema)) {\n      let cond = _`${len} >= ${min}`\n      if (max !== undefined) cond = _`${cond} && ${len} <= ${max}`\n      cxt.pass(cond)\n      return\n    }\n\n    it.items = true\n    const valid = gen.name(\"valid\")\n    if (max === undefined && min === 1) {\n      validateItems(valid, () => gen.if(valid, () => gen.break()))\n    } else if (min === 0) {\n      gen.let(valid, true)\n      if (max !== undefined) gen.if(_`${data}.length > 0`, validateItemsWithCount)\n    } else {\n      gen.let(valid, false)\n      validateItemsWithCount()\n    }\n    cxt.result(valid, () => cxt.reset())\n\n    function validateItemsWithCount(): void {\n      const schValid = gen.name(\"_valid\")\n      const count = gen.let(\"count\", 0)\n      validateItems(schValid, () => gen.if(schValid, () => checkLimits(count)))\n    }\n\n    function validateItems(_valid: Name, block: () => void): void {\n      gen.forRange(\"i\", 0, len, (i) => {\n        cxt.subschema(\n          {\n            keyword: \"contains\",\n            dataProp: i,\n            dataPropType: Type.Num,\n            compositeRule: true,\n          },\n          _valid\n        )\n        block()\n      })\n    }\n\n    function checkLimits(count: Name): void {\n      gen.code(_`${count}++`)\n      if (max === undefined) {\n        gen.if(_`${count} >= ${min}`, () => gen.assign(valid, true).break())\n      } else {\n        gen.if(_`${count} > ${max}`, () => gen.assign(valid, false).break())\n        if (min === 1) gen.assign(valid, true)\n        else gen.if(_`${count} >= ${min}`, () => gen.assign(valid, true))\n      }\n    }\n  },\n}\n\nexport default def\n","import type {\n  CodeKeywordDefinition,\n  ErrorObject,\n  KeywordErrorDefinition,\n  SchemaMap,\n  AnySchema,\n} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str} from \"../../compile/codegen\"\nimport {alwaysValidSchema} from \"../../compile/util\"\nimport {checkReportMissingProp, checkMissingProp, reportMissingProp, propertyInData} from \"../code\"\n\nexport type PropertyDependencies = {[K in string]?: string[]}\n\nexport interface DependenciesErrorParams {\n  property: string\n  missingProperty: string\n  depsCount: number\n  deps: string // TODO change to string[]\n}\n\ntype SchemaDependencies = SchemaMap\n\nexport type DependenciesError = ErrorObject<\n  \"dependencies\",\n  DependenciesErrorParams,\n  {[K in string]?: string[] | AnySchema}\n>\n\nexport const error: KeywordErrorDefinition = {\n  message: ({params: {property, depsCount, deps}}) => {\n    const property_ies = depsCount === 1 ? \"property\" : \"properties\"\n    return str`must have ${property_ies} ${deps} when property ${property} is present`\n  },\n  params: ({params: {property, depsCount, deps, missingProperty}}) =>\n    _`{property: ${property},\n    missingProperty: ${missingProperty},\n    depsCount: ${depsCount},\n    deps: ${deps}}`, // TODO change to reference\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"dependencies\",\n  type: \"object\",\n  schemaType: \"object\",\n  error,\n  code(cxt: KeywordCxt) {\n    const [propDeps, schDeps] = splitDependencies(cxt)\n    validatePropertyDeps(cxt, propDeps)\n    validateSchemaDeps(cxt, schDeps)\n  },\n}\n\nfunction splitDependencies({schema}: KeywordCxt): [PropertyDependencies, SchemaDependencies] {\n  const propertyDeps: PropertyDependencies = {}\n  const schemaDeps: SchemaDependencies = {}\n  for (const key in schema) {\n    if (key === \"__proto__\") continue\n    const deps = Array.isArray(schema[key]) ? propertyDeps : schemaDeps\n    deps[key] = schema[key]\n  }\n  return [propertyDeps, schemaDeps]\n}\n\nexport function validatePropertyDeps(\n  cxt: KeywordCxt,\n  propertyDeps: {[K in string]?: string[]} = cxt.schema\n): void {\n  const {gen, data, it} = cxt\n  if (Object.keys(propertyDeps).length === 0) return\n  const missing = gen.let(\"missing\")\n  for (const prop in propertyDeps) {\n    const deps = propertyDeps[prop] as string[]\n    if (deps.length === 0) continue\n    const hasProperty = propertyInData(gen, data, prop, it.opts.ownProperties)\n    cxt.setParams({\n      property: prop,\n      depsCount: deps.length,\n      deps: deps.join(\", \"),\n    })\n    if (it.allErrors) {\n      gen.if(hasProperty, () => {\n        for (const depProp of deps) {\n          checkReportMissingProp(cxt, depProp)\n        }\n      })\n    } else {\n      gen.if(_`${hasProperty} && (${checkMissingProp(cxt, deps, missing)})`)\n      reportMissingProp(cxt, missing)\n      gen.else()\n    }\n  }\n}\n\nexport function validateSchemaDeps(cxt: KeywordCxt, schemaDeps: SchemaMap = cxt.schema): void {\n  const {gen, data, keyword, it} = cxt\n  const valid = gen.name(\"valid\")\n  for (const prop in schemaDeps) {\n    if (alwaysValidSchema(it, schemaDeps[prop] as AnySchema)) continue\n    gen.if(\n      propertyInData(gen, data, prop, it.opts.ownProperties),\n      () => {\n        const schCxt = cxt.subschema({keyword, schemaProp: prop}, valid)\n        cxt.mergeValidEvaluated(schCxt, valid)\n      },\n      () => gen.var(valid, true) // TODO var\n    )\n    cxt.ok(valid)\n  }\n}\n\nexport default def\n","import type {\n  CodeKeywordDefinition,\n  ErrorObject,\n  KeywordErrorDefinition,\n  AnySchema,\n} from \"../../types\"\nimport type {SchemaObjCxt} from \"../../compile\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, not, Name} from \"../../compile/codegen\"\nimport {alwaysValidSchema, checkStrictMode} from \"../../compile/util\"\n\nexport type IfKeywordError = ErrorObject<\"if\", {failingKeyword: string}, AnySchema>\n\nconst error: KeywordErrorDefinition = {\n  message: ({params}) => str`must match \"${params.ifClause}\" schema`,\n  params: ({params}) => _`{failingKeyword: ${params.ifClause}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"if\",\n  schemaType: [\"object\", \"boolean\"],\n  trackErrors: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, parentSchema, it} = cxt\n    if (parentSchema.then === undefined && parentSchema.else === undefined) {\n      checkStrictMode(it, '\"if\" without \"then\" and \"else\" is ignored')\n    }\n    const hasThen = hasSchema(it, \"then\")\n    const hasElse = hasSchema(it, \"else\")\n    if (!hasThen && !hasElse) return\n\n    const valid = gen.let(\"valid\", true)\n    const schValid = gen.name(\"_valid\")\n    validateIf()\n    cxt.reset()\n\n    if (hasThen && hasElse) {\n      const ifClause = gen.let(\"ifClause\")\n      cxt.setParams({ifClause})\n      gen.if(schValid, validateClause(\"then\", ifClause), validateClause(\"else\", ifClause))\n    } else if (hasThen) {\n      gen.if(schValid, validateClause(\"then\"))\n    } else {\n      gen.if(not(schValid), validateClause(\"else\"))\n    }\n\n    cxt.pass(valid, () => cxt.error(true))\n\n    function validateIf(): void {\n      const schCxt = cxt.subschema(\n        {\n          keyword: \"if\",\n          compositeRule: true,\n          createErrors: false,\n          allErrors: false,\n        },\n        schValid\n      )\n      cxt.mergeEvaluated(schCxt)\n    }\n\n    function validateClause(keyword: string, ifClause?: Name): () => void {\n      return () => {\n        const schCxt = cxt.subschema({keyword}, schValid)\n        gen.assign(valid, schValid)\n        cxt.mergeValidEvaluated(schCxt, valid)\n        if (ifClause) gen.assign(ifClause, _`${keyword}`)\n        else cxt.setParams({ifClause: keyword})\n      }\n    }\n  },\n}\n\nfunction hasSchema(it: SchemaObjCxt, keyword: string): boolean {\n  const schema = it.schema[keyword]\n  return schema !== undefined && !alwaysValidSchema(it, schema)\n}\n\nexport default def\n","import type {ErrorNoParams, Vocabulary} from \"../../types\"\nimport additionalItems, {AdditionalItemsError} from \"./additionalItems\"\nimport prefixItems from \"./prefixItems\"\nimport items from \"./items\"\nimport items2020, {ItemsError} from \"./items2020\"\nimport contains, {ContainsError} from \"./contains\"\nimport dependencies, {DependenciesError} from \"./dependencies\"\nimport propertyNames, {PropertyNamesError} from \"./propertyNames\"\nimport additionalProperties, {AdditionalPropertiesError} from \"./additionalProperties\"\nimport properties from \"./properties\"\nimport patternProperties from \"./patternProperties\"\nimport notKeyword, {NotKeywordError} from \"./not\"\nimport anyOf, {AnyOfError} from \"./anyOf\"\nimport oneOf, {OneOfError} from \"./oneOf\"\nimport allOf from \"./allOf\"\nimport ifKeyword, {IfKeywordError} from \"./if\"\nimport thenElse from \"./thenElse\"\n\nexport default function getApplicator(draft2020 = false): Vocabulary {\n  const applicator = [\n    // any\n    notKeyword,\n    anyOf,\n    oneOf,\n    allOf,\n    ifKeyword,\n    thenElse,\n    // object\n    propertyNames,\n    additionalProperties,\n    dependencies,\n    properties,\n    patternProperties,\n  ]\n  // array\n  if (draft2020) applicator.push(prefixItems, items2020)\n  else applicator.push(additionalItems, items)\n  applicator.push(contains)\n  return applicator\n}\n\nexport type ApplicatorKeywordError =\n  | ErrorNoParams<\"false schema\">\n  | AdditionalItemsError\n  | ItemsError\n  | ContainsError\n  | AdditionalPropertiesError\n  | DependenciesError\n  | IfKeywordError\n  | AnyOfError\n  | OneOfError\n  | NotKeywordError\n  | PropertyNamesError\n","import type {CodeKeywordDefinition, AnySchema, AnySchemaObject} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_} from \"../../compile/codegen\"\nimport {alwaysValidSchema, mergeEvaluated, checkStrictMode} from \"../../compile/util\"\nimport {validateArray} from \"../code\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"items\",\n  type: \"array\",\n  schemaType: [\"object\", \"array\", \"boolean\"],\n  before: \"uniqueItems\",\n  code(cxt: KeywordCxt) {\n    const {schema, it} = cxt\n    if (Array.isArray(schema)) return validateTuple(cxt, \"additionalItems\", schema)\n    it.items = true\n    if (alwaysValidSchema(it, schema)) return\n    cxt.ok(validateArray(cxt))\n  },\n}\n\nexport function validateTuple(\n  cxt: KeywordCxt,\n  extraItems: string,\n  schArr: AnySchema[] = cxt.schema\n): void {\n  const {gen, parentSchema, data, keyword, it} = cxt\n  checkStrictTuple(parentSchema)\n  if (it.opts.unevaluated && schArr.length && it.items !== true) {\n    it.items = mergeEvaluated.items(gen, schArr.length, it.items)\n  }\n  const valid = gen.name(\"valid\")\n  const len = gen.const(\"len\", _`${data}.length`)\n  schArr.forEach((sch: AnySchema, i: number) => {\n    if (alwaysValidSchema(it, sch)) return\n    gen.if(_`${len} > ${i}`, () =>\n      cxt.subschema(\n        {\n          keyword,\n          schemaProp: i,\n          dataProp: i,\n        },\n        valid\n      )\n    )\n    cxt.ok(valid)\n  })\n\n  function checkStrictTuple(sch: AnySchemaObject): void {\n    const {opts, errSchemaPath} = it\n    const l = schArr.length\n    const fullTuple = l === sch.minItems && (l === sch.maxItems || sch[extraItems] === false)\n    if (opts.strictTuples && !fullTuple) {\n      const msg = `\"${keyword}\" is ${l}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path \"${errSchemaPath}\"`\n      checkStrictMode(it, msg, opts.strictTuples)\n    }\n  }\n}\n\nexport default def\n","import type {\n  CodeKeywordDefinition,\n  KeywordErrorDefinition,\n  ErrorObject,\n  AnySchema,\n} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str} from \"../../compile/codegen\"\nimport {alwaysValidSchema} from \"../../compile/util\"\nimport {validateArray} from \"../code\"\nimport {validateAdditionalItems} from \"./additionalItems\"\n\nexport type ItemsError = ErrorObject<\"items\", {limit: number}, AnySchema>\n\nconst error: KeywordErrorDefinition = {\n  message: ({params: {len}}) => str`must NOT have more than ${len} items`,\n  params: ({params: {len}}) => _`{limit: ${len}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"items\",\n  type: \"array\",\n  schemaType: [\"object\", \"boolean\"],\n  before: \"uniqueItems\",\n  error,\n  code(cxt: KeywordCxt) {\n    const {schema, parentSchema, it} = cxt\n    const {prefixItems} = parentSchema\n    it.items = true\n    if (alwaysValidSchema(it, schema)) return\n    if (prefixItems) validateAdditionalItems(cxt, prefixItems)\n    else cxt.ok(validateArray(cxt))\n  },\n}\n\nexport default def\n","import type {CodeKeywordDefinition, ErrorNoParams, AnySchema} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {alwaysValidSchema} from \"../../compile/util\"\n\nexport type NotKeywordError = ErrorNoParams<\"not\", AnySchema>\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"not\",\n  schemaType: [\"object\", \"boolean\"],\n  trackErrors: true,\n  code(cxt: KeywordCxt) {\n    const {gen, schema, it} = cxt\n    if (alwaysValidSchema(it, schema)) {\n      cxt.fail()\n      return\n    }\n\n    const valid = gen.name(\"valid\")\n    cxt.subschema(\n      {\n        keyword: \"not\",\n        compositeRule: true,\n        createErrors: false,\n        allErrors: false,\n      },\n      valid\n    )\n\n    cxt.failResult(\n      valid,\n      () => cxt.reset(),\n      () => cxt.error()\n    )\n  },\n  error: {message: \"must NOT be valid\"},\n}\n\nexport default def\n","import type {\n  CodeKeywordDefinition,\n  ErrorObject,\n  KeywordErrorDefinition,\n  AnySchema,\n} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, Name} from \"../../compile/codegen\"\nimport {alwaysValidSchema} from \"../../compile/util\"\nimport {SchemaCxt} from \"../../compile\"\n\nexport type OneOfError = ErrorObject<\n  \"oneOf\",\n  {passingSchemas: [number, number] | null},\n  AnySchema[]\n>\n\nconst error: KeywordErrorDefinition = {\n  message: \"must match exactly one schema in oneOf\",\n  params: ({params}) => _`{passingSchemas: ${params.passing}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"oneOf\",\n  schemaType: \"array\",\n  trackErrors: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, schema, parentSchema, it} = cxt\n    /* istanbul ignore if */\n    if (!Array.isArray(schema)) throw new Error(\"ajv implementation error\")\n    if (it.opts.discriminator && parentSchema.discriminator) return\n    const schArr: AnySchema[] = schema\n    const valid = gen.let(\"valid\", false)\n    const passing = gen.let(\"passing\", null)\n    const schValid = gen.name(\"_valid\")\n    cxt.setParams({passing})\n    // TODO possibly fail straight away (with warning or exception) if there are two empty always valid schemas\n\n    gen.block(validateOneOf)\n\n    cxt.result(\n      valid,\n      () => cxt.reset(),\n      () => cxt.error(true)\n    )\n\n    function validateOneOf(): void {\n      schArr.forEach((sch: AnySchema, i: number) => {\n        let schCxt: SchemaCxt | undefined\n        if (alwaysValidSchema(it, sch)) {\n          gen.var(schValid, true)\n        } else {\n          schCxt = cxt.subschema(\n            {\n              keyword: \"oneOf\",\n              schemaProp: i,\n              compositeRule: true,\n            },\n            schValid\n          )\n        }\n\n        if (i > 0) {\n          gen\n            .if(_`${schValid} && ${valid}`)\n            .assign(valid, false)\n            .assign(passing, _`[${passing}, ${i}]`)\n            .else()\n        }\n\n        gen.if(schValid, () => {\n          gen.assign(valid, true)\n          gen.assign(passing, i)\n          if (schCxt) cxt.mergeEvaluated(schCxt, Name)\n        })\n      })\n    }\n  },\n}\n\nexport default def\n","import type {CodeKeywordDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {allSchemaProperties, usePattern} from \"../code\"\nimport {_, not, Name} from \"../../compile/codegen\"\nimport {alwaysValidSchema, checkStrictMode} from \"../../compile/util\"\nimport {evaluatedPropsToName, Type} from \"../../compile/util\"\nimport {AnySchema} from \"../../types\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"patternProperties\",\n  type: \"object\",\n  schemaType: \"object\",\n  code(cxt: KeywordCxt) {\n    const {gen, schema, data, parentSchema, it} = cxt\n    const {opts} = it\n    const patterns = allSchemaProperties(schema)\n    const alwaysValidPatterns = patterns.filter((p) =>\n      alwaysValidSchema(it, schema[p] as AnySchema)\n    )\n\n    if (\n      patterns.length === 0 ||\n      (alwaysValidPatterns.length === patterns.length &&\n        (!it.opts.unevaluated || it.props === true))\n    ) {\n      return\n    }\n\n    const checkProperties =\n      opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties\n    const valid = gen.name(\"valid\")\n    if (it.props !== true && !(it.props instanceof Name)) {\n      it.props = evaluatedPropsToName(gen, it.props)\n    }\n    const {props} = it\n    validatePatternProperties()\n\n    function validatePatternProperties(): void {\n      for (const pat of patterns) {\n        if (checkProperties) checkMatchingProperties(pat)\n        if (it.allErrors) {\n          validateProperties(pat)\n        } else {\n          gen.var(valid, true) // TODO var\n          validateProperties(pat)\n          gen.if(valid)\n        }\n      }\n    }\n\n    function checkMatchingProperties(pat: string): void {\n      for (const prop in checkProperties) {\n        if (new RegExp(pat).test(prop)) {\n          checkStrictMode(\n            it,\n            `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`\n          )\n        }\n      }\n    }\n\n    function validateProperties(pat: string): void {\n      gen.forIn(\"key\", data, (key) => {\n        gen.if(_`${usePattern(cxt, pat)}.test(${key})`, () => {\n          const alwaysValid = alwaysValidPatterns.includes(pat)\n          if (!alwaysValid) {\n            cxt.subschema(\n              {\n                keyword: \"patternProperties\",\n                schemaProp: pat,\n                dataProp: key,\n                dataPropType: Type.Str,\n              },\n              valid\n            )\n          }\n\n          if (it.opts.unevaluated && props !== true) {\n            gen.assign(_`${props}[${key}]`, true)\n          } else if (!alwaysValid && !it.allErrors) {\n            // can short-circuit if `unevaluatedProperties` is not supported (opts.next === false)\n            // or if all properties were evaluated (props === true)\n            gen.if(not(valid), () => gen.break())\n          }\n        })\n      })\n    }\n  },\n}\n\nexport default def\n","import type {CodeKeywordDefinition} from \"../../types\"\nimport {validateTuple} from \"./items\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"prefixItems\",\n  type: \"array\",\n  schemaType: [\"array\"],\n  before: \"uniqueItems\",\n  code: (cxt) => validateTuple(cxt, \"items\"),\n}\n\nexport default def\n","import type {CodeKeywordDefinition} from \"../../types\"\nimport {KeywordCxt} from \"../../compile/validate\"\nimport {propertyInData, allSchemaProperties} from \"../code\"\nimport {alwaysValidSchema, toHash, mergeEvaluated} from \"../../compile/util\"\nimport apDef from \"./additionalProperties\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"properties\",\n  type: \"object\",\n  schemaType: \"object\",\n  code(cxt: KeywordCxt) {\n    const {gen, schema, parentSchema, data, it} = cxt\n    if (it.opts.removeAdditional === \"all\" && parentSchema.additionalProperties === undefined) {\n      apDef.code(new KeywordCxt(it, apDef, \"additionalProperties\"))\n    }\n    const allProps = allSchemaProperties(schema)\n    for (const prop of allProps) {\n      it.definedProperties.add(prop)\n    }\n    if (it.opts.unevaluated && allProps.length && it.props !== true) {\n      it.props = mergeEvaluated.props(gen, toHash(allProps), it.props)\n    }\n    const properties = allProps.filter((p) => !alwaysValidSchema(it, schema[p]))\n    if (properties.length === 0) return\n    const valid = gen.name(\"valid\")\n\n    for (const prop of properties) {\n      if (hasDefault(prop)) {\n        applyPropertySchema(prop)\n      } else {\n        gen.if(propertyInData(gen, data, prop, it.opts.ownProperties))\n        applyPropertySchema(prop)\n        if (!it.allErrors) gen.else().var(valid, true)\n        gen.endIf()\n      }\n      cxt.it.definedProperties.add(prop)\n      cxt.ok(valid)\n    }\n\n    function hasDefault(prop: string): boolean | undefined {\n      return it.opts.useDefaults && !it.compositeRule && schema[prop].default !== undefined\n    }\n\n    function applyPropertySchema(prop: string): void {\n      cxt.subschema(\n        {\n          keyword: \"properties\",\n          schemaProp: prop,\n          dataProp: prop,\n        },\n        valid\n      )\n    }\n  },\n}\n\nexport default def\n","import type {\n  CodeKeywordDefinition,\n  ErrorObject,\n  KeywordErrorDefinition,\n  AnySchema,\n} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, not} from \"../../compile/codegen\"\nimport {alwaysValidSchema} from \"../../compile/util\"\n\nexport type PropertyNamesError = ErrorObject<\"propertyNames\", {propertyName: string}, AnySchema>\n\nconst error: KeywordErrorDefinition = {\n  message: \"property name must be valid\",\n  params: ({params}) => _`{propertyName: ${params.propertyName}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"propertyNames\",\n  type: \"object\",\n  schemaType: [\"object\", \"boolean\"],\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, schema, data, it} = cxt\n    if (alwaysValidSchema(it, schema)) return\n    const valid = gen.name(\"valid\")\n\n    gen.forIn(\"key\", data, (key) => {\n      cxt.setParams({propertyName: key})\n      cxt.subschema(\n        {\n          keyword: \"propertyNames\",\n          data: key,\n          dataTypes: [\"string\"],\n          propertyName: key,\n          compositeRule: true,\n        },\n        valid\n      )\n      gen.if(not(valid), () => {\n        cxt.error(true)\n        if (!it.allErrors) gen.break()\n      })\n    })\n\n    cxt.ok(valid)\n  },\n}\n\nexport default def\n","import type {CodeKeywordDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {checkStrictMode} from \"../../compile/util\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: [\"then\", \"else\"],\n  schemaType: [\"object\", \"boolean\"],\n  code({keyword, parentSchema, it}: KeywordCxt) {\n    if (parentSchema.if === undefined) checkStrictMode(it, `\"${keyword}\" without \"if\" is ignored`)\n  },\n}\n\nexport default def\n","import type {AnySchema, SchemaMap} from \"../types\"\nimport type {SchemaCxt} from \"../compile\"\nimport type {KeywordCxt} from \"../compile/validate\"\nimport {CodeGen, _, and, or, not, nil, strConcat, getProperty, Code, Name} from \"../compile/codegen\"\nimport {alwaysValidSchema, Type} from \"../compile/util\"\nimport N from \"../compile/names\"\nimport {useFunc} from \"../compile/util\"\nexport function checkReportMissingProp(cxt: KeywordCxt, prop: string): void {\n  const {gen, data, it} = cxt\n  gen.if(noPropertyInData(gen, data, prop, it.opts.ownProperties), () => {\n    cxt.setParams({missingProperty: _`${prop}`}, true)\n    cxt.error()\n  })\n}\n\nexport function checkMissingProp(\n  {gen, data, it: {opts}}: KeywordCxt,\n  properties: string[],\n  missing: Name\n): Code {\n  return or(\n    ...properties.map((prop) =>\n      and(noPropertyInData(gen, data, prop, opts.ownProperties), _`${missing} = ${prop}`)\n    )\n  )\n}\n\nexport function reportMissingProp(cxt: KeywordCxt, missing: Name): void {\n  cxt.setParams({missingProperty: missing}, true)\n  cxt.error()\n}\n\nexport function hasPropFunc(gen: CodeGen): Name {\n  return gen.scopeValue(\"func\", {\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    ref: Object.prototype.hasOwnProperty,\n    code: _`Object.prototype.hasOwnProperty`,\n  })\n}\n\nexport function isOwnProperty(gen: CodeGen, data: Name, property: Name | string): Code {\n  return _`${hasPropFunc(gen)}.call(${data}, ${property})`\n}\n\nexport function propertyInData(\n  gen: CodeGen,\n  data: Name,\n  property: Name | string,\n  ownProperties?: boolean\n): Code {\n  const cond = _`${data}${getProperty(property)} !== undefined`\n  return ownProperties ? _`${cond} && ${isOwnProperty(gen, data, property)}` : cond\n}\n\nexport function noPropertyInData(\n  gen: CodeGen,\n  data: Name,\n  property: Name | string,\n  ownProperties?: boolean\n): Code {\n  const cond = _`${data}${getProperty(property)} === undefined`\n  return ownProperties ? or(cond, not(isOwnProperty(gen, data, property))) : cond\n}\n\nexport function allSchemaProperties(schemaMap?: SchemaMap): string[] {\n  return schemaMap ? Object.keys(schemaMap).filter((p) => p !== \"__proto__\") : []\n}\n\nexport function schemaProperties(it: SchemaCxt, schemaMap: SchemaMap): string[] {\n  return allSchemaProperties(schemaMap).filter(\n    (p) => !alwaysValidSchema(it, schemaMap[p] as AnySchema)\n  )\n}\n\nexport function callValidateCode(\n  {schemaCode, data, it: {gen, topSchemaRef, schemaPath, errorPath}, it}: KeywordCxt,\n  func: Code,\n  context: Code,\n  passSchema?: boolean\n): Code {\n  const dataAndSchema = passSchema ? _`${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}` : data\n  const valCxt: [Name, Code | number][] = [\n    [N.instancePath, strConcat(N.instancePath, errorPath)],\n    [N.parentData, it.parentData],\n    [N.parentDataProperty, it.parentDataProperty],\n    [N.rootData, N.rootData],\n  ]\n  if (it.opts.dynamicRef) valCxt.push([N.dynamicAnchors, N.dynamicAnchors])\n  const args = _`${dataAndSchema}, ${gen.object(...valCxt)}`\n  return context !== nil ? _`${func}.call(${context}, ${args})` : _`${func}(${args})`\n}\n\nconst newRegExp = _`new RegExp`\n\nexport function usePattern({gen, it: {opts}}: KeywordCxt, pattern: string): Name {\n  const u = opts.unicodeRegExp ? \"u\" : \"\"\n  const {regExp} = opts.code\n  const rx = regExp(pattern, u)\n\n  return gen.scopeValue(\"pattern\", {\n    key: rx.toString(),\n    ref: rx,\n    code: _`${regExp.code === \"new RegExp\" ? newRegExp : useFunc(gen, regExp)}(${pattern}, ${u})`,\n  })\n}\n\nexport function validateArray(cxt: KeywordCxt): Name {\n  const {gen, data, keyword, it} = cxt\n  const valid = gen.name(\"valid\")\n  if (it.allErrors) {\n    const validArr = gen.let(\"valid\", true)\n    validateItems(() => gen.assign(validArr, false))\n    return validArr\n  }\n  gen.var(valid, true)\n  validateItems(() => gen.break())\n  return valid\n\n  function validateItems(notValid: () => void): void {\n    const len = gen.const(\"len\", _`${data}.length`)\n    gen.forRange(\"i\", 0, len, (i) => {\n      cxt.subschema(\n        {\n          keyword,\n          dataProp: i,\n          dataPropType: Type.Num,\n        },\n        valid\n      )\n      gen.if(not(valid), notValid)\n    })\n  }\n}\n\nexport function validateUnion(cxt: KeywordCxt): void {\n  const {gen, schema, keyword, it} = cxt\n  /* istanbul ignore if */\n  if (!Array.isArray(schema)) throw new Error(\"ajv implementation error\")\n  const alwaysValid = schema.some((sch: AnySchema) => alwaysValidSchema(it, sch))\n  if (alwaysValid && !it.opts.unevaluated) return\n\n  const valid = gen.let(\"valid\", false)\n  const schValid = gen.name(\"_valid\")\n\n  gen.block(() =>\n    schema.forEach((_sch: AnySchema, i: number) => {\n      const schCxt = cxt.subschema(\n        {\n          keyword,\n          schemaProp: i,\n          compositeRule: true,\n        },\n        schValid\n      )\n      gen.assign(valid, _`${valid} || ${schValid}`)\n      const merged = cxt.mergeValidEvaluated(schCxt, schValid)\n      // can short-circuit if `unevaluatedProperties/Items` not supported (opts.unevaluated !== true)\n      // or if all properties and items were evaluated (it.props === true && it.items === true)\n      if (!merged) gen.if(not(valid))\n    })\n  )\n\n  cxt.result(\n    valid,\n    () => cxt.reset(),\n    () => cxt.error(true)\n  )\n}\n","import type {CodeKeywordDefinition} from \"../../types\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"id\",\n  code() {\n    throw new Error('NOT SUPPORTED: keyword \"id\", use \"$id\" for schema ID')\n  },\n}\n\nexport default def\n","import type {Vocabulary} from \"../../types\"\nimport idKeyword from \"./id\"\nimport refKeyword from \"./ref\"\n\nconst core: Vocabulary = [\n  \"$schema\",\n  \"$id\",\n  \"$defs\",\n  \"$vocabulary\",\n  {keyword: \"$comment\"},\n  \"definitions\",\n  idKeyword,\n  refKeyword,\n]\n\nexport default core\n","import type {CodeKeywordDefinition, AnySchema} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport MissingRefError from \"../../compile/ref_error\"\nimport {callValidateCode} from \"../code\"\nimport {_, nil, stringify, Code, Name} from \"../../compile/codegen\"\nimport N from \"../../compile/names\"\nimport {SchemaEnv, resolveRef} from \"../../compile\"\nimport {mergeEvaluated} from \"../../compile/util\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"$ref\",\n  schemaType: \"string\",\n  code(cxt: KeywordCxt): void {\n    const {gen, schema: $ref, it} = cxt\n    const {baseId, schemaEnv: env, validateName, opts, self} = it\n    const {root} = env\n    if (($ref === \"#\" || $ref === \"#/\") && baseId === root.baseId) return callRootRef()\n    const schOrEnv = resolveRef.call(self, root, baseId, $ref)\n    if (schOrEnv === undefined) throw new MissingRefError(it.opts.uriResolver, baseId, $ref)\n    if (schOrEnv instanceof SchemaEnv) return callValidate(schOrEnv)\n    return inlineRefSchema(schOrEnv)\n\n    function callRootRef(): void {\n      if (env === root) return callRef(cxt, validateName, env, env.$async)\n      const rootName = gen.scopeValue(\"root\", {ref: root})\n      return callRef(cxt, _`${rootName}.validate`, root, root.$async)\n    }\n\n    function callValidate(sch: SchemaEnv): void {\n      const v = getValidate(cxt, sch)\n      callRef(cxt, v, sch, sch.$async)\n    }\n\n    function inlineRefSchema(sch: AnySchema): void {\n      const schName = gen.scopeValue(\n        \"schema\",\n        opts.code.source === true ? {ref: sch, code: stringify(sch)} : {ref: sch}\n      )\n      const valid = gen.name(\"valid\")\n      const schCxt = cxt.subschema(\n        {\n          schema: sch,\n          dataTypes: [],\n          schemaPath: nil,\n          topSchemaRef: schName,\n          errSchemaPath: $ref,\n        },\n        valid\n      )\n      cxt.mergeEvaluated(schCxt)\n      cxt.ok(valid)\n    }\n  },\n}\n\nexport function getValidate(cxt: KeywordCxt, sch: SchemaEnv): Code {\n  const {gen} = cxt\n  return sch.validate\n    ? gen.scopeValue(\"validate\", {ref: sch.validate})\n    : _`${gen.scopeValue(\"wrapper\", {ref: sch})}.validate`\n}\n\nexport function callRef(cxt: KeywordCxt, v: Code, sch?: SchemaEnv, $async?: boolean): void {\n  const {gen, it} = cxt\n  const {allErrors, schemaEnv: env, opts} = it\n  const passCxt = opts.passContext ? N.this : nil\n  if ($async) callAsyncRef()\n  else callSyncRef()\n\n  function callAsyncRef(): void {\n    if (!env.$async) throw new Error(\"async schema referenced by sync schema\")\n    const valid = gen.let(\"valid\")\n    gen.try(\n      () => {\n        gen.code(_`await ${callValidateCode(cxt, v, passCxt)}`)\n        addEvaluatedFrom(v) // TODO will not work with async, it has to be returned with the result\n        if (!allErrors) gen.assign(valid, true)\n      },\n      (e) => {\n        gen.if(_`!(${e} instanceof ${it.ValidationError as Name})`, () => gen.throw(e))\n        addErrorsFrom(e)\n        if (!allErrors) gen.assign(valid, false)\n      }\n    )\n    cxt.ok(valid)\n  }\n\n  function callSyncRef(): void {\n    cxt.result(\n      callValidateCode(cxt, v, passCxt),\n      () => addEvaluatedFrom(v),\n      () => addErrorsFrom(v)\n    )\n  }\n\n  function addErrorsFrom(source: Code): void {\n    const errs = _`${source}.errors`\n    gen.assign(N.vErrors, _`${N.vErrors} === null ? ${errs} : ${N.vErrors}.concat(${errs})`) // TODO tagged\n    gen.assign(N.errors, _`${N.vErrors}.length`)\n  }\n\n  function addEvaluatedFrom(source: Code): void {\n    if (!it.opts.unevaluated) return\n    const schEvaluated = sch?.validate?.evaluated\n    // TODO refactor\n    if (it.props !== true) {\n      if (schEvaluated && !schEvaluated.dynamicProps) {\n        if (schEvaluated.props !== undefined) {\n          it.props = mergeEvaluated.props(gen, schEvaluated.props, it.props)\n        }\n      } else {\n        const props = gen.var(\"props\", _`${source}.evaluated.props`)\n        it.props = mergeEvaluated.props(gen, props, it.props, Name)\n      }\n    }\n    if (it.items !== true) {\n      if (schEvaluated && !schEvaluated.dynamicItems) {\n        if (schEvaluated.items !== undefined) {\n          it.items = mergeEvaluated.items(gen, schEvaluated.items, it.items)\n        }\n      } else {\n        const items = gen.var(\"items\", _`${source}.evaluated.items`)\n        it.items = mergeEvaluated.items(gen, items, it.items, Name)\n      }\n    }\n  }\n}\n\nexport default def\n","import type {CodeKeywordDefinition, AnySchemaObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, getProperty, Name} from \"../../compile/codegen\"\nimport {DiscrError, DiscrErrorObj} from \"../discriminator/types\"\nimport {resolveRef, SchemaEnv} from \"../../compile\"\nimport {schemaHasRulesButRef} from \"../../compile/util\"\n\nexport type DiscriminatorError = DiscrErrorObj<DiscrError.Tag> | DiscrErrorObj<DiscrError.Mapping>\n\nconst error: KeywordErrorDefinition = {\n  message: ({params: {discrError, tagName}}) =>\n    discrError === DiscrError.Tag\n      ? `tag \"${tagName}\" must be string`\n      : `value of tag \"${tagName}\" must be in oneOf`,\n  params: ({params: {discrError, tag, tagName}}) =>\n    _`{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"discriminator\",\n  type: \"object\",\n  schemaType: \"object\",\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, data, schema, parentSchema, it} = cxt\n    const {oneOf} = parentSchema\n    if (!it.opts.discriminator) {\n      throw new Error(\"discriminator: requires discriminator option\")\n    }\n    const tagName = schema.propertyName\n    if (typeof tagName != \"string\") throw new Error(\"discriminator: requires propertyName\")\n    if (schema.mapping) throw new Error(\"discriminator: mapping is not supported\")\n    if (!oneOf) throw new Error(\"discriminator: requires oneOf keyword\")\n    const valid = gen.let(\"valid\", false)\n    const tag = gen.const(\"tag\", _`${data}${getProperty(tagName)}`)\n    gen.if(\n      _`typeof ${tag} == \"string\"`,\n      () => validateMapping(),\n      () => cxt.error(false, {discrError: DiscrError.Tag, tag, tagName})\n    )\n    cxt.ok(valid)\n\n    function validateMapping(): void {\n      const mapping = getMapping()\n      gen.if(false)\n      for (const tagValue in mapping) {\n        gen.elseIf(_`${tag} === ${tagValue}`)\n        gen.assign(valid, applyTagSchema(mapping[tagValue]))\n      }\n      gen.else()\n      cxt.error(false, {discrError: DiscrError.Mapping, tag, tagName})\n      gen.endIf()\n    }\n\n    function applyTagSchema(schemaProp?: number): Name {\n      const _valid = gen.name(\"valid\")\n      const schCxt = cxt.subschema({keyword: \"oneOf\", schemaProp}, _valid)\n      cxt.mergeEvaluated(schCxt, Name)\n      return _valid\n    }\n\n    function getMapping(): {[T in string]?: number} {\n      const oneOfMapping: {[T in string]?: number} = {}\n      const topRequired = hasRequired(parentSchema)\n      let tagRequired = true\n      for (let i = 0; i < oneOf.length; i++) {\n        let sch = oneOf[i]\n        if (sch?.$ref && !schemaHasRulesButRef(sch, it.self.RULES)) {\n          sch = resolveRef.call(it.self, it.schemaEnv.root, it.baseId, sch?.$ref)\n          if (sch instanceof SchemaEnv) sch = sch.schema\n        }\n        const propSch = sch?.properties?.[tagName]\n        if (typeof propSch != \"object\") {\n          throw new Error(\n            `discriminator: oneOf subschemas (or referenced schemas) must have \"properties/${tagName}\"`\n          )\n        }\n        tagRequired = tagRequired && (topRequired || hasRequired(sch))\n        addMappings(propSch, i)\n      }\n      if (!tagRequired) throw new Error(`discriminator: \"${tagName}\" must be required`)\n      return oneOfMapping\n\n      function hasRequired({required}: AnySchemaObject): boolean {\n        return Array.isArray(required) && required.includes(tagName)\n      }\n\n      function addMappings(sch: AnySchemaObject, i: number): void {\n        if (sch.const) {\n          addMapping(sch.const, i)\n        } else if (sch.enum) {\n          for (const tagValue of sch.enum) {\n            addMapping(tagValue, i)\n          }\n        } else {\n          throw new Error(`discriminator: \"properties/${tagName}\" must have \"const\" or \"enum\"`)\n        }\n      }\n\n      function addMapping(tagValue: unknown, i: number): void {\n        if (typeof tagValue != \"string\" || tagValue in oneOfMapping) {\n          throw new Error(`discriminator: \"${tagName}\" values must be unique strings`)\n        }\n        oneOfMapping[tagValue] = i\n      }\n    }\n  },\n}\n\nexport default def\n","import type {ErrorObject} from \"../../types\"\n\nexport enum DiscrError {\n  Tag = \"tag\",\n  Mapping = \"mapping\",\n}\n\nexport type DiscrErrorObj<E extends DiscrError> = ErrorObject<\n  \"discriminator\",\n  {error: E; tag: string; tagValue: unknown},\n  string\n>\n","import type {Vocabulary} from \"../types\"\nimport coreVocabulary from \"./core\"\nimport validationVocabulary from \"./validation\"\nimport getApplicatorVocabulary from \"./applicator\"\nimport formatVocabulary from \"./format\"\nimport {metadataVocabulary, contentVocabulary} from \"./metadata\"\n\nconst draft7Vocabularies: Vocabulary[] = [\n  coreVocabulary,\n  validationVocabulary,\n  getApplicatorVocabulary(),\n  formatVocabulary,\n  metadataVocabulary,\n  contentVocabulary,\n]\n\nexport default draft7Vocabularies\n","import type {\n  AddedFormat,\n  FormatValidator,\n  AsyncFormatValidator,\n  CodeKeywordDefinition,\n  KeywordErrorDefinition,\n  ErrorObject,\n} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, nil, or, Code, getProperty, regexpCode} from \"../../compile/codegen\"\n\ntype FormatValidate =\n  | FormatValidator<string>\n  | FormatValidator<number>\n  | AsyncFormatValidator<string>\n  | AsyncFormatValidator<number>\n  | RegExp\n  | string\n  | true\n\nexport type FormatError = ErrorObject<\"format\", {format: string}, string | {$data: string}>\n\nconst error: KeywordErrorDefinition = {\n  message: ({schemaCode}) => str`must match format \"${schemaCode}\"`,\n  params: ({schemaCode}) => _`{format: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"format\",\n  type: [\"number\", \"string\"],\n  schemaType: \"string\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt, ruleType?: string) {\n    const {gen, data, $data, schema, schemaCode, it} = cxt\n    const {opts, errSchemaPath, schemaEnv, self} = it\n    if (!opts.validateFormats) return\n\n    if ($data) validate$DataFormat()\n    else validateFormat()\n\n    function validate$DataFormat(): void {\n      const fmts = gen.scopeValue(\"formats\", {\n        ref: self.formats,\n        code: opts.code.formats,\n      })\n      const fDef = gen.const(\"fDef\", _`${fmts}[${schemaCode}]`)\n      const fType = gen.let(\"fType\")\n      const format = gen.let(\"format\")\n      // TODO simplify\n      gen.if(\n        _`typeof ${fDef} == \"object\" && !(${fDef} instanceof RegExp)`,\n        () => gen.assign(fType, _`${fDef}.type || \"string\"`).assign(format, _`${fDef}.validate`),\n        () => gen.assign(fType, _`\"string\"`).assign(format, fDef)\n      )\n      cxt.fail$data(or(unknownFmt(), invalidFmt()))\n\n      function unknownFmt(): Code {\n        if (opts.strictSchema === false) return nil\n        return _`${schemaCode} && !${format}`\n      }\n\n      function invalidFmt(): Code {\n        const callFormat = schemaEnv.$async\n          ? _`(${fDef}.async ? await ${format}(${data}) : ${format}(${data}))`\n          : _`${format}(${data})`\n        const validData = _`(typeof ${format} == \"function\" ? ${callFormat} : ${format}.test(${data}))`\n        return _`${format} && ${format} !== true && ${fType} === ${ruleType} && !${validData}`\n      }\n    }\n\n    function validateFormat(): void {\n      const formatDef: AddedFormat | undefined = self.formats[schema]\n      if (!formatDef) {\n        unknownFormat()\n        return\n      }\n      if (formatDef === true) return\n      const [fmtType, format, fmtRef] = getFormat(formatDef)\n      if (fmtType === ruleType) cxt.pass(validCondition())\n\n      function unknownFormat(): void {\n        if (opts.strictSchema === false) {\n          self.logger.warn(unknownMsg())\n          return\n        }\n        throw new Error(unknownMsg())\n\n        function unknownMsg(): string {\n          return `unknown format \"${schema as string}\" ignored in schema at path \"${errSchemaPath}\"`\n        }\n      }\n\n      function getFormat(fmtDef: AddedFormat): [string, FormatValidate, Code] {\n        const code =\n          fmtDef instanceof RegExp\n            ? regexpCode(fmtDef)\n            : opts.code.formats\n            ? _`${opts.code.formats}${getProperty(schema)}`\n            : undefined\n        const fmt = gen.scopeValue(\"formats\", {key: schema, ref: fmtDef, code})\n        if (typeof fmtDef == \"object\" && !(fmtDef instanceof RegExp)) {\n          return [fmtDef.type || \"string\", fmtDef.validate, _`${fmt}.validate`]\n        }\n\n        return [\"string\", fmtDef, fmt]\n      }\n\n      function validCondition(): Code {\n        if (typeof formatDef == \"object\" && !(formatDef instanceof RegExp) && formatDef.async) {\n          if (!schemaEnv.$async) throw new Error(\"async format in sync schema\")\n          return _`await ${fmtRef}(${data})`\n        }\n        return typeof format == \"function\" ? _`${fmtRef}(${data})` : _`${fmtRef}.test(${data})`\n      }\n    }\n  },\n}\n\nexport default def\n","import type {Vocabulary} from \"../../types\"\nimport formatKeyword from \"./format\"\n\nconst format: Vocabulary = [formatKeyword]\n\nexport default format\n","import type {Vocabulary} from \"../types\"\n\nexport const metadataVocabulary: Vocabulary = [\n  \"title\",\n  \"description\",\n  \"default\",\n  \"deprecated\",\n  \"readOnly\",\n  \"writeOnly\",\n  \"examples\",\n]\n\nexport const contentVocabulary: Vocabulary = [\n  \"contentMediaType\",\n  \"contentEncoding\",\n  \"contentSchema\",\n]\n","import type {CodeKeywordDefinition, ErrorObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_} from \"../../compile/codegen\"\nimport {useFunc} from \"../../compile/util\"\nimport equal from \"../../runtime/equal\"\n\nexport type ConstError = ErrorObject<\"const\", {allowedValue: any}>\n\nconst error: KeywordErrorDefinition = {\n  message: \"must be equal to constant\",\n  params: ({schemaCode}) => _`{allowedValue: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"const\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, data, $data, schemaCode, schema} = cxt\n    if ($data || (schema && typeof schema == \"object\")) {\n      cxt.fail$data(_`!${useFunc(gen, equal)}(${data}, ${schemaCode})`)\n    } else {\n      cxt.fail(_`${schema} !== ${data}`)\n    }\n  },\n}\n\nexport default def\n","import type {CodeKeywordDefinition, ErrorObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, or, Name, Code} from \"../../compile/codegen\"\nimport {useFunc} from \"../../compile/util\"\nimport equal from \"../../runtime/equal\"\n\nexport type EnumError = ErrorObject<\"enum\", {allowedValues: any[]}, any[] | {$data: string}>\n\nconst error: KeywordErrorDefinition = {\n  message: \"must be equal to one of the allowed values\",\n  params: ({schemaCode}) => _`{allowedValues: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"enum\",\n  schemaType: \"array\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, data, $data, schema, schemaCode, it} = cxt\n    if (!$data && schema.length === 0) throw new Error(\"enum must have non-empty array\")\n    const useLoop = schema.length >= it.opts.loopEnum\n    let eql: Name | undefined\n    const getEql = (): Name => (eql ??= useFunc(gen, equal))\n\n    let valid: Code\n    if (useLoop || $data) {\n      valid = gen.let(\"valid\")\n      cxt.block$data(valid, loopEnum)\n    } else {\n      /* istanbul ignore if */\n      if (!Array.isArray(schema)) throw new Error(\"ajv implementation error\")\n      const vSchema = gen.const(\"vSchema\", schemaCode)\n      valid = or(...schema.map((_x: unknown, i: number) => equalCode(vSchema, i)))\n    }\n    cxt.pass(valid)\n\n    function loopEnum(): void {\n      gen.assign(valid, false)\n      gen.forOf(\"v\", schemaCode as Code, (v) =>\n        gen.if(_`${getEql()}(${data}, ${v})`, () => gen.assign(valid, true).break())\n      )\n    }\n\n    function equalCode(vSchema: Name, i: number): Code {\n      const sch = schema[i]\n      return typeof sch === \"object\" && sch !== null\n        ? _`${getEql()}(${data}, ${vSchema}[${i}])`\n        : _`${data} === ${sch}`\n    }\n  },\n}\n\nexport default def\n","import type {ErrorObject, Vocabulary} from \"../../types\"\nimport limitNumber, {LimitNumberError} from \"./limitNumber\"\nimport multipleOf, {MultipleOfError} from \"./multipleOf\"\nimport limitLength from \"./limitLength\"\nimport pattern, {PatternError} from \"./pattern\"\nimport limitProperties from \"./limitProperties\"\nimport required, {RequiredError} from \"./required\"\nimport limitItems from \"./limitItems\"\nimport uniqueItems, {UniqueItemsError} from \"./uniqueItems\"\nimport constKeyword, {ConstError} from \"./const\"\nimport enumKeyword, {EnumError} from \"./enum\"\n\nconst validation: Vocabulary = [\n  // number\n  limitNumber,\n  multipleOf,\n  // string\n  limitLength,\n  pattern,\n  // object\n  limitProperties,\n  required,\n  // array\n  limitItems,\n  uniqueItems,\n  // any\n  {keyword: \"type\", schemaType: [\"string\", \"array\"]},\n  {keyword: \"nullable\", schemaType: \"boolean\"},\n  constKeyword,\n  enumKeyword,\n]\n\nexport default validation\n\ntype LimitError = ErrorObject<\n  \"maxItems\" | \"minItems\" | \"minProperties\" | \"maxProperties\" | \"minLength\" | \"maxLength\",\n  {limit: number},\n  number | {$data: string}\n>\n\nexport type ValidationKeywordError =\n  | LimitError\n  | LimitNumberError\n  | MultipleOfError\n  | PatternError\n  | RequiredError\n  | UniqueItemsError\n  | ConstError\n  | EnumError\n","import type {CodeKeywordDefinition, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, operators} from \"../../compile/codegen\"\n\nconst error: KeywordErrorDefinition = {\n  message({keyword, schemaCode}) {\n    const comp = keyword === \"maxItems\" ? \"more\" : \"fewer\"\n    return str`must NOT have ${comp} than ${schemaCode} items`\n  },\n  params: ({schemaCode}) => _`{limit: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: [\"maxItems\", \"minItems\"],\n  type: \"array\",\n  schemaType: \"number\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {keyword, data, schemaCode} = cxt\n    const op = keyword === \"maxItems\" ? operators.GT : operators.LT\n    cxt.fail$data(_`${data}.length ${op} ${schemaCode}`)\n  },\n}\n\nexport default def\n","import type {CodeKeywordDefinition, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, operators} from \"../../compile/codegen\"\nimport {useFunc} from \"../../compile/util\"\nimport ucs2length from \"../../runtime/ucs2length\"\n\nconst error: KeywordErrorDefinition = {\n  message({keyword, schemaCode}) {\n    const comp = keyword === \"maxLength\" ? \"more\" : \"fewer\"\n    return str`must NOT have ${comp} than ${schemaCode} characters`\n  },\n  params: ({schemaCode}) => _`{limit: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: [\"maxLength\", \"minLength\"],\n  type: \"string\",\n  schemaType: \"number\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {keyword, data, schemaCode, it} = cxt\n    const op = keyword === \"maxLength\" ? operators.GT : operators.LT\n    const len =\n      it.opts.unicode === false ? _`${data}.length` : _`${useFunc(cxt.gen, ucs2length)}(${data})`\n    cxt.fail$data(_`${len} ${op} ${schemaCode}`)\n  },\n}\n\nexport default def\n","import type {CodeKeywordDefinition, ErrorObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, operators, Code} from \"../../compile/codegen\"\n\nconst ops = operators\n\ntype Kwd = \"maximum\" | \"minimum\" | \"exclusiveMaximum\" | \"exclusiveMinimum\"\n\ntype Comparison = \"<=\" | \">=\" | \"<\" | \">\"\n\nconst KWDs: {[K in Kwd]: {okStr: Comparison; ok: Code; fail: Code}} = {\n  maximum: {okStr: \"<=\", ok: ops.LTE, fail: ops.GT},\n  minimum: {okStr: \">=\", ok: ops.GTE, fail: ops.LT},\n  exclusiveMaximum: {okStr: \"<\", ok: ops.LT, fail: ops.GTE},\n  exclusiveMinimum: {okStr: \">\", ok: ops.GT, fail: ops.LTE},\n}\n\nexport type LimitNumberError = ErrorObject<\n  Kwd,\n  {limit: number; comparison: Comparison},\n  number | {$data: string}\n>\n\nconst error: KeywordErrorDefinition = {\n  message: ({keyword, schemaCode}) => str`must be ${KWDs[keyword as Kwd].okStr} ${schemaCode}`,\n  params: ({keyword, schemaCode}) =>\n    _`{comparison: ${KWDs[keyword as Kwd].okStr}, limit: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: Object.keys(KWDs),\n  type: \"number\",\n  schemaType: \"number\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {keyword, data, schemaCode} = cxt\n    cxt.fail$data(_`${data} ${KWDs[keyword as Kwd].fail} ${schemaCode} || isNaN(${data})`)\n  },\n}\n\nexport default def\n","import type {CodeKeywordDefinition, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, operators} from \"../../compile/codegen\"\n\nconst error: KeywordErrorDefinition = {\n  message({keyword, schemaCode}) {\n    const comp = keyword === \"maxProperties\" ? \"more\" : \"fewer\"\n    return str`must NOT have ${comp} than ${schemaCode} properties`\n  },\n  params: ({schemaCode}) => _`{limit: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: [\"maxProperties\", \"minProperties\"],\n  type: \"object\",\n  schemaType: \"number\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {keyword, data, schemaCode} = cxt\n    const op = keyword === \"maxProperties\" ? operators.GT : operators.LT\n    cxt.fail$data(_`Object.keys(${data}).length ${op} ${schemaCode}`)\n  },\n}\n\nexport default def\n","import type {CodeKeywordDefinition, ErrorObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str} from \"../../compile/codegen\"\n\nexport type MultipleOfError = ErrorObject<\n  \"multipleOf\",\n  {multipleOf: number},\n  number | {$data: string}\n>\n\nconst error: KeywordErrorDefinition = {\n  message: ({schemaCode}) => str`must be multiple of ${schemaCode}`,\n  params: ({schemaCode}) => _`{multipleOf: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"multipleOf\",\n  type: \"number\",\n  schemaType: \"number\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, data, schemaCode, it} = cxt\n    // const bdt = bad$DataType(schemaCode, <string>def.schemaType, $data)\n    const prec = it.opts.multipleOfPrecision\n    const res = gen.let(\"res\")\n    const invalid = prec\n      ? _`Math.abs(Math.round(${res}) - ${res}) > 1e-${prec}`\n      : _`${res} !== parseInt(${res})`\n    cxt.fail$data(_`(${schemaCode} === 0 || (${res} = ${data}/${schemaCode}, ${invalid}))`)\n  },\n}\n\nexport default def\n","import type {CodeKeywordDefinition, ErrorObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {usePattern} from \"../code\"\nimport {_, str} from \"../../compile/codegen\"\n\nexport type PatternError = ErrorObject<\"pattern\", {pattern: string}, string | {$data: string}>\n\nconst error: KeywordErrorDefinition = {\n  message: ({schemaCode}) => str`must match pattern \"${schemaCode}\"`,\n  params: ({schemaCode}) => _`{pattern: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"pattern\",\n  type: \"string\",\n  schemaType: \"string\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {data, $data, schema, schemaCode, it} = cxt\n    // TODO regexp should be wrapped in try/catchs\n    const u = it.opts.unicodeRegExp ? \"u\" : \"\"\n    const regExp = $data ? _`(new RegExp(${schemaCode}, ${u}))` : usePattern(cxt, schema)\n    cxt.fail$data(_`!${regExp}.test(${data})`)\n  },\n}\n\nexport default def\n","import type {CodeKeywordDefinition, ErrorObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {\n  checkReportMissingProp,\n  checkMissingProp,\n  reportMissingProp,\n  propertyInData,\n  noPropertyInData,\n} from \"../code\"\nimport {_, str, nil, not, Name, Code} from \"../../compile/codegen\"\nimport {checkStrictMode} from \"../../compile/util\"\n\nexport type RequiredError = ErrorObject<\n  \"required\",\n  {missingProperty: string},\n  string[] | {$data: string}\n>\n\nconst error: KeywordErrorDefinition = {\n  message: ({params: {missingProperty}}) => str`must have required property '${missingProperty}'`,\n  params: ({params: {missingProperty}}) => _`{missingProperty: ${missingProperty}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"required\",\n  type: \"object\",\n  schemaType: \"array\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, schema, schemaCode, data, $data, it} = cxt\n    const {opts} = it\n    if (!$data && schema.length === 0) return\n    const useLoop = schema.length >= opts.loopRequired\n    if (it.allErrors) allErrorsMode()\n    else exitOnErrorMode()\n\n    if (opts.strictRequired) {\n      const props = cxt.parentSchema.properties\n      const {definedProperties} = cxt.it\n      for (const requiredKey of schema) {\n        if (props?.[requiredKey] === undefined && !definedProperties.has(requiredKey)) {\n          const schemaPath = it.schemaEnv.baseId + it.errSchemaPath\n          const msg = `required property \"${requiredKey}\" is not defined at \"${schemaPath}\" (strictRequired)`\n          checkStrictMode(it, msg, it.opts.strictRequired)\n        }\n      }\n    }\n\n    function allErrorsMode(): void {\n      if (useLoop || $data) {\n        cxt.block$data(nil, loopAllRequired)\n      } else {\n        for (const prop of schema) {\n          checkReportMissingProp(cxt, prop)\n        }\n      }\n    }\n\n    function exitOnErrorMode(): void {\n      const missing = gen.let(\"missing\")\n      if (useLoop || $data) {\n        const valid = gen.let(\"valid\", true)\n        cxt.block$data(valid, () => loopUntilMissing(missing, valid))\n        cxt.ok(valid)\n      } else {\n        gen.if(checkMissingProp(cxt, schema, missing))\n        reportMissingProp(cxt, missing)\n        gen.else()\n      }\n    }\n\n    function loopAllRequired(): void {\n      gen.forOf(\"prop\", schemaCode as Code, (prop) => {\n        cxt.setParams({missingProperty: prop})\n        gen.if(noPropertyInData(gen, data, prop, opts.ownProperties), () => cxt.error())\n      })\n    }\n\n    function loopUntilMissing(missing: Name, valid: Name): void {\n      cxt.setParams({missingProperty: missing})\n      gen.forOf(\n        missing,\n        schemaCode as Code,\n        () => {\n          gen.assign(valid, propertyInData(gen, data, missing, opts.ownProperties))\n          gen.if(not(valid), () => {\n            cxt.error()\n            gen.break()\n          })\n        },\n        nil\n      )\n    }\n  },\n}\n\nexport default def\n","import type {CodeKeywordDefinition, ErrorObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {checkDataTypes, getSchemaTypes, DataType} from \"../../compile/validate/dataType\"\nimport {_, str, Name} from \"../../compile/codegen\"\nimport {useFunc} from \"../../compile/util\"\nimport equal from \"../../runtime/equal\"\n\nexport type UniqueItemsError = ErrorObject<\n  \"uniqueItems\",\n  {i: number; j: number},\n  boolean | {$data: string}\n>\n\nconst error: KeywordErrorDefinition = {\n  message: ({params: {i, j}}) =>\n    str`must NOT have duplicate items (items ## ${j} and ${i} are identical)`,\n  params: ({params: {i, j}}) => _`{i: ${i}, j: ${j}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"uniqueItems\",\n  type: \"array\",\n  schemaType: \"boolean\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, data, $data, schema, parentSchema, schemaCode, it} = cxt\n    if (!$data && !schema) return\n    const valid = gen.let(\"valid\")\n    const itemTypes = parentSchema.items ? getSchemaTypes(parentSchema.items) : []\n    cxt.block$data(valid, validateUniqueItems, _`${schemaCode} === false`)\n    cxt.ok(valid)\n\n    function validateUniqueItems(): void {\n      const i = gen.let(\"i\", _`${data}.length`)\n      const j = gen.let(\"j\")\n      cxt.setParams({i, j})\n      gen.assign(valid, true)\n      gen.if(_`${i} > 1`, () => (canOptimize() ? loopN : loopN2)(i, j))\n    }\n\n    function canOptimize(): boolean {\n      return itemTypes.length > 0 && !itemTypes.some((t) => t === \"object\" || t === \"array\")\n    }\n\n    function loopN(i: Name, j: Name): void {\n      const item = gen.name(\"item\")\n      const wrongType = checkDataTypes(itemTypes, item, it.opts.strictNumbers, DataType.Wrong)\n      const indices = gen.const(\"indices\", _`{}`)\n      gen.for(_`;${i}--;`, () => {\n        gen.let(item, _`${data}[${i}]`)\n        gen.if(wrongType, _`continue`)\n        if (itemTypes.length > 1) gen.if(_`typeof ${item} == \"string\"`, _`${item} += \"_\"`)\n        gen\n          .if(_`typeof ${indices}[${item}] == \"number\"`, () => {\n            gen.assign(j, _`${indices}[${item}]`)\n            cxt.error()\n            gen.assign(valid, false).break()\n          })\n          .code(_`${indices}[${item}] = ${i}`)\n      })\n    }\n\n    function loopN2(i: Name, j: Name): void {\n      const eql = useFunc(gen, equal)\n      const outer = gen.name(\"outer\")\n      gen.label(outer).for(_`;${i}--;`, () =>\n        gen.for(_`${j} = ${i}; ${j}--;`, () =>\n          gen.if(_`${eql}(${data}[${i}], ${data}[${j}])`, () => {\n            cxt.error()\n            gen.assign(valid, false).break(outer)\n          })\n        )\n      )\n    }\n  },\n}\n\nexport default def\n","'use strict';\n\nvar traverse = module.exports = function (schema, opts, cb) {\n  // Legacy support for v0.3.1 and earlier.\n  if (typeof opts == 'function') {\n    cb = opts;\n    opts = {};\n  }\n\n  cb = opts.cb || cb;\n  var pre = (typeof cb == 'function') ? cb : cb.pre || function() {};\n  var post = cb.post || function() {};\n\n  _traverse(opts, pre, post, schema, '', schema);\n};\n\n\ntraverse.keywords = {\n  additionalItems: true,\n  items: true,\n  contains: true,\n  additionalProperties: true,\n  propertyNames: true,\n  not: true,\n  if: true,\n  then: true,\n  else: true\n};\n\ntraverse.arrayKeywords = {\n  items: true,\n  allOf: true,\n  anyOf: true,\n  oneOf: true\n};\n\ntraverse.propsKeywords = {\n  $defs: true,\n  definitions: true,\n  properties: true,\n  patternProperties: true,\n  dependencies: true\n};\n\ntraverse.skipKeywords = {\n  default: true,\n  enum: true,\n  const: true,\n  required: true,\n  maximum: true,\n  minimum: true,\n  exclusiveMaximum: true,\n  exclusiveMinimum: true,\n  multipleOf: true,\n  maxLength: true,\n  minLength: true,\n  pattern: true,\n  format: true,\n  maxItems: true,\n  minItems: true,\n  uniqueItems: true,\n  maxProperties: true,\n  minProperties: true\n};\n\n\nfunction _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {\n  if (schema && typeof schema == 'object' && !Array.isArray(schema)) {\n    pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);\n    for (var key in schema) {\n      var sch = schema[key];\n      if (Array.isArray(sch)) {\n        if (key in traverse.arrayKeywords) {\n          for (var i=0; i<sch.length; i++)\n            _traverse(opts, pre, post, sch[i], jsonPtr + '/' + key + '/' + i, rootSchema, jsonPtr, key, schema, i);\n        }\n      } else if (key in traverse.propsKeywords) {\n        if (sch && typeof sch == 'object') {\n          for (var prop in sch)\n            _traverse(opts, pre, post, sch[prop], jsonPtr + '/' + key + '/' + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);\n        }\n      } else if (key in traverse.keywords || (opts.allKeys && !(key in traverse.skipKeywords))) {\n        _traverse(opts, pre, post, sch, jsonPtr + '/' + key, rootSchema, jsonPtr, key, schema);\n      }\n    }\n    post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);\n  }\n}\n\n\nfunction escapeJsonPtr(str) {\n  return str.replace(/~/g, '~0').replace(/\\//g, '~1');\n}\n","'use strict';\n\n// do not edit .js files directly - edit src/index.jst\n\n\n\nmodule.exports = function equal(a, b) {\n  if (a === b) return true;\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    if (a.constructor !== b.constructor) return false;\n\n    var length, i, keys;\n    if (Array.isArray(a)) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0;)\n        if (!equal(a[i], b[i])) return false;\n      return true;\n    }\n\n\n\n    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;\n    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\n    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();\n\n    keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) return false;\n\n    for (i = length; i-- !== 0;)\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n\n    for (i = length; i-- !== 0;) {\n      var key = keys[i];\n\n      if (!equal(a[key], b[key])) return false;\n    }\n\n    return true;\n  }\n\n  // true if both NaN, false otherwise\n  return a!==a && b!==b;\n};\n","export function merge(...sets:Array<string>):string {\n\tif (sets.length > 1) {\n\t\tsets[0] = sets[0].slice(0, -1);\n\t\tconst xl = sets.length - 1;\n\t\tfor (let x = 1; x < xl; ++x) {\n\t\t\tsets[x] = sets[x].slice(1, -1);\n\t\t}\n\t\tsets[xl] = sets[xl].slice(1);\n\t\treturn sets.join('');\n\t} else {\n\t\treturn sets[0];\n\t}\n}\n\nexport function subexp(str:string):string {\n\treturn \"(?:\" + str + \")\";\n}\n\nexport function typeOf(o:any):string {\n\treturn o === undefined ? \"undefined\" : (o === null ? \"null\" : Object.prototype.toString.call(o).split(\" \").pop().split(\"]\").shift().toLowerCase());\n}\n\nexport function toUpperCase(str:string):string {\n\treturn str.toUpperCase();\n}\n\nexport function toArray(obj:any):Array<any> {\n\treturn obj !== undefined && obj !== null ? (obj instanceof Array ? obj : (typeof obj.length !== \"number\" || obj.split || obj.setInterval || obj.call ? [obj] : Array.prototype.slice.call(obj))) : [];\n}\n\n\nexport function assign(target: object, source: any): any {\n\tconst obj = target as any;\n\tif (source) {\n\t\tfor (const key in source) {\n\t\t\tobj[key] = source[key];\n\t\t}\n\t}\n\treturn obj;\n}","import { URIRegExps } from \"./uri\";\nimport { merge, subexp } from \"./util\";\n\nexport function buildExps(isIRI:boolean):URIRegExps {\n\tconst\n\t\tALPHA$$ = \"[A-Za-z]\",\n\t\tCR$ = \"[\\\\x0D]\",\n\t\tDIGIT$$ = \"[0-9]\",\n\t\tDQUOTE$$ = \"[\\\\x22]\",\n\t\tHEXDIG$$ = merge(DIGIT$$, \"[A-Fa-f]\"),  //case-insensitive\n\t\tLF$$ = \"[\\\\x0A]\",\n\t\tSP$$ = \"[\\\\x20]\",\n\t\tPCT_ENCODED$ = subexp(subexp(\"%[EFef]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%[89A-Fa-f]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%\" + HEXDIG$$ + HEXDIG$$)),  //expanded\n\t\tGEN_DELIMS$$ = \"[\\\\:\\\\/\\\\?\\\\#\\\\[\\\\]\\\\@]\",\n\t\tSUB_DELIMS$$ = \"[\\\\!\\\\$\\\\&\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\;\\\\=]\",\n\t\tRESERVED$$ = merge(GEN_DELIMS$$, SUB_DELIMS$$),\n\t\tUCSCHAR$$ = isIRI ? \"[\\\\xA0-\\\\u200D\\\\u2010-\\\\u2029\\\\u202F-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFEF]\" : \"[]\",  //subset, excludes bidi control characters\n\t\tIPRIVATE$$ = isIRI ? \"[\\\\uE000-\\\\uF8FF]\" : \"[]\",  //subset\n\t\tUNRESERVED$$ = merge(ALPHA$$, DIGIT$$, \"[\\\\-\\\\.\\\\_\\\\~]\", UCSCHAR$$),\n\t\tSCHEME$ = subexp(ALPHA$$ + merge(ALPHA$$, DIGIT$$, \"[\\\\+\\\\-\\\\.]\") + \"*\"),\n\t\tUSERINFO$ = subexp(subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:]\")) + \"*\"),\n\t\tDEC_OCTET$ = subexp(subexp(\"25[0-5]\") + \"|\" + subexp(\"2[0-4]\" + DIGIT$$) + \"|\" + subexp(\"1\" + DIGIT$$ + DIGIT$$) + \"|\" + subexp(\"[1-9]\" + DIGIT$$) + \"|\" + DIGIT$$),\n\t\tDEC_OCTET_RELAXED$ = subexp(subexp(\"25[0-5]\") + \"|\" + subexp(\"2[0-4]\" + DIGIT$$) + \"|\" + subexp(\"1\" + DIGIT$$ + DIGIT$$) + \"|\" + subexp(\"0?[1-9]\" + DIGIT$$) + \"|0?0?\" + DIGIT$$),  //relaxed parsing rules\n\t\tIPV4ADDRESS$ = subexp(DEC_OCTET_RELAXED$ + \"\\\\.\" + DEC_OCTET_RELAXED$ + \"\\\\.\" + DEC_OCTET_RELAXED$ + \"\\\\.\" + DEC_OCTET_RELAXED$),\n\t\tH16$ = subexp(HEXDIG$$ + \"{1,4}\"),\n\t\tLS32$ = subexp(subexp(H16$ + \"\\\\:\" + H16$) + \"|\" + IPV4ADDRESS$),\n\t\tIPV6ADDRESS1$ = subexp(                                                            subexp(H16$ + \"\\\\:\") + \"{6}\" + LS32$), //                           6( h16 \":\" ) ls32\n\t\tIPV6ADDRESS2$ = subexp(                                                 \"\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{5}\" + LS32$), //                      \"::\" 5( h16 \":\" ) ls32\n\t\tIPV6ADDRESS3$ = subexp(subexp(                                 H16$) + \"?\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{4}\" + LS32$), //[               h16 ] \"::\" 4( h16 \":\" ) ls32\n\t\tIPV6ADDRESS4$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,1}\" + H16$) + \"?\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{3}\" + LS32$), //[ *1( h16 \":\" ) h16 ] \"::\" 3( h16 \":\" ) ls32\n\t\tIPV6ADDRESS5$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,2}\" + H16$) + \"?\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{2}\" + LS32$), //[ *2( h16 \":\" ) h16 ] \"::\" 2( h16 \":\" ) ls32\n\t\tIPV6ADDRESS6$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,3}\" + H16$) + \"?\\\\:\\\\:\" +        H16$ + \"\\\\:\"          + LS32$), //[ *3( h16 \":\" ) h16 ] \"::\"    h16 \":\"   ls32\n\t\tIPV6ADDRESS7$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,4}\" + H16$) + \"?\\\\:\\\\:\"                                + LS32$), //[ *4( h16 \":\" ) h16 ] \"::\"              ls32\n\t\tIPV6ADDRESS8$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,5}\" + H16$) + \"?\\\\:\\\\:\"                                + H16$ ), //[ *5( h16 \":\" ) h16 ] \"::\"              h16\n\t\tIPV6ADDRESS9$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,6}\" + H16$) + \"?\\\\:\\\\:\"                                       ), //[ *6( h16 \":\" ) h16 ] \"::\"\n\t\tIPV6ADDRESS$ = subexp([IPV6ADDRESS1$, IPV6ADDRESS2$, IPV6ADDRESS3$, IPV6ADDRESS4$, IPV6ADDRESS5$, IPV6ADDRESS6$, IPV6ADDRESS7$, IPV6ADDRESS8$, IPV6ADDRESS9$].join(\"|\")),\n\t\tZONEID$ = subexp(subexp(UNRESERVED$$ + \"|\" + PCT_ENCODED$) + \"+\"),  //RFC 6874\n\t\tIPV6ADDRZ$ = subexp(IPV6ADDRESS$ + \"\\\\%25\" + ZONEID$),  //RFC 6874\n\t\tIPV6ADDRZ_RELAXED$ = subexp(IPV6ADDRESS$ + subexp(\"\\\\%25|\\\\%(?!\" + HEXDIG$$ + \"{2})\") + ZONEID$),  //RFC 6874, with relaxed parsing rules\n\t\tIPVFUTURE$ = subexp(\"[vV]\" + HEXDIG$$ + \"+\\\\.\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:]\") + \"+\"),\n\t\tIP_LITERAL$ = subexp(\"\\\\[\" + subexp(IPV6ADDRZ_RELAXED$ + \"|\" + IPV6ADDRESS$ + \"|\" + IPVFUTURE$) + \"\\\\]\"),  //RFC 6874\n\t\tREG_NAME$ = subexp(subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$)) + \"*\"),\n\t\tHOST$ = subexp(IP_LITERAL$ + \"|\" + IPV4ADDRESS$ + \"(?!\" + REG_NAME$ + \")\" + \"|\" + REG_NAME$),\n\t\tPORT$ = subexp(DIGIT$$ + \"*\"),\n\t\tAUTHORITY$ = subexp(subexp(USERINFO$ + \"@\") + \"?\" + HOST$ + subexp(\"\\\\:\" + PORT$) + \"?\"),\n\t\tPCHAR$ = subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:\\\\@]\")),\n\t\tSEGMENT$ = subexp(PCHAR$ + \"*\"),\n\t\tSEGMENT_NZ$ = subexp(PCHAR$ + \"+\"),\n\t\tSEGMENT_NZ_NC$ = subexp(subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\@]\")) + \"+\"),\n\t\tPATH_ABEMPTY$ = subexp(subexp(\"\\\\/\" + SEGMENT$) + \"*\"),\n\t\tPATH_ABSOLUTE$ = subexp(\"\\\\/\" + subexp(SEGMENT_NZ$ + PATH_ABEMPTY$) + \"?\"),  //simplified\n\t\tPATH_NOSCHEME$ = subexp(SEGMENT_NZ_NC$ + PATH_ABEMPTY$),  //simplified\n\t\tPATH_ROOTLESS$ = subexp(SEGMENT_NZ$ + PATH_ABEMPTY$),  //simplified\n\t\tPATH_EMPTY$ = \"(?!\" + PCHAR$ + \")\",\n\t\tPATH$ = subexp(PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_NOSCHEME$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$),\n\t\tQUERY$ = subexp(subexp(PCHAR$ + \"|\" + merge(\"[\\\\/\\\\?]\", IPRIVATE$$)) + \"*\"),\n\t\tFRAGMENT$ = subexp(subexp(PCHAR$ + \"|[\\\\/\\\\?]\") + \"*\"),\n\t\tHIER_PART$ = subexp(subexp(\"\\\\/\\\\/\" + AUTHORITY$ + PATH_ABEMPTY$) + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$),\n\t\tURI$ = subexp(SCHEME$ + \"\\\\:\" + HIER_PART$ + subexp(\"\\\\?\" + QUERY$) + \"?\" + subexp(\"\\\\#\" + FRAGMENT$) + \"?\"),\n\t\tRELATIVE_PART$ = subexp(subexp(\"\\\\/\\\\/\" + AUTHORITY$ + PATH_ABEMPTY$) + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_NOSCHEME$ + \"|\" + PATH_EMPTY$),\n\t\tRELATIVE$ = subexp(RELATIVE_PART$ + subexp(\"\\\\?\" + QUERY$) + \"?\" + subexp(\"\\\\#\" + FRAGMENT$) + \"?\"),\n\t\tURI_REFERENCE$ = subexp(URI$ + \"|\" + RELATIVE$),\n\t\tABSOLUTE_URI$ = subexp(SCHEME$ + \"\\\\:\" + HIER_PART$ + subexp(\"\\\\?\" + QUERY$) + \"?\"),\n\n\t\tGENERIC_REF$ = \"^(\" + SCHEME$ + \")\\\\:\" + subexp(subexp(\"\\\\/\\\\/(\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?)\") + \"?(\" + PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$ + \")\") + subexp(\"\\\\?(\" + QUERY$ + \")\") + \"?\" + subexp(\"\\\\#(\" + FRAGMENT$ + \")\") + \"?$\",\n\t\tRELATIVE_REF$ = \"^(){0}\" + subexp(subexp(\"\\\\/\\\\/(\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?)\") + \"?(\" + PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_NOSCHEME$ + \"|\" + PATH_EMPTY$ + \")\") + subexp(\"\\\\?(\" + QUERY$ + \")\") + \"?\" + subexp(\"\\\\#(\" + FRAGMENT$ + \")\") + \"?$\",\n\t\tABSOLUTE_REF$ = \"^(\" + SCHEME$ + \")\\\\:\" + subexp(subexp(\"\\\\/\\\\/(\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?)\") + \"?(\" + PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$ + \")\") + subexp(\"\\\\?(\" + QUERY$ + \")\") + \"?$\",\n\t\tSAMEDOC_REF$ = \"^\" + subexp(\"\\\\#(\" + FRAGMENT$ + \")\") + \"?$\",\n\t\tAUTHORITY_REF$ = \"^\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?$\"\n\t;\n\n\treturn {\n\t\tNOT_SCHEME : new RegExp(merge(\"[^]\", ALPHA$$, DIGIT$$, \"[\\\\+\\\\-\\\\.]\"), \"g\"),\n\t\tNOT_USERINFO : new RegExp(merge(\"[^\\\\%\\\\:]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n\t\tNOT_HOST : new RegExp(merge(\"[^\\\\%\\\\[\\\\]\\\\:]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n\t\tNOT_PATH : new RegExp(merge(\"[^\\\\%\\\\/\\\\:\\\\@]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n\t\tNOT_PATH_NOSCHEME : new RegExp(merge(\"[^\\\\%\\\\/\\\\@]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n\t\tNOT_QUERY : new RegExp(merge(\"[^\\\\%]\", UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:\\\\@\\\\/\\\\?]\", IPRIVATE$$), \"g\"),\n\t\tNOT_FRAGMENT : new RegExp(merge(\"[^\\\\%]\", UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:\\\\@\\\\/\\\\?]\"), \"g\"),\n\t\tESCAPE : new RegExp(merge(\"[^]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n\t\tUNRESERVED : new RegExp(UNRESERVED$$, \"g\"),\n\t\tOTHER_CHARS : new RegExp(merge(\"[^\\\\%]\", UNRESERVED$$, RESERVED$$), \"g\"),\n\t\tPCT_ENCODED : new RegExp(PCT_ENCODED$, \"g\"),\n\t\tIPV4ADDRESS : new RegExp(\"^(\" + IPV4ADDRESS$ + \")$\"),\n\t\tIPV6ADDRESS : new RegExp(\"^\\\\[?(\" + IPV6ADDRESS$ + \")\" + subexp(subexp(\"\\\\%25|\\\\%(?!\" + HEXDIG$$ + \"{2})\") + \"(\" + ZONEID$ + \")\") + \"?\\\\]?$\")  //RFC 6874, with relaxed parsing rules\n\t};\n}\n\nexport default buildExps(false);\n","import { URIRegExps } from \"./uri\";\nimport { buildExps } from \"./regexps-uri\";\n\nexport default buildExps(true);\n","'use strict';\n\n/** Highest positive signed 32-bit float value */\nconst maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1\n\n/** Bootstring parameters */\nconst base = 36;\nconst tMin = 1;\nconst tMax = 26;\nconst skew = 38;\nconst damp = 700;\nconst initialBias = 72;\nconst initialN = 128; // 0x80\nconst delimiter = '-'; // '\\x2D'\n\n/** Regular expressions */\nconst regexPunycode = /^xn--/;\nconst regexNonASCII = /[^\\0-\\x7E]/; // non-ASCII chars\nconst regexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g; // RFC 3490 separators\n\n/** Error messages */\nconst errors = {\n\t'overflow': 'Overflow: input needs wider integers to process',\n\t'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\n\t'invalid-input': 'Invalid input'\n};\n\n/** Convenience shortcuts */\nconst baseMinusTMin = base - tMin;\nconst floor = Math.floor;\nconst stringFromCharCode = String.fromCharCode;\n\n/*--------------------------------------------------------------------------*/\n\n/**\n * A generic error utility function.\n * @private\n * @param {String} type The error type.\n * @returns {Error} Throws a `RangeError` with the applicable error message.\n */\nfunction error(type) {\n\tthrow new RangeError(errors[type]);\n}\n\n/**\n * A generic `Array#map` utility function.\n * @private\n * @param {Array} array The array to iterate over.\n * @param {Function} callback The function that gets called for every array\n * item.\n * @returns {Array} A new array of values returned by the callback function.\n */\nfunction map(array, fn) {\n\tconst result = [];\n\tlet length = array.length;\n\twhile (length--) {\n\t\tresult[length] = fn(array[length]);\n\t}\n\treturn result;\n}\n\n/**\n * A simple `Array#map`-like wrapper to work with domain name strings or email\n * addresses.\n * @private\n * @param {String} domain The domain name or email address.\n * @param {Function} callback The function that gets called for every\n * character.\n * @returns {Array} A new string of characters returned by the callback\n * function.\n */\nfunction mapDomain(string, fn) {\n\tconst parts = string.split('@');\n\tlet result = '';\n\tif (parts.length > 1) {\n\t\t// In email addresses, only the domain name should be punycoded. Leave\n\t\t// the local part (i.e. everything up to `@`) intact.\n\t\tresult = parts[0] + '@';\n\t\tstring = parts[1];\n\t}\n\t// Avoid `split(regex)` for IE8 compatibility. See #17.\n\tstring = string.replace(regexSeparators, '\\x2E');\n\tconst labels = string.split('.');\n\tconst encoded = map(labels, fn).join('.');\n\treturn result + encoded;\n}\n\n/**\n * Creates an array containing the numeric code points of each Unicode\n * character in the string. While JavaScript uses UCS-2 internally,\n * this function will convert a pair of surrogate halves (each of which\n * UCS-2 exposes as separate characters) into a single code point,\n * matching UTF-16.\n * @see `punycode.ucs2.encode`\n * @see <https://mathiasbynens.be/notes/javascript-encoding>\n * @memberOf punycode.ucs2\n * @name decode\n * @param {String} string The Unicode input string (UCS-2).\n * @returns {Array} The new array of code points.\n */\nfunction ucs2decode(string) {\n\tconst output = [];\n\tlet counter = 0;\n\tconst length = string.length;\n\twhile (counter < length) {\n\t\tconst value = string.charCodeAt(counter++);\n\t\tif (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n\t\t\t// It's a high surrogate, and there is a next character.\n\t\t\tconst extra = string.charCodeAt(counter++);\n\t\t\tif ((extra & 0xFC00) == 0xDC00) { // Low surrogate.\n\t\t\t\toutput.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n\t\t\t} else {\n\t\t\t\t// It's an unmatched surrogate; only append this code unit, in case the\n\t\t\t\t// next code unit is the high surrogate of a surrogate pair.\n\t\t\t\toutput.push(value);\n\t\t\t\tcounter--;\n\t\t\t}\n\t\t} else {\n\t\t\toutput.push(value);\n\t\t}\n\t}\n\treturn output;\n}\n\n/**\n * Creates a string based on an array of numeric code points.\n * @see `punycode.ucs2.decode`\n * @memberOf punycode.ucs2\n * @name encode\n * @param {Array} codePoints The array of numeric code points.\n * @returns {String} The new Unicode string (UCS-2).\n */\nconst ucs2encode = array => String.fromCodePoint(...array);\n\n/**\n * Converts a basic code point into a digit/integer.\n * @see `digitToBasic()`\n * @private\n * @param {Number} codePoint The basic numeric code point value.\n * @returns {Number} The numeric value of a basic code point (for use in\n * representing integers) in the range `0` to `base - 1`, or `base` if\n * the code point does not represent a value.\n */\nconst basicToDigit = function(codePoint) {\n\tif (codePoint - 0x30 < 0x0A) {\n\t\treturn codePoint - 0x16;\n\t}\n\tif (codePoint - 0x41 < 0x1A) {\n\t\treturn codePoint - 0x41;\n\t}\n\tif (codePoint - 0x61 < 0x1A) {\n\t\treturn codePoint - 0x61;\n\t}\n\treturn base;\n};\n\n/**\n * Converts a digit/integer into a basic code point.\n * @see `basicToDigit()`\n * @private\n * @param {Number} digit The numeric value of a basic code point.\n * @returns {Number} The basic code point whose value (when used for\n * representing integers) is `digit`, which needs to be in the range\n * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\n * used; else, the lowercase form is used. The behavior is undefined\n * if `flag` is non-zero and `digit` has no uppercase form.\n */\nconst digitToBasic = function(digit, flag) {\n\t//  0..25 map to ASCII a..z or A..Z\n\t// 26..35 map to ASCII 0..9\n\treturn digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n};\n\n/**\n * Bias adaptation function as per section 3.4 of RFC 3492.\n * https://tools.ietf.org/html/rfc3492#section-3.4\n * @private\n */\nconst adapt = function(delta, numPoints, firstTime) {\n\tlet k = 0;\n\tdelta = firstTime ? floor(delta / damp) : delta >> 1;\n\tdelta += floor(delta / numPoints);\n\tfor (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {\n\t\tdelta = floor(delta / baseMinusTMin);\n\t}\n\treturn floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n};\n\n/**\n * Converts a Punycode string of ASCII-only symbols to a string of Unicode\n * symbols.\n * @memberOf punycode\n * @param {String} input The Punycode string of ASCII-only symbols.\n * @returns {String} The resulting string of Unicode symbols.\n */\nconst decode = function(input) {\n\t// Don't use UCS-2.\n\tconst output = [];\n\tconst inputLength = input.length;\n\tlet i = 0;\n\tlet n = initialN;\n\tlet bias = initialBias;\n\n\t// Handle the basic code points: let `basic` be the number of input code\n\t// points before the last delimiter, or `0` if there is none, then copy\n\t// the first basic code points to the output.\n\n\tlet basic = input.lastIndexOf(delimiter);\n\tif (basic < 0) {\n\t\tbasic = 0;\n\t}\n\n\tfor (let j = 0; j < basic; ++j) {\n\t\t// if it's not a basic code point\n\t\tif (input.charCodeAt(j) >= 0x80) {\n\t\t\terror('not-basic');\n\t\t}\n\t\toutput.push(input.charCodeAt(j));\n\t}\n\n\t// Main decoding loop: start just after the last delimiter if any basic code\n\t// points were copied; start at the beginning otherwise.\n\n\tfor (let index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {\n\n\t\t// `index` is the index of the next character to be consumed.\n\t\t// Decode a generalized variable-length integer into `delta`,\n\t\t// which gets added to `i`. The overflow checking is easier\n\t\t// if we increase `i` as we go, then subtract off its starting\n\t\t// value at the end to obtain `delta`.\n\t\tlet oldi = i;\n\t\tfor (let w = 1, k = base; /* no condition */; k += base) {\n\n\t\t\tif (index >= inputLength) {\n\t\t\t\terror('invalid-input');\n\t\t\t}\n\n\t\t\tconst digit = basicToDigit(input.charCodeAt(index++));\n\n\t\t\tif (digit >= base || digit > floor((maxInt - i) / w)) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\ti += digit * w;\n\t\t\tconst t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\n\t\t\tif (digit < t) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tconst baseMinusT = base - t;\n\t\t\tif (w > floor(maxInt / baseMinusT)) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tw *= baseMinusT;\n\n\t\t}\n\n\t\tconst out = output.length + 1;\n\t\tbias = adapt(i - oldi, out, oldi == 0);\n\n\t\t// `i` was supposed to wrap around from `out` to `0`,\n\t\t// incrementing `n` each time, so we'll fix that now:\n\t\tif (floor(i / out) > maxInt - n) {\n\t\t\terror('overflow');\n\t\t}\n\n\t\tn += floor(i / out);\n\t\ti %= out;\n\n\t\t// Insert `n` at position `i` of the output.\n\t\toutput.splice(i++, 0, n);\n\n\t}\n\n\treturn String.fromCodePoint(...output);\n};\n\n/**\n * Converts a string of Unicode symbols (e.g. a domain name label) to a\n * Punycode string of ASCII-only symbols.\n * @memberOf punycode\n * @param {String} input The string of Unicode symbols.\n * @returns {String} The resulting Punycode string of ASCII-only symbols.\n */\nconst encode = function(input) {\n\tconst output = [];\n\n\t// Convert the input in UCS-2 to an array of Unicode code points.\n\tinput = ucs2decode(input);\n\n\t// Cache the length.\n\tlet inputLength = input.length;\n\n\t// Initialize the state.\n\tlet n = initialN;\n\tlet delta = 0;\n\tlet bias = initialBias;\n\n\t// Handle the basic code points.\n\tfor (const currentValue of input) {\n\t\tif (currentValue < 0x80) {\n\t\t\toutput.push(stringFromCharCode(currentValue));\n\t\t}\n\t}\n\n\tlet basicLength = output.length;\n\tlet handledCPCount = basicLength;\n\n\t// `handledCPCount` is the number of code points that have been handled;\n\t// `basicLength` is the number of basic code points.\n\n\t// Finish the basic string with a delimiter unless it's empty.\n\tif (basicLength) {\n\t\toutput.push(delimiter);\n\t}\n\n\t// Main encoding loop:\n\twhile (handledCPCount < inputLength) {\n\n\t\t// All non-basic code points < n have been handled already. Find the next\n\t\t// larger one:\n\t\tlet m = maxInt;\n\t\tfor (const currentValue of input) {\n\t\t\tif (currentValue >= n && currentValue < m) {\n\t\t\t\tm = currentValue;\n\t\t\t}\n\t\t}\n\n\t\t// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\n\t\t// but guard against overflow.\n\t\tconst handledCPCountPlusOne = handledCPCount + 1;\n\t\tif (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n\t\t\terror('overflow');\n\t\t}\n\n\t\tdelta += (m - n) * handledCPCountPlusOne;\n\t\tn = m;\n\n\t\tfor (const currentValue of input) {\n\t\t\tif (currentValue < n && ++delta > maxInt) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\t\t\tif (currentValue == n) {\n\t\t\t\t// Represent delta as a generalized variable-length integer.\n\t\t\t\tlet q = delta;\n\t\t\t\tfor (let k = base; /* no condition */; k += base) {\n\t\t\t\t\tconst t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\t\t\t\t\tif (q < t) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tconst qMinusT = q - t;\n\t\t\t\t\tconst baseMinusT = base - t;\n\t\t\t\t\toutput.push(\n\t\t\t\t\t\tstringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))\n\t\t\t\t\t);\n\t\t\t\t\tq = floor(qMinusT / baseMinusT);\n\t\t\t\t}\n\n\t\t\t\toutput.push(stringFromCharCode(digitToBasic(q, 0)));\n\t\t\t\tbias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n\t\t\t\tdelta = 0;\n\t\t\t\t++handledCPCount;\n\t\t\t}\n\t\t}\n\n\t\t++delta;\n\t\t++n;\n\n\t}\n\treturn output.join('');\n};\n\n/**\n * Converts a Punycode string representing a domain name or an email address\n * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\n * it doesn't matter if you call it on a string that has already been\n * converted to Unicode.\n * @memberOf punycode\n * @param {String} input The Punycoded domain name or email address to\n * convert to Unicode.\n * @returns {String} The Unicode representation of the given Punycode\n * string.\n */\nconst toUnicode = function(input) {\n\treturn mapDomain(input, function(string) {\n\t\treturn regexPunycode.test(string)\n\t\t\t? decode(string.slice(4).toLowerCase())\n\t\t\t: string;\n\t});\n};\n\n/**\n * Converts a Unicode string representing a domain name or an email address to\n * Punycode. Only the non-ASCII parts of the domain name will be converted,\n * i.e. it doesn't matter if you call it with a domain that's already in\n * ASCII.\n * @memberOf punycode\n * @param {String} input The domain name or email address to convert, as a\n * Unicode string.\n * @returns {String} The Punycode representation of the given domain name or\n * email address.\n */\nconst toASCII = function(input) {\n\treturn mapDomain(input, function(string) {\n\t\treturn regexNonASCII.test(string)\n\t\t\t? 'xn--' + encode(string)\n\t\t\t: string;\n\t});\n};\n\n/*--------------------------------------------------------------------------*/\n\n/** Define the public API */\nconst punycode = {\n\t/**\n\t * A string representing the current Punycode.js version number.\n\t * @memberOf punycode\n\t * @type String\n\t */\n\t'version': '2.1.0',\n\t/**\n\t * An object of methods to convert from JavaScript's internal character\n\t * representation (UCS-2) to Unicode code points, and back.\n\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t * @memberOf punycode\n\t * @type Object\n\t */\n\t'ucs2': {\n\t\t'decode': ucs2decode,\n\t\t'encode': ucs2encode\n\t},\n\t'decode': decode,\n\t'encode': encode,\n\t'toASCII': toASCII,\n\t'toUnicode': toUnicode\n};\n\nexport default punycode;\n","/**\n * URI.js\n *\n * @fileoverview An RFC 3986 compliant, scheme extendable URI parsing/validating/resolving library for JavaScript.\n * @author <a href=\"mailto:gary.court@gmail.com\">Gary Court</a>\n * @see http://github.com/garycourt/uri-js\n */\n\n/**\n * Copyright 2011 Gary Court. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification, are\n * permitted provided that the following conditions are met:\n *\n *    1. Redistributions of source code must retain the above copyright notice, this list of\n *       conditions and the following disclaimer.\n *\n *    2. Redistributions in binary form must reproduce the above copyright notice, this list\n *       of conditions and the following disclaimer in the documentation and/or other materials\n *       provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY GARY COURT ``AS IS'' AND ANY EXPRESS OR IMPLIED\n * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GARY COURT OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\n * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * The views and conclusions contained in the software and documentation are those of the\n * authors and should not be interpreted as representing official policies, either expressed\n * or implied, of Gary Court.\n */\n\nimport URI_PROTOCOL from \"./regexps-uri\";\nimport IRI_PROTOCOL from \"./regexps-iri\";\nimport punycode from \"punycode\";\nimport { toUpperCase, typeOf, assign } from \"./util\";\n\nexport interface URIComponents {\n\tscheme?:string;\n\tuserinfo?:string;\n\thost?:string;\n\tport?:number|string;\n\tpath?:string;\n\tquery?:string;\n\tfragment?:string;\n\treference?:string;\n\terror?:string;\n}\n\nexport interface URIOptions {\n\tscheme?:string;\n\treference?:string;\n\ttolerant?:boolean;\n\tabsolutePath?:boolean;\n\tiri?:boolean;\n\tunicodeSupport?:boolean;\n\tdomainHost?:boolean;\n}\n\nexport interface URISchemeHandler<Components extends URIComponents = URIComponents, Options extends URIOptions = URIOptions, ParentComponents extends URIComponents = URIComponents> {\n\tscheme:string;\n\tparse(components:ParentComponents, options:Options):Components;\n\tserialize(components:Components, options:Options):ParentComponents;\n\tunicodeSupport?:boolean;\n\tdomainHost?:boolean;\n\tabsolutePath?:boolean;\n}\n\nexport interface URIRegExps {\n\tNOT_SCHEME : RegExp,\n\tNOT_USERINFO : RegExp,\n\tNOT_HOST : RegExp,\n\tNOT_PATH : RegExp,\n\tNOT_PATH_NOSCHEME : RegExp,\n\tNOT_QUERY : RegExp,\n\tNOT_FRAGMENT : RegExp,\n\tESCAPE : RegExp,\n\tUNRESERVED : RegExp,\n\tOTHER_CHARS : RegExp,\n\tPCT_ENCODED : RegExp,\n\tIPV4ADDRESS : RegExp,\n\tIPV6ADDRESS : RegExp,\n}\n\nexport const SCHEMES:{[scheme:string]:URISchemeHandler} = {};\n\nexport function pctEncChar(chr:string):string {\n\tconst c = chr.charCodeAt(0);\n\tlet e:string;\n\n\tif (c < 16) e = \"%0\" + c.toString(16).toUpperCase();\n\telse if (c < 128) e = \"%\" + c.toString(16).toUpperCase();\n\telse if (c < 2048) e = \"%\" + ((c >> 6) | 192).toString(16).toUpperCase() + \"%\" + ((c & 63) | 128).toString(16).toUpperCase();\n\telse e = \"%\" + ((c >> 12) | 224).toString(16).toUpperCase() + \"%\" + (((c >> 6) & 63) | 128).toString(16).toUpperCase() + \"%\" + ((c & 63) | 128).toString(16).toUpperCase();\n\n\treturn e;\n}\n\nexport function pctDecChars(str:string):string {\n\tlet newStr = \"\";\n\tlet i = 0;\n\tconst il = str.length;\n\n\twhile (i < il) {\n\t\tconst c = parseInt(str.substr(i + 1, 2), 16);\n\n\t\tif (c < 128) {\n\t\t\tnewStr += String.fromCharCode(c);\n\t\t\ti += 3;\n\t\t}\n\t\telse if (c >= 194 && c < 224) {\n\t\t\tif ((il - i) >= 6) {\n\t\t\t\tconst c2 = parseInt(str.substr(i + 4, 2), 16);\n\t\t\t\tnewStr += String.fromCharCode(((c & 31) << 6) | (c2 & 63));\n\t\t\t} else {\n\t\t\t\tnewStr += str.substr(i, 6);\n\t\t\t}\n\t\t\ti += 6;\n\t\t}\n\t\telse if (c >= 224) {\n\t\t\tif ((il - i) >= 9) {\n\t\t\t\tconst c2 = parseInt(str.substr(i + 4, 2), 16);\n\t\t\t\tconst c3 = parseInt(str.substr(i + 7, 2), 16);\n\t\t\t\tnewStr += String.fromCharCode(((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));\n\t\t\t} else {\n\t\t\t\tnewStr += str.substr(i, 9);\n\t\t\t}\n\t\t\ti += 9;\n\t\t}\n\t\telse {\n\t\t\tnewStr += str.substr(i, 3);\n\t\t\ti += 3;\n\t\t}\n\t}\n\n\treturn newStr;\n}\n\nfunction _normalizeComponentEncoding(components:URIComponents, protocol:URIRegExps) {\n\tfunction decodeUnreserved(str:string):string {\n\t\tconst decStr = pctDecChars(str);\n\t\treturn (!decStr.match(protocol.UNRESERVED) ? str : decStr);\n\t}\n\n\tif (components.scheme) components.scheme = String(components.scheme).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_SCHEME, \"\");\n\tif (components.userinfo !== undefined) components.userinfo = String(components.userinfo).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_USERINFO, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n\tif (components.host !== undefined) components.host = String(components.host).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_HOST, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n\tif (components.path !== undefined) components.path = String(components.path).replace(protocol.PCT_ENCODED, decodeUnreserved).replace((components.scheme ? protocol.NOT_PATH : protocol.NOT_PATH_NOSCHEME), pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n\tif (components.query !== undefined) components.query = String(components.query).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_QUERY, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n\tif (components.fragment !== undefined) components.fragment = String(components.fragment).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_FRAGMENT, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n\n\treturn components;\n};\n\nfunction _stripLeadingZeros(str:string):string {\n\treturn str.replace(/^0*(.*)/, \"$1\") || \"0\";\n}\n\nfunction _normalizeIPv4(host:string, protocol:URIRegExps):string {\n\tconst matches = host.match(protocol.IPV4ADDRESS) || [];\n\tconst [, address] = matches;\n\t\n\tif (address) {\n\t\treturn address.split(\".\").map(_stripLeadingZeros).join(\".\");\n\t} else {\n\t\treturn host;\n\t}\n}\n\nfunction _normalizeIPv6(host:string, protocol:URIRegExps):string {\n\tconst matches = host.match(protocol.IPV6ADDRESS) || [];\n\tconst [, address, zone] = matches;\n\n\tif (address) {\n\t\tconst [last, first] = address.toLowerCase().split('::').reverse();\n\t\tconst firstFields = first ? first.split(\":\").map(_stripLeadingZeros) : [];\n\t\tconst lastFields = last.split(\":\").map(_stripLeadingZeros);\n\t\tconst isLastFieldIPv4Address = protocol.IPV4ADDRESS.test(lastFields[lastFields.length - 1]);\n\t\tconst fieldCount = isLastFieldIPv4Address ? 7 : 8;\n\t\tconst lastFieldsStart = lastFields.length - fieldCount;\n\t\tconst fields = Array<string>(fieldCount);\n\n\t\tfor (let x = 0; x < fieldCount; ++x) {\n\t\t\tfields[x] = firstFields[x] || lastFields[lastFieldsStart + x] || '';\n\t\t}\n\n\t\tif (isLastFieldIPv4Address) {\n\t\t\tfields[fieldCount - 1] = _normalizeIPv4(fields[fieldCount - 1], protocol);\n\t\t}\n\n\t\tconst allZeroFields = fields.reduce<Array<{index:number,length:number}>>((acc, field, index) => {\n\t\t\tif (!field || field === \"0\") {\n\t\t\t\tconst lastLongest = acc[acc.length - 1];\n\t\t\t\tif (lastLongest && lastLongest.index + lastLongest.length === index) {\n\t\t\t\t\tlastLongest.length++;\n\t\t\t\t} else {\n\t\t\t\t\tacc.push({ index, length : 1 });\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn acc;\n\t\t}, []);\n\n\t\tconst longestZeroFields = allZeroFields.sort((a, b) => b.length - a.length)[0];\n\n\t\tlet newHost:string;\n\t\tif (longestZeroFields && longestZeroFields.length > 1) {\n\t\t\tconst newFirst = fields.slice(0, longestZeroFields.index) ;\n\t\t\tconst newLast = fields.slice(longestZeroFields.index + longestZeroFields.length);\n\t\t\tnewHost = newFirst.join(\":\") + \"::\" + newLast.join(\":\");\n\t\t} else {\n\t\t\tnewHost = fields.join(\":\");\n\t\t}\n\n\t\tif (zone) {\n\t\t\tnewHost += \"%\" + zone;\n\t\t}\n\n\t\treturn newHost;\n\t} else {\n\t\treturn host;\n\t}\n}\n\nconst URI_PARSE = /^(?:([^:\\/?#]+):)?(?:\\/\\/((?:([^\\/?#@]*)@)?(\\[[^\\/?#\\]]+\\]|[^\\/?#:]*)(?:\\:(\\d*))?))?([^?#]*)(?:\\?([^#]*))?(?:#((?:.|\\n|\\r)*))?/i;\nconst NO_MATCH_IS_UNDEFINED = (<RegExpMatchArray>(\"\").match(/(){0}/))[1] === undefined;\n\nexport function parse(uriString:string, options:URIOptions = {}):URIComponents {\n\tconst components:URIComponents = {};\n\tconst protocol = (options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL);\n\n\tif (options.reference === \"suffix\") uriString = (options.scheme ? options.scheme + \":\" : \"\") + \"//\" + uriString;\n\n\tconst matches = uriString.match(URI_PARSE);\n\n\tif (matches) {\n\t\tif (NO_MATCH_IS_UNDEFINED) {\n\t\t\t//store each component\n\t\t\tcomponents.scheme = matches[1];\n\t\t\tcomponents.userinfo = matches[3];\n\t\t\tcomponents.host = matches[4];\n\t\t\tcomponents.port = parseInt(matches[5], 10);\n\t\t\tcomponents.path = matches[6] || \"\";\n\t\t\tcomponents.query = matches[7];\n\t\t\tcomponents.fragment = matches[8];\n\n\t\t\t//fix port number\n\t\t\tif (isNaN(components.port)) {\n\t\t\t\tcomponents.port = matches[5];\n\t\t\t}\n\t\t} else {  //IE FIX for improper RegExp matching\n\t\t\t//store each component\n\t\t\tcomponents.scheme = matches[1] || undefined;\n\t\t\tcomponents.userinfo = (uriString.indexOf(\"@\") !== -1 ? matches[3] : undefined);\n\t\t\tcomponents.host = (uriString.indexOf(\"//\") !== -1 ? matches[4] : undefined);\n\t\t\tcomponents.port = parseInt(matches[5], 10);\n\t\t\tcomponents.path = matches[6] || \"\";\n\t\t\tcomponents.query = (uriString.indexOf(\"?\") !== -1 ? matches[7] : undefined);\n\t\t\tcomponents.fragment = (uriString.indexOf(\"#\") !== -1 ? matches[8] : undefined);\n\n\t\t\t//fix port number\n\t\t\tif (isNaN(components.port)) {\n\t\t\t\tcomponents.port = (uriString.match(/\\/\\/(?:.|\\n)*\\:(?:\\/|\\?|\\#|$)/) ? matches[4] : undefined);\n\t\t\t}\n\t\t}\n\n\t\tif (components.host) {\n\t\t\t//normalize IP hosts\n\t\t\tcomponents.host = _normalizeIPv6(_normalizeIPv4(components.host, protocol), protocol);\n\t\t}\n\n\t\t//determine reference type\n\t\tif (components.scheme === undefined && components.userinfo === undefined && components.host === undefined && components.port === undefined && !components.path && components.query === undefined) {\n\t\t\tcomponents.reference = \"same-document\";\n\t\t} else if (components.scheme === undefined) {\n\t\t\tcomponents.reference = \"relative\";\n\t\t} else if (components.fragment === undefined) {\n\t\t\tcomponents.reference = \"absolute\";\n\t\t} else {\n\t\t\tcomponents.reference = \"uri\";\n\t\t}\n\n\t\t//check for reference errors\n\t\tif (options.reference && options.reference !== \"suffix\" && options.reference !== components.reference) {\n\t\t\tcomponents.error = components.error || \"URI is not a \" + options.reference + \" reference.\";\n\t\t}\n\n\t\t//find scheme handler\n\t\tconst schemeHandler = SCHEMES[(options.scheme || components.scheme || \"\").toLowerCase()];\n\n\t\t//check if scheme can't handle IRIs\n\t\tif (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {\n\t\t\t//if host component is a domain name\n\t\t\tif (components.host && (options.domainHost || (schemeHandler && schemeHandler.domainHost))) {\n\t\t\t\t//convert Unicode IDN -> ASCII IDN\n\t\t\t\ttry {\n\t\t\t\t\tcomponents.host = punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase());\n\t\t\t\t} catch (e) {\n\t\t\t\t\tcomponents.error = components.error || \"Host's domain name can not be converted to ASCII via punycode: \" + e;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//convert IRI -> URI\n\t\t\t_normalizeComponentEncoding(components, URI_PROTOCOL);\n\t\t} else {\n\t\t\t//normalize encodings\n\t\t\t_normalizeComponentEncoding(components, protocol);\n\t\t}\n\n\t\t//perform scheme specific parsing\n\t\tif (schemeHandler && schemeHandler.parse) {\n\t\t\tschemeHandler.parse(components, options);\n\t\t}\n\t} else {\n\t\tcomponents.error = components.error || \"URI can not be parsed.\";\n\t}\n\n\treturn components;\n};\n\nfunction _recomposeAuthority(components:URIComponents, options:URIOptions):string|undefined {\n\tconst protocol = (options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL);\n\tconst uriTokens:Array<string> = [];\n\n\tif (components.userinfo !== undefined) {\n\t\turiTokens.push(components.userinfo);\n\t\turiTokens.push(\"@\");\n\t}\n\n\tif (components.host !== undefined) {\n\t\t//normalize IP hosts, add brackets and escape zone separator for IPv6\n\t\turiTokens.push(_normalizeIPv6(_normalizeIPv4(String(components.host), protocol), protocol).replace(protocol.IPV6ADDRESS, (_, $1, $2) => \"[\" + $1 + ($2 ? \"%25\" + $2 : \"\") + \"]\"));\n\t}\n\n\tif (typeof components.port === \"number\" || typeof components.port === \"string\") {\n\t\turiTokens.push(\":\");\n\t\turiTokens.push(String(components.port));\n\t}\n\n\treturn uriTokens.length ? uriTokens.join(\"\") : undefined;\n};\n\nconst RDS1 = /^\\.\\.?\\//;\nconst RDS2 = /^\\/\\.(\\/|$)/;\nconst RDS3 = /^\\/\\.\\.(\\/|$)/;\nconst RDS4 = /^\\.\\.?$/;\nconst RDS5 = /^\\/?(?:.|\\n)*?(?=\\/|$)/;\n\nexport function removeDotSegments(input:string):string {\n\tconst output:Array<string> = [];\n\n\twhile (input.length) {\n\t\tif (input.match(RDS1)) {\n\t\t\tinput = input.replace(RDS1, \"\");\n\t\t} else if (input.match(RDS2)) {\n\t\t\tinput = input.replace(RDS2, \"/\");\n\t\t} else if (input.match(RDS3)) {\n\t\t\tinput = input.replace(RDS3, \"/\");\n\t\t\toutput.pop();\n\t\t} else if (input === \".\" || input === \"..\") {\n\t\t\tinput = \"\";\n\t\t} else {\n\t\t\tconst im = input.match(RDS5);\n\t\t\tif (im) {\n\t\t\t\tconst s = im[0];\n\t\t\t\tinput = input.slice(s.length);\n\t\t\t\toutput.push(s);\n\t\t\t} else {\n\t\t\t\tthrow new Error(\"Unexpected dot segment condition\");\n\t\t\t}\n\t\t}\n\t}\n\n\treturn output.join(\"\");\n};\n\nexport function serialize(components:URIComponents, options:URIOptions = {}):string {\n\tconst protocol = (options.iri ? IRI_PROTOCOL : URI_PROTOCOL);\n\tconst uriTokens:Array<string> = [];\n\n\t//find scheme handler\n\tconst schemeHandler = SCHEMES[(options.scheme || components.scheme || \"\").toLowerCase()];\n\n\t//perform scheme specific serialization\n\tif (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(components, options);\n\n\tif (components.host) {\n\t\t//if host component is an IPv6 address\n\t\tif (protocol.IPV6ADDRESS.test(components.host)) {\n\t\t\t//TODO: normalize IPv6 address as per RFC 5952\n\t\t}\n\n\t\t//if host component is a domain name\n\t\telse if (options.domainHost || (schemeHandler && schemeHandler.domainHost)) {\n\t\t\t//convert IDN via punycode\n\t\t\ttry {\n\t\t\t\tcomponents.host = (!options.iri ? punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase()) : punycode.toUnicode(components.host));\n\t\t\t} catch (e) {\n\t\t\t\tcomponents.error = components.error || \"Host's domain name can not be converted to \" + (!options.iri ? \"ASCII\" : \"Unicode\") + \" via punycode: \" + e;\n\t\t\t}\n\t\t}\n\t}\n\n\t//normalize encoding\n\t_normalizeComponentEncoding(components, protocol);\n\n\tif (options.reference !== \"suffix\" && components.scheme) {\n\t\turiTokens.push(components.scheme);\n\t\turiTokens.push(\":\");\n\t}\n\n\tconst authority = _recomposeAuthority(components, options);\n\tif (authority !== undefined) {\n\t\tif (options.reference !== \"suffix\") {\n\t\t\turiTokens.push(\"//\");\n\t\t}\n\n\t\turiTokens.push(authority);\n\n\t\tif (components.path && components.path.charAt(0) !== \"/\") {\n\t\t\turiTokens.push(\"/\");\n\t\t}\n\t}\n\n\tif (components.path !== undefined) {\n\t\tlet s = components.path;\n\n\t\tif (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {\n\t\t\ts = removeDotSegments(s);\n\t\t}\n\n\t\tif (authority === undefined) {\n\t\t\ts = s.replace(/^\\/\\//, \"/%2F\");  //don't allow the path to start with \"//\"\n\t\t}\n\n\t\turiTokens.push(s);\n\t}\n\n\tif (components.query !== undefined) {\n\t\turiTokens.push(\"?\");\n\t\turiTokens.push(components.query);\n\t}\n\n\tif (components.fragment !== undefined) {\n\t\turiTokens.push(\"#\");\n\t\turiTokens.push(components.fragment);\n\t}\n\n\treturn uriTokens.join(\"\");  //merge tokens into a string\n};\n\nexport function resolveComponents(base:URIComponents, relative:URIComponents, options:URIOptions = {}, skipNormalization?:boolean):URIComponents {\n\tconst target:URIComponents = {};\n\n\tif (!skipNormalization) {\n\t\tbase = parse(serialize(base, options), options);  //normalize base components\n\t\trelative = parse(serialize(relative, options), options);  //normalize relative components\n\t}\n\toptions = options || {};\n\n\tif (!options.tolerant && relative.scheme) {\n\t\ttarget.scheme = relative.scheme;\n\t\t//target.authority = relative.authority;\n\t\ttarget.userinfo = relative.userinfo;\n\t\ttarget.host = relative.host;\n\t\ttarget.port = relative.port;\n\t\ttarget.path = removeDotSegments(relative.path || \"\");\n\t\ttarget.query = relative.query;\n\t} else {\n\t\tif (relative.userinfo !== undefined || relative.host !== undefined || relative.port !== undefined) {\n\t\t\t//target.authority = relative.authority;\n\t\t\ttarget.userinfo = relative.userinfo;\n\t\t\ttarget.host = relative.host;\n\t\t\ttarget.port = relative.port;\n\t\t\ttarget.path = removeDotSegments(relative.path || \"\");\n\t\t\ttarget.query = relative.query;\n\t\t} else {\n\t\t\tif (!relative.path) {\n\t\t\t\ttarget.path = base.path;\n\t\t\t\tif (relative.query !== undefined) {\n\t\t\t\t\ttarget.query = relative.query;\n\t\t\t\t} else {\n\t\t\t\t\ttarget.query = base.query;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (relative.path.charAt(0) === \"/\") {\n\t\t\t\t\ttarget.path = removeDotSegments(relative.path);\n\t\t\t\t} else {\n\t\t\t\t\tif ((base.userinfo !== undefined || base.host !== undefined || base.port !== undefined) && !base.path) {\n\t\t\t\t\t\ttarget.path = \"/\" + relative.path;\n\t\t\t\t\t} else if (!base.path) {\n\t\t\t\t\t\ttarget.path = relative.path;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttarget.path = base.path.slice(0, base.path.lastIndexOf(\"/\") + 1) + relative.path;\n\t\t\t\t\t}\n\t\t\t\t\ttarget.path = removeDotSegments(target.path);\n\t\t\t\t}\n\t\t\t\ttarget.query = relative.query;\n\t\t\t}\n\t\t\t//target.authority = base.authority;\n\t\t\ttarget.userinfo = base.userinfo;\n\t\t\ttarget.host = base.host;\n\t\t\ttarget.port = base.port;\n\t\t}\n\t\ttarget.scheme = base.scheme;\n\t}\n\n\ttarget.fragment = relative.fragment;\n\n\treturn target;\n};\n\nexport function resolve(baseURI:string, relativeURI:string, options?:URIOptions):string {\n\tconst schemelessOptions = assign({ scheme : 'null' }, options);\n\treturn serialize(resolveComponents(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true), schemelessOptions);\n};\n\nexport function normalize(uri:string, options?:URIOptions):string;\nexport function normalize(uri:URIComponents, options?:URIOptions):URIComponents;\nexport function normalize(uri:any, options?:URIOptions):any {\n\tif (typeof uri === \"string\") {\n\t\turi = serialize(parse(uri, options), options);\n\t} else if (typeOf(uri) === \"object\") {\n\t\turi = parse(serialize(<URIComponents>uri, options), options);\n\t}\n\n\treturn uri;\n};\n\nexport function equal(uriA:string, uriB:string, options?: URIOptions):boolean;\nexport function equal(uriA:URIComponents, uriB:URIComponents, options?:URIOptions):boolean;\nexport function equal(uriA:any, uriB:any, options?:URIOptions):boolean {\n\tif (typeof uriA === \"string\") {\n\t\turiA = serialize(parse(uriA, options), options);\n\t} else if (typeOf(uriA) === \"object\") {\n\t\turiA = serialize(<URIComponents>uriA, options);\n\t}\n\n\tif (typeof uriB === \"string\") {\n\t\turiB = serialize(parse(uriB, options), options);\n\t} else if (typeOf(uriB) === \"object\") {\n\t\turiB = serialize(<URIComponents>uriB, options);\n\t}\n\n\treturn uriA === uriB;\n};\n\nexport function escapeComponent(str:string, options?:URIOptions):string {\n\treturn str && str.toString().replace((!options || !options.iri ? URI_PROTOCOL.ESCAPE : IRI_PROTOCOL.ESCAPE), pctEncChar);\n};\n\nexport function unescapeComponent(str:string, options?:URIOptions):string {\n\treturn str && str.toString().replace((!options || !options.iri ? URI_PROTOCOL.PCT_ENCODED : IRI_PROTOCOL.PCT_ENCODED), pctDecChars);\n};\n","import { URISchemeHandler, URIComponents, URIOptions } from \"../uri\";\n\nconst handler:URISchemeHandler = {\n\tscheme : \"http\",\n\n\tdomainHost : true,\n\n\tparse : function (components:URIComponents, options:URIOptions):URIComponents {\n\t\t//report missing host\n\t\tif (!components.host) {\n\t\t\tcomponents.error = components.error || \"HTTP URIs must have a host.\";\n\t\t}\n\n\t\treturn components;\n\t},\n\n\tserialize : function (components:URIComponents, options:URIOptions):URIComponents {\n\t\tconst secure = String(components.scheme).toLowerCase() === \"https\";\n\n\t\t//normalize the default port\n\t\tif (components.port === (secure ? 443 : 80) || components.port === \"\") {\n\t\t\tcomponents.port = undefined;\n\t\t}\n\t\t\n\t\t//normalize the empty path\n\t\tif (!components.path) {\n\t\t\tcomponents.path = \"/\";\n\t\t}\n\n\t\t//NOTE: We do not parse query strings for HTTP URIs\n\t\t//as WWW Form Url Encoded query strings are part of the HTML4+ spec,\n\t\t//and not the HTTP spec.\n\n\t\treturn components;\n\t}\n};\n\nexport default handler;","import { URISchemeHandler, URIComponents, URIOptions } from \"../uri\";\nimport http from \"./http\";\n\nconst handler:URISchemeHandler = {\n\tscheme : \"https\",\n\tdomainHost : http.domainHost,\n\tparse : http.parse,\n\tserialize : http.serialize\n}\n\nexport default handler;","import { URISchemeHandler, URIComponents, URIOptions } from \"../uri\";\n\nexport interface WSComponents extends URIComponents {\n\tresourceName?: string;\n\tsecure?: boolean;\n}\n\nfunction isSecure(wsComponents:WSComponents):boolean {\n\treturn typeof wsComponents.secure === 'boolean' ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === \"wss\";\n}\n\n//RFC 6455\nconst handler:URISchemeHandler = {\n\tscheme : \"ws\",\n\n\tdomainHost : true,\n\n\tparse : function (components:URIComponents, options:URIOptions):WSComponents {\n\t\tconst wsComponents = components as WSComponents;\n\n\t\t//indicate if the secure flag is set\n\t\twsComponents.secure = isSecure(wsComponents);\n\n\t\t//construct resouce name\n\t\twsComponents.resourceName = (wsComponents.path || '/') + (wsComponents.query ? '?' + wsComponents.query : '');\n\t\twsComponents.path = undefined;\n\t\twsComponents.query = undefined;\n\n\t\treturn wsComponents;\n\t},\n\n\tserialize : function (wsComponents:WSComponents, options:URIOptions):URIComponents {\n\t\t//normalize the default port\n\t\tif (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === \"\") {\n\t\t\twsComponents.port = undefined;\n\t\t}\n\n\t\t//ensure scheme matches secure flag\n\t\tif (typeof wsComponents.secure === 'boolean') {\n\t\t\twsComponents.scheme = (wsComponents.secure ? 'wss' : 'ws');\n\t\t\twsComponents.secure = undefined;\n\t\t}\n\n\t\t//reconstruct path from resource name\n\t\tif (wsComponents.resourceName) {\n\t\t\tconst [path, query] = wsComponents.resourceName.split('?');\n\t\t\twsComponents.path = (path && path !== '/' ? path : undefined);\n\t\t\twsComponents.query = query;\n\t\t\twsComponents.resourceName = undefined;\n\t\t}\n\n\t\t//forbid fragment component\n\t\twsComponents.fragment = undefined;\n\n\t\treturn wsComponents;\n\t}\n};\n\nexport default handler;","import { URISchemeHandler, URIComponents, URIOptions } from \"../uri\";\nimport ws from \"./ws\";\n\nconst handler:URISchemeHandler = {\n\tscheme : \"wss\",\n\tdomainHost : ws.domainHost,\n\tparse : ws.parse,\n\tserialize : ws.serialize\n}\n\nexport default handler;","import { URISchemeHandler, URIComponents, URIOptions } from \"../uri\";\nimport { pctEncChar, pctDecChars, unescapeComponent } from \"../uri\";\nimport punycode from \"punycode\";\nimport { merge, subexp, toUpperCase, toArray } from \"../util\";\n\nexport interface MailtoHeaders {\n\t[hfname:string]:string\n}\n\nexport interface MailtoComponents extends URIComponents {\n\tto:Array<string>,\n\theaders?:MailtoHeaders,\n\tsubject?:string,\n\tbody?:string\n}\n\nconst O:MailtoHeaders = {};\nconst isIRI = true;\n\n//RFC 3986\nconst UNRESERVED$$ = \"[A-Za-z0-9\\\\-\\\\.\\\\_\\\\~\" + (isIRI ? \"\\\\xA0-\\\\u200D\\\\u2010-\\\\u2029\\\\u202F-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFEF\" : \"\") + \"]\";\nconst HEXDIG$$ = \"[0-9A-Fa-f]\";  //case-insensitive\nconst PCT_ENCODED$ = subexp(subexp(\"%[EFef]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%[89A-Fa-f]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%\" + HEXDIG$$ + HEXDIG$$));  //expanded\n\n//RFC 5322, except these symbols as per RFC 6068: @ : / ? # [ ] & ; =\n//const ATEXT$$ = \"[A-Za-z0-9\\\\!\\\\#\\\\$\\\\%\\\\&\\\\'\\\\*\\\\+\\\\-\\\\/\\\\=\\\\?\\\\^\\\\_\\\\`\\\\{\\\\|\\\\}\\\\~]\";\n//const WSP$$ = \"[\\\\x20\\\\x09]\";\n//const OBS_QTEXT$$ = \"[\\\\x01-\\\\x08\\\\x0B\\\\x0C\\\\x0E-\\\\x1F\\\\x7F]\";  //(%d1-8 / %d11-12 / %d14-31 / %d127)\n//const QTEXT$$ = merge(\"[\\\\x21\\\\x23-\\\\x5B\\\\x5D-\\\\x7E]\", OBS_QTEXT$$);  //%d33 / %d35-91 / %d93-126 / obs-qtext\n//const VCHAR$$ = \"[\\\\x21-\\\\x7E]\";\n//const WSP$$ = \"[\\\\x20\\\\x09]\";\n//const OBS_QP$ = subexp(\"\\\\\\\\\" + merge(\"[\\\\x00\\\\x0D\\\\x0A]\", OBS_QTEXT$$));  //%d0 / CR / LF / obs-qtext\n//const FWS$ = subexp(subexp(WSP$$ + \"*\" + \"\\\\x0D\\\\x0A\") + \"?\" + WSP$$ + \"+\");\n//const QUOTED_PAIR$ = subexp(subexp(\"\\\\\\\\\" + subexp(VCHAR$$ + \"|\" + WSP$$)) + \"|\" + OBS_QP$);\n//const QUOTED_STRING$ = subexp('\\\\\"' + subexp(FWS$ + \"?\" + QCONTENT$) + \"*\" + FWS$ + \"?\" + '\\\\\"');\nconst ATEXT$$ = \"[A-Za-z0-9\\\\!\\\\$\\\\%\\\\'\\\\*\\\\+\\\\-\\\\^\\\\_\\\\`\\\\{\\\\|\\\\}\\\\~]\";\nconst QTEXT$$ = \"[\\\\!\\\\$\\\\%\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\-\\\\.0-9\\\\<\\\\>A-Z\\\\x5E-\\\\x7E]\";\nconst VCHAR$$ = merge(QTEXT$$, \"[\\\\\\\"\\\\\\\\]\");\nconst DOT_ATOM_TEXT$ = subexp(ATEXT$$ + \"+\" + subexp(\"\\\\.\" + ATEXT$$ + \"+\") + \"*\");\nconst QUOTED_PAIR$ = subexp(\"\\\\\\\\\" + VCHAR$$);\nconst QCONTENT$ = subexp(QTEXT$$ + \"|\" + QUOTED_PAIR$);\nconst QUOTED_STRING$ = subexp('\\\\\"' + QCONTENT$ + \"*\" + '\\\\\"');\n\n//RFC 6068\nconst DTEXT_NO_OBS$$ = \"[\\\\x21-\\\\x5A\\\\x5E-\\\\x7E]\";  //%d33-90 / %d94-126\nconst SOME_DELIMS$$ = \"[\\\\!\\\\$\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\;\\\\:\\\\@]\";\nconst QCHAR$ = subexp(UNRESERVED$$ + \"|\" + PCT_ENCODED$ + \"|\" + SOME_DELIMS$$);\nconst DOMAIN$ = subexp(DOT_ATOM_TEXT$ + \"|\" + \"\\\\[\" + DTEXT_NO_OBS$$ + \"*\" + \"\\\\]\");\nconst LOCAL_PART$ = subexp(DOT_ATOM_TEXT$ + \"|\" + QUOTED_STRING$);\nconst ADDR_SPEC$ = subexp(LOCAL_PART$ + \"\\\\@\" + DOMAIN$);\nconst TO$ = subexp(ADDR_SPEC$ + subexp(\"\\\\,\" + ADDR_SPEC$) + \"*\");\nconst HFNAME$ = subexp(QCHAR$ + \"*\");\nconst HFVALUE$ = HFNAME$;\nconst HFIELD$ = subexp(HFNAME$ + \"\\\\=\" + HFVALUE$);\nconst HFIELDS2$ = subexp(HFIELD$ + subexp(\"\\\\&\" + HFIELD$) + \"*\");\nconst HFIELDS$ = subexp(\"\\\\?\" + HFIELDS2$);\nconst MAILTO_URI = new RegExp(\"^mailto\\\\:\" + TO$ + \"?\" + HFIELDS$ + \"?$\");\n\nconst UNRESERVED = new RegExp(UNRESERVED$$, \"g\");\nconst PCT_ENCODED = new RegExp(PCT_ENCODED$, \"g\");\nconst NOT_LOCAL_PART = new RegExp(merge(\"[^]\", ATEXT$$, \"[\\\\.]\", '[\\\\\"]', VCHAR$$), \"g\");\nconst NOT_DOMAIN = new RegExp(merge(\"[^]\", ATEXT$$, \"[\\\\.]\", \"[\\\\[]\", DTEXT_NO_OBS$$, \"[\\\\]]\"), \"g\");\nconst NOT_HFNAME = new RegExp(merge(\"[^]\", UNRESERVED$$, SOME_DELIMS$$), \"g\");\nconst NOT_HFVALUE = NOT_HFNAME;\nconst TO = new RegExp(\"^\" + TO$ + \"$\");\nconst HFIELDS = new RegExp(\"^\" + HFIELDS2$ + \"$\");\n\nfunction decodeUnreserved(str:string):string {\n\tconst decStr = pctDecChars(str);\n\treturn (!decStr.match(UNRESERVED) ? str : decStr);\n}\n\nconst handler:URISchemeHandler<MailtoComponents> =  {\n\tscheme : \"mailto\",\n\n\tparse : function (components:URIComponents, options:URIOptions):MailtoComponents {\n\t\tconst mailtoComponents = components as MailtoComponents;\n\t\tconst to = mailtoComponents.to = (mailtoComponents.path ? mailtoComponents.path.split(\",\") : []);\n\t\tmailtoComponents.path = undefined;\n\n\t\tif (mailtoComponents.query) {\n\t\t\tlet unknownHeaders = false\n\t\t\tconst headers:MailtoHeaders = {};\n\t\t\tconst hfields = mailtoComponents.query.split(\"&\");\n\n\t\t\tfor (let x = 0, xl = hfields.length; x < xl; ++x) {\n\t\t\t\tconst hfield = hfields[x].split(\"=\");\n\n\t\t\t\tswitch (hfield[0]) {\n\t\t\t\t\tcase \"to\":\n\t\t\t\t\t\tconst toAddrs = hfield[1].split(\",\");\n\t\t\t\t\t\tfor (let x = 0, xl = toAddrs.length; x < xl; ++x) {\n\t\t\t\t\t\t\tto.push(toAddrs[x]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"subject\":\n\t\t\t\t\t\tmailtoComponents.subject = unescapeComponent(hfield[1], options);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"body\":\n\t\t\t\t\t\tmailtoComponents.body = unescapeComponent(hfield[1], options);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tunknownHeaders = true;\n\t\t\t\t\t\theaders[unescapeComponent(hfield[0], options)] = unescapeComponent(hfield[1], options);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (unknownHeaders) mailtoComponents.headers = headers;\n\t\t}\n\n\t\tmailtoComponents.query = undefined;\n\n\t\tfor (let x = 0, xl = to.length; x < xl; ++x) {\n\t\t\tconst addr = to[x].split(\"@\");\n\n\t\t\taddr[0] = unescapeComponent(addr[0]);\n\n\t\t\tif (!options.unicodeSupport) {\n\t\t\t\t//convert Unicode IDN -> ASCII IDN\n\t\t\t\ttry {\n\t\t\t\t\taddr[1] = punycode.toASCII(unescapeComponent(addr[1], options).toLowerCase());\n\t\t\t\t} catch (e) {\n\t\t\t\t\tmailtoComponents.error = mailtoComponents.error || \"Email address's domain name can not be converted to ASCII via punycode: \" + e;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\taddr[1] = unescapeComponent(addr[1], options).toLowerCase();\n\t\t\t}\n\n\t\t\tto[x] = addr.join(\"@\");\n\t\t}\n\n\t\treturn mailtoComponents;\n\t},\n\n\tserialize : function (mailtoComponents:MailtoComponents, options:URIOptions):URIComponents {\n\t\tconst components = mailtoComponents as URIComponents;\n\t\tconst to = toArray(mailtoComponents.to);\n\t\tif (to) {\n\t\t\tfor (let x = 0, xl = to.length; x < xl; ++x) {\n\t\t\t\tconst toAddr = String(to[x]);\n\t\t\t\tconst atIdx = toAddr.lastIndexOf(\"@\");\n\t\t\t\tconst localPart = (toAddr.slice(0, atIdx)).replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_LOCAL_PART, pctEncChar);\n\t\t\t\tlet domain = toAddr.slice(atIdx + 1);\n\n\t\t\t\t//convert IDN via punycode\n\t\t\t\ttry {\n\t\t\t\t\tdomain = (!options.iri ? punycode.toASCII(unescapeComponent(domain, options).toLowerCase()) : punycode.toUnicode(domain));\n\t\t\t\t} catch (e) {\n\t\t\t\t\tcomponents.error = components.error || \"Email address's domain name can not be converted to \" + (!options.iri ? \"ASCII\" : \"Unicode\") + \" via punycode: \" + e;\n\t\t\t\t}\n\n\t\t\t\tto[x] = localPart + \"@\" + domain;\n\t\t\t}\n\n\t\t\tcomponents.path = to.join(\",\");\n\t\t}\n\n\t\tconst headers = mailtoComponents.headers = mailtoComponents.headers || {};\n\n\t\tif (mailtoComponents.subject) headers[\"subject\"] = mailtoComponents.subject;\n\t\tif (mailtoComponents.body) headers[\"body\"] = mailtoComponents.body;\n\n\t\tconst fields = [];\n\t\tfor (const name in headers) {\n\t\t\tif (headers[name] !== O[name]) {\n\t\t\t\tfields.push(\n\t\t\t\t\tname.replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFNAME, pctEncChar) +\n\t\t\t\t\t\"=\" +\n\t\t\t\t\theaders[name].replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFVALUE, pctEncChar)\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\tif (fields.length) {\n\t\t\tcomponents.query = fields.join(\"&\");\n\t\t}\n\n\t\treturn components;\n\t}\n}\n\nexport default handler;","import { URISchemeHandler, URIComponents, URIOptions } from \"../uri\";\nimport { pctEncChar, SCHEMES } from \"../uri\";\n\nexport interface URNComponents extends URIComponents {\n\tnid?:string;\n\tnss?:string;\n}\n\nexport interface URNOptions extends URIOptions {\n\tnid?:string;\n}\n\nconst NID$ = \"(?:[0-9A-Za-z][0-9A-Za-z\\\\-]{1,31})\";\nconst PCT_ENCODED$ = \"(?:\\\\%[0-9A-Fa-f]{2})\";\nconst TRANS$$ = \"[0-9A-Za-z\\\\(\\\\)\\\\+\\\\,\\\\-\\\\.\\\\:\\\\=\\\\@\\\\;\\\\$\\\\_\\\\!\\\\*\\\\'\\\\/\\\\?\\\\#]\";\nconst NSS$ = \"(?:(?:\" + PCT_ENCODED$ + \"|\" + TRANS$$ + \")+)\";\nconst URN_SCHEME = new RegExp(\"^urn\\\\:(\" + NID$ + \")$\");\nconst URN_PATH = new RegExp(\"^(\" + NID$ + \")\\\\:(\" + NSS$ + \")$\");\nconst URN_PARSE = /^([^\\:]+)\\:(.*)/;\nconst URN_EXCLUDED = /[\\x00-\\x20\\\\\\\"\\&\\<\\>\\[\\]\\^\\`\\{\\|\\}\\~\\x7F-\\xFF]/g;\n\n//RFC 2141\nconst handler:URISchemeHandler<URNComponents,URNOptions> = {\n\tscheme : \"urn\",\n\n\tparse : function (components:URIComponents, options:URNOptions):URNComponents {\n\t\tconst matches = components.path && components.path.match(URN_PARSE);\n\t\tlet urnComponents = components as URNComponents;\n\n\t\tif (matches) {\n\t\t\tconst scheme = options.scheme || urnComponents.scheme || \"urn\";\n\t\t\tconst nid = matches[1].toLowerCase();\n\t\t\tconst nss = matches[2];\n\t\t\tconst urnScheme = `${scheme}:${options.nid || nid}`;\n\t\t\tconst schemeHandler = SCHEMES[urnScheme];\n\n\t\t\turnComponents.nid = nid;\n\t\t\turnComponents.nss = nss;\n\t\t\turnComponents.path = undefined;\n\n\t\t\tif (schemeHandler) {\n\t\t\t\turnComponents = schemeHandler.parse(urnComponents, options) as URNComponents;\n\t\t\t}\n\t\t} else {\n\t\t\turnComponents.error = urnComponents.error || \"URN can not be parsed.\";\n\t\t}\n\n\t\treturn urnComponents;\n\t},\n\n\tserialize : function (urnComponents:URNComponents, options:URNOptions):URIComponents {\n\t\tconst scheme = options.scheme || urnComponents.scheme || \"urn\";\n\t\tconst nid = urnComponents.nid;\n\t\tconst urnScheme = `${scheme}:${options.nid || nid}`;\n\t\tconst schemeHandler = SCHEMES[urnScheme];\n\n\t\tif (schemeHandler) {\n\t\t\turnComponents = schemeHandler.serialize(urnComponents, options) as URNComponents;\n\t\t}\n\n\t\tconst uriComponents = urnComponents as URIComponents;\n\t\tconst nss = urnComponents.nss;\n\t\turiComponents.path = `${nid || options.nid}:${nss}`;\n\n\t\treturn uriComponents;\n\t},\n};\n\nexport default handler;","import { URISchemeHandler, URIComponents, URIOptions } from \"../uri\";\nimport { URNComponents } from \"./urn\";\nimport { SCHEMES } from \"../uri\";\n\nexport interface UUIDComponents extends URNComponents {\n\tuuid?: string;\n}\n\nconst UUID = /^[0-9A-Fa-f]{8}(?:\\-[0-9A-Fa-f]{4}){3}\\-[0-9A-Fa-f]{12}$/;\nconst UUID_PARSE = /^[0-9A-Fa-f\\-]{36}/;\n\n//RFC 4122\nconst handler:URISchemeHandler<UUIDComponents, URIOptions, URNComponents> = {\n\tscheme : \"urn:uuid\",\n\n\tparse : function (urnComponents:URNComponents, options:URIOptions):UUIDComponents {\n\t\tconst uuidComponents = urnComponents as UUIDComponents;\n\t\tuuidComponents.uuid = uuidComponents.nss;\n\t\tuuidComponents.nss = undefined;\n\n\t\tif (!options.tolerant && (!uuidComponents.uuid || !uuidComponents.uuid.match(UUID))) {\n\t\t\tuuidComponents.error = uuidComponents.error || \"UUID is not valid.\";\n\t\t}\n\n\t\treturn uuidComponents;\n\t},\n\n\tserialize : function (uuidComponents:UUIDComponents, options:URIOptions):URNComponents {\n\t\tconst urnComponents = uuidComponents as URNComponents;\n\t\t//normalize UUID\n\t\turnComponents.nss = (uuidComponents.uuid || \"\").toLowerCase();\n\t\treturn urnComponents;\n\t},\n};\n\nexport default handler;","import { SCHEMES } from \"./uri\";\n\nimport http from \"./schemes/http\";\nSCHEMES[http.scheme] = http;\n\nimport https from \"./schemes/https\";\nSCHEMES[https.scheme] = https;\n\nimport ws from \"./schemes/ws\";\nSCHEMES[ws.scheme] = ws;\n\nimport wss from \"./schemes/wss\";\nSCHEMES[wss.scheme] = wss;\n\nimport mailto from \"./schemes/mailto\";\nSCHEMES[mailto.scheme] = mailto;\n\nimport urn from \"./schemes/urn\";\nSCHEMES[urn.scheme] = urn;\n\nimport uuid from \"./schemes/urn-uuid\";\nSCHEMES[uuid.scheme] = uuid;\n\nexport * from \"./uri\";\n"],"names":["core_1","require","draft7_1","discriminator_1","draft7MetaSchema","META_SUPPORT_DATA","META_SCHEMA_ID","default","_addVocabularies","forEach","addVocabulary","v","opts","discriminator","addKeyword","_addDefaultMetaSchema","meta","metaSchema","$data","$dataMetaSchema","addMetaSchema","refs","defaultMeta","getSchema","undefined","module","exports","Ajv","Object","defineProperty","value","validate_1","enumerable","get","KeywordCxt","codegen_1","_","str","stringify","nil","Name","CodeGen","validation_error_1","ref_error_1","_CodeOrName","toString","emptyStr","names","constructor","s","IDENTIFIER","test","_items","length","item","_a","_str","reduce","c","_names","code","strs","args","i","addCodeArg","push","_Code","plus","expr","safeStringify","optimize","a","b","res","slice","splice","arg","x","Array","isArray","join","JSON","replace","c1","c2","key","rx","code_1","scope_1","code_2","strConcat","getProperty","regexpCode","scope_2","Scope","ValueScope","ValueScopeName","varKinds","GT","GTE","LT","LTE","EQ","NEQ","NOT","OR","AND","ADD","optimizeNodes","optimizeNames","_constants","Node","render","es5","_n","varKind","var","rhs","name","constants","optimizeExpr","lhs","sideEffects","addExprNames","Assign","op","label","error","nodes","n","subtractNames","from","addNames","ParentNode","BlockNode","Else","kind","If","condition","else","cond","e","ns","not","For","iteration","to","loop","iterable","_async","async","Func","Return","catch","finally","_b","Catch","Finally","_root","prefix","_scope","scopeName","_extScope","scopeValue","prefixOrName","vs","_values","Set","add","getScopeValue","keyOrRef","getValue","scopeRefs","scopeCode","_def","nameOrPrefix","constant","toName","_leafNode","Def","const","_constant","let","assign","AssignOp","operators","AnyCode","object","keyValues","if","thenBody","elseBody","_blockNode","endIf","elseIf","_elseNode","_endBlockNode","_for","node","forBody","endFor","for","ForLoop","forRange","ForRange","forOf","arr","ForIter","forIn","obj","ownProperties","Label","break","Break","return","try","tryBody","catchCode","finallyCode","Try","_currNode","throw","Throw","block","body","nodeCount","_blockStarts","_nodes","endBlock","len","pop","toClose","func","funcBody","endFunc","N1","N2","extScope","lines","parent","Root","replaceName","some","items","par","andCode","mappend","orCode","y","UsedValueState","Error","_newName","ng","_nameGroup","index","_parent","_prefixes","has","prefixes","setValue","property","itemIndex","scopePath","nameStr","line","ref","valueKey","_name","Map","set","values","_reduceValues","usedValues","getCode","valueCode","nameSet","Started","def","ValueError","Completed","scope","util_1","names_1","addError","gen","errObj","err","vErrors","errors","returnErrors","it","errs","validateName","schemaEnv","$async","ValidationError","message","keyword","schemaType","cxt","keywordError","errorPaths","overrideAllErrors","compositeRule","allErrors","errorObjectCode","errsCount","schemaValue","data","instancePath","errorPath","errSchemaPath","verbose","E","schemaPath","params","propertyName","schema","parentSchema","createErrors","errorObject","errorInstancePath","instPath","getErrorPath","Type","Str","errorSchemaPath","schPath","extraErrorProps","topSchemaRef","messages","resolve_1","env","dynamicAnchors","schemaId","root","baseId","normalizeId","localRefs","compileSchema","sch","_ValidationError","sourceCode","_sch","getCompilingSchema","call","rootId","getFullPath","uriResolver","schemaCxt","parentData","parentDataProperty","dataNames","dataPathArr","dataLevel","dataTypes","definedProperties","source","jtd","self","_compilations","validateFunctionCode","validateCode","process","makeValidate","validate","scopeValues","unevaluated","props","evaluated","dynamicProps","dynamicItems","logger","delete","inlineOrCompile","inlineRef","inlineRefs","schEnv","s1","s2","resolve","schemas","resolveSchema","p","parse","refPath","_getFullPath","keys","getJsonPointer","id","schOrRef","schId","resolveUrl","SchemaEnv","schOrFunc","PREVENT_SCOPE_CHANGE","parsedRef","fragment","part","split","partSchema","unescapeFragment","$ref","schemaHasRulesButRef","RULES","valCxt","rootData","this","json","jsonPos","jsonLen","jsonPart","resolver","msg","missingRef","missingSchema","MissingRefError","equal","traverse","SIMPLE_INLINED","limit","hasRef","REF_KEYWORDS","countKeys","count","eachItem","Infinity","normalize","serialized","serialize","TRAILING_SLASH_HASH","ANCHOR","baseIds","pathPrefix","schemaRefs","allKeys","jsonPtr","parentJsonPtr","fullPath","addRef","_resolve","ambiguos","checkAmbiguosRef","addAnchor","anchor","$anchor","$dynamicAnchor","sch1","sch2","jsonTypes","groups","number","type","rules","string","array","types","integer","boolean","null","post","all","keywords","checkUnknownRules","strictSchema","checkStrictMode","schemaHasRules","escapeJsonPointer","unescapeJsonPointer","makeMergeEvaluated","mergeNames","mergeToName","mergeValues","resultToName","evaluatedPropsToName","ps","setEvaluated","hash","decodeURIComponent","encodeURIComponent","xs","f","Math","max","snippets","mode","warn","dataProp","dataPropType","jsPropertySyntax","isNumber","Num","shouldUseGroup","group","shouldUseRule","rule","definition","implements","kwd","errors_1","boolError","falseSchemaError","reportError","schemaCode","valid","DataType","rules_1","applicability_1","getJSONTypes","ts","every","isJSONType","hasNull","includes","nullable","coerceTypes","coerceTo","filter","COERCIBLE","t","checkTypes","schemaHasRulesForType","wrongType","checkDataTypes","strictNumbers","Wrong","coerceData","dataType","coerced","coerceSpecificType","reportTypeError","assignParentData","checkDataType","strictNums","correct","Correct","numCond","_cond","and","toHash","notObj","typeError","getTypeErrorContext","schemaRefOrVal","assignDefault","prop","defaultValue","childData","useDefaults","ty","properties","boolSchema_1","dataType_1","dataType_2","defaults_1","keyword_1","subschema_1","validateFunction","funcSourceUrl","destructureValCxtES5","dynamicRef","schemaCxtHasRules","isSchemaObj","checkKeywords","checkRefsAndKeywords","ignoreKeywordsWithRef","typeAndKeywords","schemaKeywords","getSchemaTypes","checkedTypes","coerceAndCheckDataType","commentKeyword","$comment","rootName","typeErrors","keywordCode","groupKeywords","iterateKeywords","strictTypes","checkContextTypes","includesType","strictTypesError","narrowSchemaTypes","withTypes","allowUnionTypes","checkKeywordTypes","schTs","kwdT","assignDefaults","topSchemaObjCode","checkNoDefault","resetEvaluated","returnResults","assignEvaluated","topBoolOrEmptySchema","result","successAction","failAction","failResult","pass","fail","fail$data","or","invalid$data","append","errorParams","setParams","_error","reportExtraError","$dataError","keyword$DataError","reset","resetErrorsCount","ok","block$data","codeBlock","$dataValid","check$data","validateSchema","wrong$DataType","st","invalid$DataSchema","validateSchemaRef","subschema","appl","getSubschema","extendSubschemaData","extendSubschemaMode","nextContext","subschemaCode","subSchemaObjCode","updateContext","checkAsyncSchema","boolOrEmptySchema","mergeEvaluated","mergeValidEvaluated","validateKeywordUsage","getData","validSchemaType","allowUndefined","trackErrors","ruleType","funcKeywordCode","macroKeywordCode","compile","JSON_POINTER","RELATIVE_JSON_POINTER","jsonPointer","matches","exec","up","errorMsg","segments","segment","pointerType","modifyData","useKeyword","macroSchema","macro","schemaRef","checkAsyncKeyword","validateRef","assignValid","_await","passCxt","passContext","passSchema","callValidateCode","modifying","reportErrs","ruleErrs","validateAsync","validateSync","validateErrs","addErrs","extendErrors","deps","dependencies","prototype","hasOwnProperty","errorsText","schemaProp","escapeFragment","dpType","nextData","dataContextProps","_nextData","jtdDiscriminator","jtdMetadata","compile_1","codegen_2","$dataRefSchema","uri_1","defaultRegExp","flags","RegExp","META_IGNORE_OPTIONS","EXT_SCOPE_NAMES","removedOptions","errorDataPath","format","jsonPointers","extendRefs","missingRefs","processCode","strictDefaults","strictKeywords","uniqueItems","unknownFormats","cache","ajvErrors","deprecatedOptions","unicode","_dataRefSchema","$id","schemaKeyRef","_meta","_addSchema","_compileSchemaEnv","compileAsync","loadSchema","runCompileAsync","_schema","loadMetaSchema","$schema","_compileAsync","checkLoaded","loadMissingSchema","_loadSchema","addSchema","_loading","_validateSchema","_checkUnique","throwOrLogError","keyRef","getSchEnv","removeSchema","_removeAllSchemas","_cache","clear","definitions","kwdOrDef","checkKeyword","addRule","keywordMetaschema","k","getKeyword","removeKeyword","findIndex","addFormat","formats","separator","dataVar","map","text","keywordsJsonPointers","seg","schemaOrData","regex","addUsedSchema","getSchemaRefs","startsWith","_compileMetaSchema","currentOpts","_metaOpts","requiredOptions","o","strict","_optz","regExp","_c","_d","_f","_e","_h","_g","_k","_j","strictTuples","_m","_l","strictRequired","_p","_o","loopRequired","_q","loopEnum","_r","_s","_t","_u","_v","_w","_x","validateFormats","_y","unicodeRegExp","_z","int32range","_0","getLogger","noLogs","console","log","formatOpt","getRules","checkOptions","getMetaSchemaOptions","addInitialFormats","addInitialKeywords","addInitialSchemas","checkOpts","options","optsSchemas","defs","metaOpts","opt","KEYWORD_NAME","ruleGroup","find","before","addBeforeRule","_rule","$dataRef","anyOf","ucs2length","pos","charCodeAt","uri","ajv","validation","validateAdditionalItems","alwaysValidSchema","additionalProperty","removeAdditional","allSchemaProperties","patProps","patternProperties","deleteAdditional","additionalPropertyCode","applyAdditionalSchema","isAdditional","definedProp","propsSchema","isOwnProperty","usePattern","schCxt","validateUnion","min","minContains","maxContains","next","validateItemsWithCount","schValid","validateItems","_valid","depsCount","missingProperty","propDeps","schDeps","splitDependencies","propertyDeps","schemaDeps","validatePropertyDeps","validateSchemaDeps","missing","hasProperty","propertyInData","depProp","checkReportMissingProp","checkMissingProp","reportMissingProp","hasSchema","ifClause","then","hasThen","hasElse","validateIf","validateClause","additionalItems_1","prefixItems_1","items_1","items2020_1","contains_1","dependencies_1","propertyNames_1","additionalProperties_1","properties_1","patternProperties_1","not_1","anyOf_1","oneOf_1","allOf_1","if_1","thenElse_1","draft2020","applicator","validateTuple","extraItems","schArr","checkStrictTuple","l","fullTuple","minItems","maxItems","validateArray","prefixItems","passing","util_2","patterns","alwaysValidPatterns","checkProperties","allowMatchingProperties","validateProperties","pat","alwaysValid","validatePatternProperties","checkMatchingProperties","additionalProperties","allProps","applyPropertySchema","hasPropFunc","noPropertyInData","schemaMap","context","dataAndSchema","newRegExp","pattern","u","useFunc","validArr","notValid","merged","id_1","ref_1","core","getValidate","callRef","addErrorsFrom","addEvaluatedFrom","schEvaluated","callAsyncRef","callRootRef","schOrEnv","resolveRef","callValidate","inlineRefSchema","schName","types_1","discrError","tagName","DiscrError","Tag","tag","oneOf","mapping","validateMapping","getMapping","oneOfMapping","topRequired","hasRequired","tagRequired","propSch","addMappings","addMapping","enum","tagValue","required","applyTagSchema","Mapping","validation_1","applicator_1","format_1","metadata_1","draft7Vocabularies","metadataVocabulary","contentVocabulary","validate$DataFormat","fmts","fDef","fType","invalidFmt","callFormat","validData","validateFormat","formatDef","unknownFormat","unknownMsg","fmtType","fmtRef","getFormat","fmtDef","fmt","validCondition","equal_1","eql","useLoop","getEql","vSchema","equalCode","limitNumber_1","multipleOf_1","limitLength_1","pattern_1","limitProperties_1","required_1","limitItems_1","uniqueItems_1","const_1","enum_1","ucs2length_1","ops","KWDs","maximum","okStr","minimum","exclusiveMaximum","exclusiveMinimum","prec","multipleOfPrecision","invalid","allErrorsMode","loopAllRequired","exitOnErrorMode","requiredKey","j","itemTypes","canOptimize","indices","outer","cb","pre","_traverse","rootSchema","parentKeyword","keyIndex","arrayKeywords","propsKeywords","skipKeywords","additionalItems","contains","propertyNames","allOf","$defs","multipleOf","maxLength","minLength","maxProperties","minProperties","valueOf","merge","sets","_len","_key","arguments","xl","subexp","typeOf","shift","toLowerCase","toUpperCase","buildExps","isIRI","ALPHA$$","DIGIT$$","HEXDIG$$","PCT_ENCODED$","SUB_DELIMS$$","RESERVED$$","SCHEME$","USERINFO$","UNRESERVED$$","DEC_OCTET_RELAXED$","H16$","LS32$","IPV4ADDRESS$","IPV6ADDRESS1$","IPV6ADDRESS2$","IPV6ADDRESS3$","IPV6ADDRESS4$","IPV6ADDRESS5$","IPV6ADDRESS6$","IPV6ADDRESS7$","IPV6ADDRESS8$","IPV6ADDRESS9$","ZONEID$","IPV6ADDRESS$","IP_LITERAL$","IPV6ADDRZ_RELAXED$","IPVFUTURE$","HOST$","REG_NAME$","PORT$","AUTHORITY$","PCHAR$","SEGMENT$","SEGMENT_NZ$","SEGMENT_NZ_NC$","PATH_ABEMPTY$","PATH_ABSOLUTE$","QUERY$","PATH_NOSCHEME$","PATH_ROOTLESS$","PATH_EMPTY$","IPRIVATE$$","FRAGMENT$","HIER_PART$","URI$","RELATIVE_PART$","RELATIVE$","URI_PROTOCOL","IRI_PROTOCOL","regexPunycode","regexNonASCII","regexSeparators","floor","stringFromCharCode","String","fromCharCode","mapDomain","fn","parts","ucs2decode","output","counter","extra","digitToBasic","digit","flag","adapt","delta","numPoints","firstTime","baseMinusTMin","base","decode","input","inputLength","bias","basic","lastIndexOf","oldi","w","codePoint","maxInt","baseMinusT","out","fromCodePoint","apply","encode","_step","Symbol","iterator","_iteratorNormalCompletion","_iterator","done","currentValue","basicLength","handledCPCount","m","_step2","_iteratorNormalCompletion2","_iterator2","handledCPCountPlusOne","_step3","_iteratorNormalCompletion3","_iterator3","q","qMinusT","punycode","toConsumableArray","SCHEMES","pctEncChar","chr","pctDecChars","newStr","il","parseInt","substr","c3","_normalizeComponentEncoding","components","protocol","decodeUnreserved","decStr","match","UNRESERVED","scheme","PCT_ENCODED","NOT_SCHEME","userinfo","NOT_USERINFO","host","NOT_HOST","path","NOT_PATH","NOT_PATH_NOSCHEME","query","NOT_QUERY","NOT_FRAGMENT","_stripLeadingZeros","_normalizeIPv4","address","_matches","IPV4ADDRESS","_normalizeIPv6","IPV6ADDRESS","_matches2","zone","reverse","last","_address$toLowerCase$2","first","firstFields","lastFields","isLastFieldIPv4Address","fieldCount","lastFieldsStart","fields","longestZeroFields","allZeroFields","acc","field","lastLongest","sort","newHost","newFirst","newLast","URI_PARSE","NO_MATCH_IS_UNDEFINED","uriString","iri","reference","port","isNaN","indexOf","schemeHandler","unicodeSupport","domainHost","toASCII","RDS1","RDS2","RDS3","RDS5","removeDotSegments","im","uriTokens","toUnicode","authority","$1","$2","charAt","absolutePath","resolveComponents","relative","skipNormalization","target","tolerant","unescapeComponent","handler","secure","http","isSecure","wsComponents","resourceName","_wsComponents$resourc2","ws","O","VCHAR$$","NOT_LOCAL_PART","NOT_HFNAME","mailtoComponents","unknownHeaders","headers","hfields","hfield","toAddrs","subject","addr","setInterval","toAddr","atIdx","localPart","domain","URN_PARSE","urnComponents","nid","nss","uriComponents","UUID","uuid","uuidComponents","https","wss","mailto","urn","baseURI","relativeURI","schemelessOptions","uriA","uriB","ESCAPE"],"sourceRoot":""}